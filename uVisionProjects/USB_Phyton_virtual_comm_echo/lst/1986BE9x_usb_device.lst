L 1 "src\1986BE9x_usb_device.c"
N/**
N  ******************************************************************************
N  * @file    USB_Library\1986BE9x_usb_device.c
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    21/02/2011
N  * @brief   This file contains implementation of the EndPoint and Device basic
N  *          functionality as of USB Specification Rev.2 Chapter 9.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE 1986BE9x_usb_device.c
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include "opora.h"
L 1 ".\inc\opora.h" 1
N/**
N  ******************************************************************************
N  * @file	 OPORA.h
N  * @author  Phyton Application Team and Milandr Application Team
N  * @version V1.0.0
N  * @date	 08/09/2011
N  * @brief	 This file contains all the Special Function Registers definitions
N  * 		 for the Milandr 1986VE1 microcontroller.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON AND MILANDR SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE OPORA.h
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_H
N#define __OPORA_H
N
N/**
N  * @brief 1986VE1 Interrupt Number Definition
N  */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M1 Hard Fault Interrupt                     */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M1 SV Call Interrupt                       */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M1 Pend SV Interrupt                       */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M1 System Tick Interrupt                   */
N
N/****** MDR32Fx specific Interrupt Numbers *******************************************************/
N  MIL_STD_1553B2_IRQn         = 0,      /*!< MIL_STD_1553B2 Interrupt                             */
N  MIL_STD_1553B1_IRQn         = 1,      /*!< MIL_STD_1553B1 Interrupt                             */
N  USB_IRQn                    = 2,      /*!< USB Host Interrupt                                   */
N  CAN1_IRQn					  = 3,		/*!< CAN1 Interrupt										  */
N  CAN2_IRQn					  = 4,		/*!< CAN2 Interrupt										  */
N  DMA_IRQn                    = 5,      /*!< DMA Interrupt                                        */
N  UART1_IRQn                  = 6,      /*!< UART1 Interrupt                                      */
N  UART2_IRQn                  = 7,      /*!< UART2 Interrupt                                      */
N  SSP1_IRQn                   = 8,      /*!< SSP1 Interrupt                                       */
N  BUSY_IRQn					  = 9,		/*!< BUSY Interrupt										  */
N  ARINC429R_IRQn              = 10,     /*!< ARINC429 Receiver Interrupt                          */
N  POWER_IRQn                  = 11,     /*!< POWER Detecor Interrupt                              */
N  WWDG_IRQn                   = 12,     /*!< Window Watchdog Interrupt                            */
N  TIMER4_IRQn				  = 13,		/*!< Timer4 Interrupt									  */
N  TIMER1_IRQn                 = 14,     /*!< Timer1 Interrupt                                     */
N  TIMER2_IRQn                 = 15,     /*!< Timer2 Interrupt                                     */
N  TIMER3_IRQn                 = 16,     /*!< Timer3 Interrupt                                     */
N  ADC_IRQn                    = 17,     /*!< ADC Interrupt                                        */
N  ETHERNET_IRQn        	      = 18,     /*!< Ethernet Interrupt                                   */
N  SSP3_IRQn			          = 19,     /*!< SSP3 Interrupt                                 	  */
N  SSP2_IRQn                   = 20,     /*!< SSP2 Interrupt                                       */
N  ARINC429T1_IRQn			  = 21,		/*!< ARINC429 Transmitter 1 Interrupt					  */
N  ARINC429T2_IRQn			  = 22,		/*!< ARINC429 Transmitter 2 Interrupt					  */
N  ARINC429T3_IRQn			  = 23,		/*!< ARINC429 Transmitter 3 Interrupt					  */
N  ARINC429T4_IRQn			  = 24,		/*!< ARINC429 Transmitter 4 Interrupt 					  */
N  BKP_IRQn		              = 27,     /*!< BACKUP Interrupt                                     */
N  EXT_INT1_IRQn               = 28,     /*!< EXT_INT1 Interrupt                                   */
N  EXT_INT2_IRQn               = 29,     /*!< EXT_INT2 Interrupt                                   */
N  EXT_INT3_IRQn               = 30,     /*!< EXT_INT3 Interrupt                                   */
N  EXT_INT4_IRQn               = 31      /*!< EXT_INT4 Interrupt                                   */
N}IRQn_Type;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm1.h"
L 1 ".\inc\core_cm1.h" 1
N/**************************************************************************//**
N * @file     core_cm1.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM1_CORE_H__
N#define __CM1_CORE_H__
N
N/** @addtogroup CMSIS_CM1_core_LintCinfiguration CMSIS CM1 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * .
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm1_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM1_CORE_H__ \n
N *     Info 750: local macro '__CM1_CORE_H__' (line 43, file./cm1_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm1_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm1_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM1_core_definitions CM1 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#define __CM1_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM1_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM1_CMSIS_VERSION       ((__CM1_CMSIS_VERSION_MAIN << 16) | __CM1_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 91 ".\inc\core_cm1.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
N  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM1_core_register CMSIS CM1 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM1_NVIC CMSIS CM1 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM1_NVIC */
N
N
N/** @addtogroup CMSIS_CM1_SCB CMSIS CM1 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM1_SCB */
N
N
N/** @addtogroup CMSIS_CM1_SysTick CMSIS CM1 SysTick
N  memory mapped structure for SysTick
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM1_SysTick */
N
N
N/** @addtogroup CMSIS_CM1_ITM CMSIS CM1 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM1_ITM */
N
N
N/** @addtogroup CMSIS_CM1_InterruptType CMSIS CM1 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM1_REV) && (__CM1_REV >= 0x200))
X#if ((0L) && (__CM1_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM1_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 0L && (__MPU_PRESENT == 1)
S/** @addtogroup CMSIS_CM1_MPU CMSIS CM1 MPU
S  memory mapped structure for Memory Protection Unit (MPU)
S  @{
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
S  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
S  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
S  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
S  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
S  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
S  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
S#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
S#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
S#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
S#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
S#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
S#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@}*/ /* end of group CMSIS_CM1_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM1_CoreDebug CMSIS CM1 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM1_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 0L && (__MPU_PRESENT == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
S  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM1_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler                 */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler              */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler                 */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler                 */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler              */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler             */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler          */
S
S#elif defined ( __CMCARM__ )
S  #define __ASM            #pragma asm                                /*!< #pragma asm for Phyton CMC-ARM Compiler      */
S  #define __INLINE                                                    /*!< no inline support in Phyton CMC-ARM Compiler */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5060750 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S *
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
N/*
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
N  return(__regBasePri);
N}
N*/
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
N /*
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N*/
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
N /*
Nstatic __INLINE uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
N  return(__regPriMask);
N}
N*/
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
N /*
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
N  __regPriMask = (priMask);
N}
N*/
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
N /*
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
N  return(__regFaultMask);
N}
N*/
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
N /*
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N*/
N/**
N * @brief  Return the Control Register value
N *
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S*
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif (defined (__CMCARM__)) /*----------------- Phyton CMC-ARM Compiler ---------------*/
S/* Phyton CMC-ARM specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM1_Core_FunctionInterface CMSIS CM1 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                (0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N *
N * @param  IRQn   The positive number of the external interrupt to disable
N *
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N *
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending,
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active,
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!0L) || (__Vendor_SysTickConfig == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1ul << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N
N/*@}*/ /* end of group CMSIS_CM1_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM1_CoreDebugInterface CMSIS CM1 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not.
N * The function returns '1' if a character is available and '0' if no character is available.
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N
N/*@}*/ /* end of group CMSIS_CM1_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM1_core_definitions */
N
N#endif /* __CM1_CORE_H__ */
N
N/*lint -restore */
L 82 ".\inc\opora.h" 2
N#include "opora_can_defs.h"
L 1 ".\inc\opora_can_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_can_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the CAN peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_can_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_CAN_DEFS_H
N#define __OPORA_CAN_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_CAN CAN
N  * @{
N  */
N
N/**
N  * @brief CAN_BUF_TypeDef ??? structure
N  */
N
Ntypedef struct {
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N} _CAN_BUF_TypeDef;
N
N/**
N  * @brief CAN_BUF_TypeDef0 ??? structure
N  */
N
Ntypedef struct {
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N} _CAN_BUF_TypeDef0;
N
N/** @defgroup Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_CAN_TypeDef CAN_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_01_CON;
X  volatile uint32_t BUF_01_CON;
N  __IO uint32_t BUF_02_CON;
X  volatile uint32_t BUF_02_CON;
N  __IO uint32_t BUF_03_CON;
X  volatile uint32_t BUF_03_CON;
N  __IO uint32_t BUF_04_CON;
X  volatile uint32_t BUF_04_CON;
N  __IO uint32_t BUF_05_CON;
X  volatile uint32_t BUF_05_CON;
N  __IO uint32_t BUF_06_CON;
X  volatile uint32_t BUF_06_CON;
N  __IO uint32_t BUF_07_CON;
X  volatile uint32_t BUF_07_CON;
N  __IO uint32_t BUF_08_CON;
X  volatile uint32_t BUF_08_CON;
N  __IO uint32_t BUF_09_CON;
X  volatile uint32_t BUF_09_CON;
N  __IO uint32_t BUF_10_CON;
X  volatile uint32_t BUF_10_CON;
N  __IO uint32_t BUF_11_CON;
X  volatile uint32_t BUF_11_CON;
N  __IO uint32_t BUF_12_CON;
X  volatile uint32_t BUF_12_CON;
N  __IO uint32_t BUF_13_CON;
X  volatile uint32_t BUF_13_CON;
N  __IO uint32_t BUF_14_CON;
X  volatile uint32_t BUF_14_CON;
N  __IO uint32_t BUF_15_CON;
X  volatile uint32_t BUF_15_CON;
N  __IO uint32_t BUF_16_CON;
X  volatile uint32_t BUF_16_CON;
N  __IO uint32_t BUF_17_CON;
X  volatile uint32_t BUF_17_CON;
N  __IO uint32_t BUF_18_CON;
X  volatile uint32_t BUF_18_CON;
N  __IO uint32_t BUF_19_CON;
X  volatile uint32_t BUF_19_CON;
N  __IO uint32_t BUF_20_CON;
X  volatile uint32_t BUF_20_CON;
N  __IO uint32_t BUF_21_CON;
X  volatile uint32_t BUF_21_CON;
N  __IO uint32_t BUF_22_CON;
X  volatile uint32_t BUF_22_CON;
N  __IO uint32_t BUF_23_CON;
X  volatile uint32_t BUF_23_CON;
N  __IO uint32_t BUF_24_CON;
X  volatile uint32_t BUF_24_CON;
N  __IO uint32_t BUF_25_CON;
X  volatile uint32_t BUF_25_CON;
N  __IO uint32_t BUF_26_CON;
X  volatile uint32_t BUF_26_CON;
N  __IO uint32_t BUF_27_CON;
X  volatile uint32_t BUF_27_CON;
N  __IO uint32_t BUF_28_CON;
X  volatile uint32_t BUF_28_CON;
N  __IO uint32_t BUF_29_CON;
X  volatile uint32_t BUF_29_CON;
N  __IO uint32_t BUF_30_CON;
X  volatile uint32_t BUF_30_CON;
N  __IO uint32_t BUF_31_CON;
X  volatile uint32_t BUF_31_CON;
N  __IO uint32_t BUF_32_CON;
X  volatile uint32_t BUF_32_CON;
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N  __IO uint32_t BUF_01_ID;
X  volatile uint32_t BUF_01_ID;
N  __IO uint32_t BUF_01_DLC;
X  volatile uint32_t BUF_01_DLC;
N  __IO uint32_t BUF_01_DATAL;
X  volatile uint32_t BUF_01_DATAL;
N  __IO uint32_t BUF_01_DATAH;
X  volatile uint32_t BUF_01_DATAH;
N  __IO uint32_t BUF_02_ID;
X  volatile uint32_t BUF_02_ID;
N  __IO uint32_t BUF_02_DLC;
X  volatile uint32_t BUF_02_DLC;
N  __IO uint32_t BUF_02_DATAL;
X  volatile uint32_t BUF_02_DATAL;
N  __IO uint32_t BUF_02_DATAH;
X  volatile uint32_t BUF_02_DATAH;
N  __IO uint32_t BUF_03_ID;
X  volatile uint32_t BUF_03_ID;
N  __IO uint32_t BUF_03_DLC;
X  volatile uint32_t BUF_03_DLC;
N  __IO uint32_t BUF_03_DATAL;
X  volatile uint32_t BUF_03_DATAL;
N  __IO uint32_t BUF_03_DATAH;
X  volatile uint32_t BUF_03_DATAH;
N  __IO uint32_t BUF_04_ID;
X  volatile uint32_t BUF_04_ID;
N  __IO uint32_t BUF_04_DLC;
X  volatile uint32_t BUF_04_DLC;
N  __IO uint32_t BUF_04_DATAL;
X  volatile uint32_t BUF_04_DATAL;
N  __IO uint32_t BUF_04_DATAH;
X  volatile uint32_t BUF_04_DATAH;
N  __IO uint32_t BUF_05_ID;
X  volatile uint32_t BUF_05_ID;
N  __IO uint32_t BUF_05_DLC;
X  volatile uint32_t BUF_05_DLC;
N  __IO uint32_t BUF_05_DATAL;
X  volatile uint32_t BUF_05_DATAL;
N  __IO uint32_t BUF_05_DATAH;
X  volatile uint32_t BUF_05_DATAH;
N  __IO uint32_t BUF_06_ID;
X  volatile uint32_t BUF_06_ID;
N  __IO uint32_t BUF_06_DLC;
X  volatile uint32_t BUF_06_DLC;
N  __IO uint32_t BUF_06_DATAL;
X  volatile uint32_t BUF_06_DATAL;
N  __IO uint32_t BUF_06_DATAH;
X  volatile uint32_t BUF_06_DATAH;
N  __IO uint32_t BUF_07_ID;
X  volatile uint32_t BUF_07_ID;
N  __IO uint32_t BUF_07_DLC;
X  volatile uint32_t BUF_07_DLC;
N  __IO uint32_t BUF_07_DATAL;
X  volatile uint32_t BUF_07_DATAL;
N  __IO uint32_t BUF_07_DATAH;
X  volatile uint32_t BUF_07_DATAH;
N  __IO uint32_t BUF_08_ID;
X  volatile uint32_t BUF_08_ID;
N  __IO uint32_t BUF_08_DLC;
X  volatile uint32_t BUF_08_DLC;
N  __IO uint32_t BUF_08_DATAL;
X  volatile uint32_t BUF_08_DATAL;
N  __IO uint32_t BUF_08_DATAH;
X  volatile uint32_t BUF_08_DATAH;
N  __IO uint32_t BUF_09_ID;
X  volatile uint32_t BUF_09_ID;
N  __IO uint32_t BUF_09_DLC;
X  volatile uint32_t BUF_09_DLC;
N  __IO uint32_t BUF_09_DATAL;
X  volatile uint32_t BUF_09_DATAL;
N  __IO uint32_t BUF_09_DATAH;
X  volatile uint32_t BUF_09_DATAH;
N  __IO uint32_t BUF_10_ID;
X  volatile uint32_t BUF_10_ID;
N  __IO uint32_t BUF_10_DLC;
X  volatile uint32_t BUF_10_DLC;
N  __IO uint32_t BUF_10_DATAL;
X  volatile uint32_t BUF_10_DATAL;
N  __IO uint32_t BUF_10_DATAH;
X  volatile uint32_t BUF_10_DATAH;
N  __IO uint32_t BUF_11_ID;
X  volatile uint32_t BUF_11_ID;
N  __IO uint32_t BUF_11_DLC;
X  volatile uint32_t BUF_11_DLC;
N  __IO uint32_t BUF_11_DATAL;
X  volatile uint32_t BUF_11_DATAL;
N  __IO uint32_t BUF_11_DATAH;
X  volatile uint32_t BUF_11_DATAH;
N  __IO uint32_t BUF_12_ID;
X  volatile uint32_t BUF_12_ID;
N  __IO uint32_t BUF_12_DLC;
X  volatile uint32_t BUF_12_DLC;
N  __IO uint32_t BUF_12_DATAL;
X  volatile uint32_t BUF_12_DATAL;
N  __IO uint32_t BUF_12_DATAH;
X  volatile uint32_t BUF_12_DATAH;
N  __IO uint32_t BUF_13_ID;
X  volatile uint32_t BUF_13_ID;
N  __IO uint32_t BUF_13_DLC;
X  volatile uint32_t BUF_13_DLC;
N  __IO uint32_t BUF_13_DATAL;
X  volatile uint32_t BUF_13_DATAL;
N  __IO uint32_t BUF_13_DATAH;
X  volatile uint32_t BUF_13_DATAH;
N  __IO uint32_t BUF_14_ID;
X  volatile uint32_t BUF_14_ID;
N  __IO uint32_t BUF_14_DLC;
X  volatile uint32_t BUF_14_DLC;
N  __IO uint32_t BUF_14_DATAL;
X  volatile uint32_t BUF_14_DATAL;
N  __IO uint32_t BUF_14_DATAH;
X  volatile uint32_t BUF_14_DATAH;
N  __IO uint32_t BUF_15_ID;
X  volatile uint32_t BUF_15_ID;
N  __IO uint32_t BUF_15_DLC;
X  volatile uint32_t BUF_15_DLC;
N  __IO uint32_t BUF_15_DATAL;
X  volatile uint32_t BUF_15_DATAL;
N  __IO uint32_t BUF_15_DATAH;
X  volatile uint32_t BUF_15_DATAH;
N  __IO uint32_t BUF_16_ID;
X  volatile uint32_t BUF_16_ID;
N  __IO uint32_t BUF_16_DLC;
X  volatile uint32_t BUF_16_DLC;
N  __IO uint32_t BUF_16_DATAL;
X  volatile uint32_t BUF_16_DATAL;
N  __IO uint32_t BUF_16_DATAH;
X  volatile uint32_t BUF_16_DATAH;
N  __IO uint32_t BUF_17_ID;
X  volatile uint32_t BUF_17_ID;
N  __IO uint32_t BUF_17_DLC;
X  volatile uint32_t BUF_17_DLC;
N  __IO uint32_t BUF_17_DATAL;
X  volatile uint32_t BUF_17_DATAL;
N  __IO uint32_t BUF_17_DATAH;
X  volatile uint32_t BUF_17_DATAH;
N  __IO uint32_t BUF_18_ID;
X  volatile uint32_t BUF_18_ID;
N  __IO uint32_t BUF_18_DLC;
X  volatile uint32_t BUF_18_DLC;
N  __IO uint32_t BUF_18_DATAL;
X  volatile uint32_t BUF_18_DATAL;
N  __IO uint32_t BUF_18_DATAH;
X  volatile uint32_t BUF_18_DATAH;
N  __IO uint32_t BUF_19_ID;
X  volatile uint32_t BUF_19_ID;
N  __IO uint32_t BUF_19_DLC;
X  volatile uint32_t BUF_19_DLC;
N  __IO uint32_t BUF_19_DATAL;
X  volatile uint32_t BUF_19_DATAL;
N  __IO uint32_t BUF_19_DATAH;
X  volatile uint32_t BUF_19_DATAH;
N  __IO uint32_t BUF_20_ID;
X  volatile uint32_t BUF_20_ID;
N  __IO uint32_t BUF_20_DLC;
X  volatile uint32_t BUF_20_DLC;
N  __IO uint32_t BUF_20_DATAL;
X  volatile uint32_t BUF_20_DATAL;
N  __IO uint32_t BUF_20_DATAH;
X  volatile uint32_t BUF_20_DATAH;
N  __IO uint32_t BUF_21_ID;
X  volatile uint32_t BUF_21_ID;
N  __IO uint32_t BUF_21_DLC;
X  volatile uint32_t BUF_21_DLC;
N  __IO uint32_t BUF_21_DATAL;
X  volatile uint32_t BUF_21_DATAL;
N  __IO uint32_t BUF_21_DATAH;
X  volatile uint32_t BUF_21_DATAH;
N  __IO uint32_t BUF_22_ID;
X  volatile uint32_t BUF_22_ID;
N  __IO uint32_t BUF_22_DLC;
X  volatile uint32_t BUF_22_DLC;
N  __IO uint32_t BUF_22_DATAL;
X  volatile uint32_t BUF_22_DATAL;
N  __IO uint32_t BUF_22_DATAH;
X  volatile uint32_t BUF_22_DATAH;
N  __IO uint32_t BUF_23_ID;
X  volatile uint32_t BUF_23_ID;
N  __IO uint32_t BUF_23_DLC;
X  volatile uint32_t BUF_23_DLC;
N  __IO uint32_t BUF_23_DATAL;
X  volatile uint32_t BUF_23_DATAL;
N  __IO uint32_t BUF_23_DATAH;
X  volatile uint32_t BUF_23_DATAH;
N  __IO uint32_t BUF_24_ID;
X  volatile uint32_t BUF_24_ID;
N  __IO uint32_t BUF_24_DLC;
X  volatile uint32_t BUF_24_DLC;
N  __IO uint32_t BUF_24_DATAL;
X  volatile uint32_t BUF_24_DATAL;
N  __IO uint32_t BUF_24_DATAH;
X  volatile uint32_t BUF_24_DATAH;
N  __IO uint32_t BUF_25_ID;
X  volatile uint32_t BUF_25_ID;
N  __IO uint32_t BUF_25_DLC;
X  volatile uint32_t BUF_25_DLC;
N  __IO uint32_t BUF_25_DATAL;
X  volatile uint32_t BUF_25_DATAL;
N  __IO uint32_t BUF_25_DATAH;
X  volatile uint32_t BUF_25_DATAH;
N  __IO uint32_t BUF_26_ID;
X  volatile uint32_t BUF_26_ID;
N  __IO uint32_t BUF_26_DLC;
X  volatile uint32_t BUF_26_DLC;
N  __IO uint32_t BUF_26_DATAL;
X  volatile uint32_t BUF_26_DATAL;
N  __IO uint32_t BUF_26_DATAH;
X  volatile uint32_t BUF_26_DATAH;
N  __IO uint32_t BUF_27_ID;
X  volatile uint32_t BUF_27_ID;
N  __IO uint32_t BUF_27_DLC;
X  volatile uint32_t BUF_27_DLC;
N  __IO uint32_t BUF_27_DATAL;
X  volatile uint32_t BUF_27_DATAL;
N  __IO uint32_t BUF_27_DATAH;
X  volatile uint32_t BUF_27_DATAH;
N  __IO uint32_t BUF_28_ID;
X  volatile uint32_t BUF_28_ID;
N  __IO uint32_t BUF_28_DLC;
X  volatile uint32_t BUF_28_DLC;
N  __IO uint32_t BUF_28_DATAL;
X  volatile uint32_t BUF_28_DATAL;
N  __IO uint32_t BUF_28_DATAH;
X  volatile uint32_t BUF_28_DATAH;
N  __IO uint32_t BUF_29_ID;
X  volatile uint32_t BUF_29_ID;
N  __IO uint32_t BUF_29_DLC;
X  volatile uint32_t BUF_29_DLC;
N  __IO uint32_t BUF_29_DATAL;
X  volatile uint32_t BUF_29_DATAL;
N  __IO uint32_t BUF_29_DATAH;
X  volatile uint32_t BUF_29_DATAH;
N  __IO uint32_t BUF_30_ID;
X  volatile uint32_t BUF_30_ID;
N  __IO uint32_t BUF_30_DLC;
X  volatile uint32_t BUF_30_DLC;
N  __IO uint32_t BUF_30_DATAL;
X  volatile uint32_t BUF_30_DATAL;
N  __IO uint32_t BUF_30_DATAH;
X  volatile uint32_t BUF_30_DATAH;
N  __IO uint32_t BUF_31_ID;
X  volatile uint32_t BUF_31_ID;
N  __IO uint32_t BUF_31_DLC;
X  volatile uint32_t BUF_31_DLC;
N  __IO uint32_t BUF_31_DATAL;
X  volatile uint32_t BUF_31_DATAL;
N  __IO uint32_t BUF_31_DATAH;
X  volatile uint32_t BUF_31_DATAH;
N  __IO uint32_t BUF_32_ID;
X  volatile uint32_t BUF_32_ID;
N  __IO uint32_t BUF_32_DLC;
X  volatile uint32_t BUF_32_DLC;
N  __IO uint32_t BUF_32_DATAL;
X  volatile uint32_t BUF_32_DATAL;
N  __IO uint32_t BUF_32_DATAH;
X  volatile uint32_t BUF_32_DATAH;
N       uint32_t RESERVED3[64];
N  __IO uint32_t BUF_01_MASK;
X  volatile uint32_t BUF_01_MASK;
N  __IO uint32_t BUF_01_FILTER;
X  volatile uint32_t BUF_01_FILTER;
N  __IO uint32_t BUF_02_MASK;
X  volatile uint32_t BUF_02_MASK;
N  __IO uint32_t BUF_02_FILTER;
X  volatile uint32_t BUF_02_FILTER;
N  __IO uint32_t BUF_03_MASK;
X  volatile uint32_t BUF_03_MASK;
N  __IO uint32_t BUF_03_FILTER;
X  volatile uint32_t BUF_03_FILTER;
N  __IO uint32_t BUF_04_MASK;
X  volatile uint32_t BUF_04_MASK;
N  __IO uint32_t BUF_04_FILTER;
X  volatile uint32_t BUF_04_FILTER;
N  __IO uint32_t BUF_05_MASK;
X  volatile uint32_t BUF_05_MASK;
N  __IO uint32_t BUF_05_FILTER;
X  volatile uint32_t BUF_05_FILTER;
N  __IO uint32_t BUF_06_MASK;
X  volatile uint32_t BUF_06_MASK;
N  __IO uint32_t BUF_06_FILTER;
X  volatile uint32_t BUF_06_FILTER;
N  __IO uint32_t BUF_07_MASK;
X  volatile uint32_t BUF_07_MASK;
N  __IO uint32_t BUF_07_FILTER;
X  volatile uint32_t BUF_07_FILTER;
N  __IO uint32_t BUF_08_MASK;
X  volatile uint32_t BUF_08_MASK;
N  __IO uint32_t BUF_08_FILTER;
X  volatile uint32_t BUF_08_FILTER;
N  __IO uint32_t BUF_09_MASK;
X  volatile uint32_t BUF_09_MASK;
N  __IO uint32_t BUF_09_FILTER;
X  volatile uint32_t BUF_09_FILTER;
N  __IO uint32_t BUF_10_MASK;
X  volatile uint32_t BUF_10_MASK;
N  __IO uint32_t BUF_10_FILTER;
X  volatile uint32_t BUF_10_FILTER;
N  __IO uint32_t BUF_11_MASK;
X  volatile uint32_t BUF_11_MASK;
N  __IO uint32_t BUF_11_FILTER;
X  volatile uint32_t BUF_11_FILTER;
N  __IO uint32_t BUF_12_MASK;
X  volatile uint32_t BUF_12_MASK;
N  __IO uint32_t BUF_12_FILTER;
X  volatile uint32_t BUF_12_FILTER;
N  __IO uint32_t BUF_13_MASK;
X  volatile uint32_t BUF_13_MASK;
N  __IO uint32_t BUF_13_FILTER;
X  volatile uint32_t BUF_13_FILTER;
N  __IO uint32_t BUF_14_MASK;
X  volatile uint32_t BUF_14_MASK;
N  __IO uint32_t BUF_14_FILTER;
X  volatile uint32_t BUF_14_FILTER;
N  __IO uint32_t BUF_15_MASK;
X  volatile uint32_t BUF_15_MASK;
N  __IO uint32_t BUF_15_FILTER;
X  volatile uint32_t BUF_15_FILTER;
N  __IO uint32_t BUF_16_MASK;
X  volatile uint32_t BUF_16_MASK;
N  __IO uint32_t BUF_16_FILTER;
X  volatile uint32_t BUF_16_FILTER;
N  __IO uint32_t BUF_17_MASK;
X  volatile uint32_t BUF_17_MASK;
N  __IO uint32_t BUF_17_FILTER;
X  volatile uint32_t BUF_17_FILTER;
N  __IO uint32_t BUF_18_MASK;
X  volatile uint32_t BUF_18_MASK;
N  __IO uint32_t BUF_18_FILTER;
X  volatile uint32_t BUF_18_FILTER;
N  __IO uint32_t BUF_19_MASK;
X  volatile uint32_t BUF_19_MASK;
N  __IO uint32_t BUF_19_FILTER;
X  volatile uint32_t BUF_19_FILTER;
N  __IO uint32_t BUF_20_MASK;
X  volatile uint32_t BUF_20_MASK;
N  __IO uint32_t BUF_20_FILTER;
X  volatile uint32_t BUF_20_FILTER;
N  __IO uint32_t BUF_21_MASK;
X  volatile uint32_t BUF_21_MASK;
N  __IO uint32_t BUF_21_FILTER;
X  volatile uint32_t BUF_21_FILTER;
N  __IO uint32_t BUF_22_MASK;
X  volatile uint32_t BUF_22_MASK;
N  __IO uint32_t BUF_22_FILTER;
X  volatile uint32_t BUF_22_FILTER;
N  __IO uint32_t BUF_23_MASK;
X  volatile uint32_t BUF_23_MASK;
N  __IO uint32_t BUF_23_FILTER;
X  volatile uint32_t BUF_23_FILTER;
N  __IO uint32_t BUF_24_MASK;
X  volatile uint32_t BUF_24_MASK;
N  __IO uint32_t BUF_24_FILTER;
X  volatile uint32_t BUF_24_FILTER;
N  __IO uint32_t BUF_25_MASK;
X  volatile uint32_t BUF_25_MASK;
N  __IO uint32_t BUF_25_FILTER;
X  volatile uint32_t BUF_25_FILTER;
N  __IO uint32_t BUF_26_MASK;
X  volatile uint32_t BUF_26_MASK;
N  __IO uint32_t BUF_26_FILTER;
X  volatile uint32_t BUF_26_FILTER;
N  __IO uint32_t BUF_27_MASK;
X  volatile uint32_t BUF_27_MASK;
N  __IO uint32_t BUF_27_FILTER;
X  volatile uint32_t BUF_27_FILTER;
N  __IO uint32_t BUF_28_MASK;
X  volatile uint32_t BUF_28_MASK;
N  __IO uint32_t BUF_28_FILTER;
X  volatile uint32_t BUF_28_FILTER;
N  __IO uint32_t BUF_29_MASK;
X  volatile uint32_t BUF_29_MASK;
N  __IO uint32_t BUF_29_FILTER;
X  volatile uint32_t BUF_29_FILTER;
N  __IO uint32_t BUF_30_MASK;
X  volatile uint32_t BUF_30_MASK;
N  __IO uint32_t BUF_30_FILTER;
X  volatile uint32_t BUF_30_FILTER;
N  __IO uint32_t BUF_31_MASK;
X  volatile uint32_t BUF_31_MASK;
N  __IO uint32_t BUF_31_FILTER;
X  volatile uint32_t BUF_31_FILTER;
N  __IO uint32_t BUF_32_MASK;
X  volatile uint32_t BUF_32_MASK;
N  __IO uint32_t BUF_32_FILTER;
X  volatile uint32_t BUF_32_FILTER;
N} CAN_TypeDef;
N
N/** @} */ /* End of group Periph_CAN_TypeDef */
N
N/** @} */ /* End of group Periph_CAN_Data_Structures */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_CONTROL_Bits CAN_CONTROL
N  * @{
N  */
N
N#define CAN_CONTROL_CAN_EN_OFFS                 0
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N
N#define CAN_CONTROL_ROM_OFFS                    1
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N
N#define CAN_CONTROL_STM_OFFS                    2
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N
N#define CAN_CONTROL_SAP_OFFS                    3
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N
N#define CAN_CONTROL_ROP_OFFS                    4
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_CONTROL_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_STATUS_Bits CAN_STATUS
N  * @{
N  */
N
N#define CAN_STATUS_RX_READY_OFFS                0
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N
N#define CAN_STATUS_TX_READY_OFFS                1
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N
N#define CAN_STATUS_ERROR_OVER_OFFS              2
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N
N#define CAN_STATUS_BIT_ERR_OFFS                 3
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N
N#define CAN_STATUS_BIT_STUFF_ERR_OFFS           4
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N
N#define CAN_STATUS_CRC_ERR_OFFS                 5
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N
N#define CAN_STATUS_FRAME_ERR_OFFS               6
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N
N#define CAN_STATUS_ACK_ERR_OFFS                 7
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N
N#define CAN_STATUS_IDLOWER_OFFS                 8
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N
N#define CAN_STATUS_ERR_STATUS_OFFS              9
N#define CAN_STATUS_ERR_STATUS_MASK              ((uint32_t)0x00000600)
N
N#define CAN_STATUS_RX_ERR_CNT8_OFFS             11
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N
N#define CAN_STATUS_TX_ERR_CNT8_OFFS             12
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N
N#define CAN_STATUS_RX_ERR_CNT_OFFS              16
N#define CAN_STATUS_RX_ERR_CNT_MASK              ((uint32_t)0x00FF0000)
N
N#define CAN_STATUS_TX_ERR_CNT_OFFS              24
N#define CAN_STATUS_TX_ERR_CNT_MASK              ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_STATUS_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BITTMNG_Bits CAN_BITTMNG
N  * @{
N  */
N
N#define CAN_BITTMNG_BRP_OFFS                    0
N#define CAN_BITTMNG_BRP_MASK                    ((uint32_t)0x0000FFFF)
N
N#define CAN_BITTMNG_PSEG_OFFS                   16
N#define CAN_BITTMNG_PSEG_MASK                   ((uint32_t)0x00070000)
N
N#define CAN_BITTMNG_SEG1_OFFS                   19
N#define CAN_BITTMNG_SEG1_MASK                   ((uint32_t)0x00380000)
N
N#define CAN_BITTMNG_SEG2_OFFS                   22
N#define CAN_BITTMNG_SEG2_MASK                   ((uint32_t)0x01C00000)
N
N#define CAN_BITTMNG_SJW_OFFS                    25
N#define CAN_BITTMNG_SJW_MASK                    ((uint32_t)0x06000000)
N
N#define CAN_BITTMNG_SB_OFFS                     27
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BITTMNG_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_INT_EN_Bits CAN_INT_EN
N  * @{
N  */
N
N#define CAN_INT_EN_GLB_INT_EN_OFFS              0
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N
N#define CAN_INT_EN_RX_INT_EN_OFFS               1
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N
N#define CAN_INT_EN_TX_INT_EN_OFFS               2
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N
N#define CAN_INT_EN_ERR_INT_EN_OFFS              3
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N
N#define CAN_INT_EN_ERR_OVER_INT_EN_OFFS         4
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_INT_EN_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_RXID_Bits CAN_RXID
N  * @{
N  */
N
N#define CAN_RXID_EID_OFFS                       0
N#define CAN_RXID_EID_MASK                       ((uint32_t)0x0003FFFF)
N
N#define CAN_RXID_SID_OFFS                       18
N#define CAN_RXID_SID_MASK                       ((uint32_t)0x1FFC0000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_RXID_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_RXDLC_Bits CAN_RXDLC
N  * @{
N  */
N
N#define CAN_RXDLC_OFFS                          0
N#define CAN_RXDLC_MASK                          ((uint32_t)0x0000000F)
N
N#define CAN_RXDLC_RTR_OFFS                      8
N#define CAN_RXDLC_RTR                           ((uint32_t)0x00000100)
N
N#define CAN_RXDLC_R1_OFFS                       9
N#define CAN_RXDLC_R1                            ((uint32_t)0x00000200)
N
N#define CAN_RXDLC_R0_OFFS                       10
N#define CAN_RXDLC_R0                            ((uint32_t)0x00000400)
N
N#define CAN_RXDLC_SSR_OFFS                      11
N#define CAN_RXDLC_SSR                           ((uint32_t)0x00000800)
N
N#define CAN_RXDLC_IDE_OFFS                      12
N#define CAN_RXDLC_IDE                           ((uint32_t)0x00001000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_RXDLC_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_RXDATAL_Bits CAN_RXDATAL
N  * @{
N  */
N
N#define CAN_RXDATAL_DB0_OFFS                    0
N#define CAN_RXDATAL_DB0_MASK                    ((uint32_t)0x000000FF)
N
N#define CAN_RXDATAL_DB1_OFFS                    8
N#define CAN_RXDATAL_DB1_MASK                    ((uint32_t)0x0000FF00)
N
N#define CAN_RXDATAL_DB2_OFFS                    16
N#define CAN_RXDATAL_DB2_MASK                    ((uint32_t)0x00FF0000)
N
N#define CAN_RXDATAL_DB3_OFFS                    24
N#define CAN_RXDATAL_DB3_MASK                    ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_RXDATAL_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_RXDATAH_Bits CAN_RXDATAH
N  * @{
N  */
N
N#define CAN_RXDATAH_DB4_OFFS                    0
N#define CAN_RXDATAH_DB4_MASK                    ((uint32_t)0x000000FF)
N
N#define CAN_RXDATAH_DB5_OFFS                    8
N#define CAN_RXDATAH_DB5_MASK                    ((uint32_t)0x0000FF00)
N
N#define CAN_RXDATAH_DB6_OFFS                    16
N#define CAN_RXDATAH_DB6_MASK                    ((uint32_t)0x00FF0000)
N
N#define CAN_RXDATAH_DB7_OFFS                    24
N#define CAN_RXDATAH_DB7_MASK                    ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_RXDATAH_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_TXID_Bits CAN_TXID
N  * @{
N  */
N
N#define CAN_TXID_EID_OFFS                       0
N#define CAN_TXID_EID_MASK                       ((uint32_t)0x0003FFFF)
N
N#define CAN_TXID_SID_OFFS                       18
N#define CAN_TXID_SID_MASK                       ((uint32_t)0x1FFC0000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_TXID_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_TXDLC_Bits CAN_TXDLC
N  * @{
N  */
N
N#define CAN_TXDLC_OFFS                          0
N#define CAN_TXDLC_MASK                          ((uint32_t)0x0000000F)
N
N#define CAN_TXDLC_RTR_OFFS                      8
N#define CAN_TXDLC_RTR                           ((uint32_t)0x00000100)
N
N#define CAN_TXDLC_R1_OFFS                       9
N#define CAN_TXDLC_R1                            ((uint32_t)0x00000200)
N
N#define CAN_TXDLC_R0_OFFS                       10
N#define CAN_TXDLC_R0                            ((uint32_t)0x00000400)
N
N#define CAN_TXDLC_SSR_OFFS                      11
N#define CAN_TXDLC_SSR                           ((uint32_t)0x00000800)
N
N#define CAN_TXDLC_IDE_OFFS                      12
N#define CAN_TXDLC_IDE                           ((uint32_t)0x00001000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_TXDLC_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_DATAL_Bits CAN_DATAL
N  * @{
N  */
N
N#define CAN_DATAL_DB0_OFFS                      0
N#define CAN_DATAL_DB0_MASK                      ((uint32_t)0x000000FF)
N
N#define CAN_DATAL_DB1_OFFS                      8
N#define CAN_DATAL_DB1_MASK                      ((uint32_t)0x0000FF00)
N
N#define CAN_DATAL_DB2_OFFS                      16
N#define CAN_DATAL_DB2_MASK                      ((uint32_t)0x00FF0000)
N
N#define CAN_DATAL_DB3_OFFS                      24
N#define CAN_DATAL_DB3_MASK                      ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_DATAL_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_DATAH_Bits CAN_DATAH
N  * @{
N  */
N
N#define CAN_DATAH_DB4_OFFS                      0
N#define CAN_DATAH_DB4_MASK                      ((uint32_t)0x000000FF)
N
N#define CAN_DATAH_DB5_OFFS                      8
N#define CAN_DATAH_DB5_MASK                      ((uint32_t)0x0000FF00)
N
N#define CAN_DATAH_DB6_OFFS                      16
N#define CAN_DATAH_DB6_MASK                      ((uint32_t)0x00FF0000)
N
N#define CAN_DATAH_DB7_OFFS                      24
N#define CAN_DATAH_DB7_MASK                      ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_DATAH_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BUF_CON_Bits CAN_BUF_CON
N  * @{
N  */
N
N#define CAN_BUF_CON_EN_OFFS                     0
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N
N#define CAN_BUF_CON_RX_TXn_OFFS                 1
N#define CAN_BUF_CON_RX_TXn                      ((uint32_t)0x00000002)
N
N#define CAN_BUF_CON_OVER_EN_OFFS                2
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N
N#define CAN_BUF_CON_RTR_EN_OFFS                 3
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N
N#define CAN_BUF_CON_PRIOR_0_OFFS                4
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N
N#define CAN_BUF_CON_TX_REQ_OFFS                 5
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N
N#define CAN_BUF_CON_RX_FULL_OFFS                6
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N
N#define CAN_BUF_CON_OVER_WR_OFFS                7
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BUF_CON_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BUF_ID_Bits CAN_BUF_ID
N  * @{
N  */
N
N#define CAN_BUF_ID_EID_OFFS                     0
N#define CAN_BUF_ID_EID_MASK                     ((uint32_t)0x0003FFFF)
N
N#define CAN_BUF_ID_SID_OFFS                     18
N#define CAN_BUF_ID_SID_MASK                     ((uint32_t)0x1FFC0000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BUF_ID_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BUF_DLC_Bits CAN_BUF_DLC
N  * @{
N  */
N
N#define CAN_BUF_DLC_OFFS                        0
N#define CAN_BUF_DLC_MASK                        ((uint32_t)0x0000000F)
N
N#define CAN_BUF_DLC_RTR_OFFS                    8
N#define CAN_BUF_DLC_RTR                         ((uint32_t)0x00000100)
N
N#define CAN_BUF_DLC_R1_OFFS                     9
N#define CAN_BUF_DLC_R1                          ((uint32_t)0x00000200)
N
N#define CAN_BUF_DLC_R0_OFFS                     10
N#define CAN_BUF_DLC_R0                          ((uint32_t)0x00000400)
N
N#define CAN_BUF_DLC_SSR_OFFS                    11
N#define CAN_BUF_DLC_SSR                         ((uint32_t)0x00000800)
N
N#define CAN_BUF_DLC_IDE_OFFS                    12
N#define CAN_BUF_DLC_IDE                         ((uint32_t)0x00001000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BUF_DLC_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BUF_DATAL_Bits CAN_BUF_DATAL
N  * @{
N  */
N
N#define CAN_BUF_DATAL_DB0_OFFS                  0
N#define CAN_BUF_DATAL_DB0_MASK                  ((uint32_t)0x000000FF)
N
N#define CAN_BUF_DATAL_DB1_OFFS                  8
N#define CAN_BUF_DATAL_DB1_MASK                  ((uint32_t)0x0000FF00)
N
N#define CAN_BUF_DATAL_DB2_OFFS                  16
N#define CAN_BUF_DATAL_DB2_MASK                  ((uint32_t)0x00FF0000)
N
N#define CAN_BUF_DATAL_DB3_OFFS                  24
N#define CAN_BUF_DATAL_DB3_MASK                  ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BUF_DATAL_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @defgroup Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CAN_BUF_DATAH_Bits CAN_BUF_DATAH
N  * @{
N  */
N
N#define CAN_BUF_DATAH_DB4_OFFS                  0
N#define CAN_BUF_DATAH_DB4_MASK                  ((uint32_t)0x000000FF)
N
N#define CAN_BUF_DATAH_DB5_OFFS                  8
N#define CAN_BUF_DATAH_DB5_MASK                  ((uint32_t)0x0000FF00)
N
N#define CAN_BUF_DATAH_DB6_OFFS                  16
N#define CAN_BUF_DATAH_DB6_MASK                  ((uint32_t)0x00FF0000)
N
N#define CAN_BUF_DATAH_DB7_OFFS                  24
N#define CAN_BUF_DATAH_DB7_MASK                  ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_CAN_CAN_BUF_DATAH_Bits */
N
N/** @} */ /* End of group Periph_CAN_Defines */
N
N/** @} */ /* End of group Periph_CAN */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_CAN_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_can_defs.h */
L 83 ".\inc\opora.h" 2
N#include "opora_usb_defs.h"
L 1 ".\inc\opora_usb_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_usb_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the USB peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_usb_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_USB_DEFS_H
N#define __OPORA_USB_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_USB USB
N  * @{
N  */
N
N/**
N  * @brief USB_SEP_TypeDef ??? structure
N  */
N
Ntypedef struct {
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N} _USB_SEP_TypeDef;
N
N/**
N  * @brief USB_SEP_TypeDef0 ??? structure
N  */
N
Ntypedef struct {
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N  __IO uint32_t RESERVED6[11];
X  volatile uint32_t RESERVED6[11];
N} _USB_SEP_TypeDef0;
N
N/** @defgroup Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_USB_TypeDef USB_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFDC;
X  volatile uint32_t HTXFDC;
N       uint32_t RESERVED4[11];
N  _USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N  _USB_SEP_TypeDef0 USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N} USB_TypeDef;
N
N/** @} */ /* End of group Periph_USB_TypeDef */
N
N/** @} */ /* End of group Periph_USB_Data_Structures */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HTXC_Bits USB_HTXC
N  * @{
N  */
N
N#define USB_HTXC_TREQ_OFFS                      0
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N
N#define USB_HTXC_SOFS_OFFS                      1
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N
N#define USB_HTXC_PREEN_OFFS                     2
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N
N#define USB_HTXC_ISOEN_OFFS                     3
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_USB_USB_HTXC_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HTXLC_Bits USB_HTXLC
N  * @{
N  */
N
N#define USB_HTXLC_OFFS                          0
N#define USB_HTXLC_MASK                          ((uint32_t)0x00000003)
N
N#define USB_HTXLC_DC_OFFS                       2
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N
N#define USB_HTXLC_FSPL_OFFS                     3
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N
N#define USB_HTXLC_FSLR_OFFS                     4
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_USB_USB_HTXLC_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HIS_Bits USB_HIS
N  * @{
N  */
N
N#define USB_HIS_TDONE_OFFS                      0
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N
N#define USB_HIS_RESUME_OFFS                     1
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N
N#define USB_HIS_CONEV_OFFS                      2
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N
N#define USB_HIS_SOFS_OFFS                       3
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_USB_USB_HIS_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HIM_Bits USB_HIM
N  * @{
N  */
N
N#define USB_HIM_TDONEIE_OFFS                    0
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N
N#define USB_HIM_RESUMEIE_OFFS                   1
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N
N#define USB_HIM_CONEVIE_OFFS                    2
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N
N#define USB_HIM_SOFIE_OFFS                      3
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_USB_USB_HIM_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HRXS_Bits USB_HRXS
N  * @{
N  */
N
N#define USB_HRXS_CRCERR_OFFS                    0
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N
N#define USB_HRXS_BSERR_OFFS                     1
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N
N#define USB_HRXS_RXOF_OFFS                      2
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N
N#define USB_HRXS_RXTO_OFFS                      3
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N
N#define USB_HRXS_NAKRXED_OFFS                   4
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N
N#define USB_HRXS_STALLRXED_OFFS                 5
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N
N#define USB_HRXS_ACKRXED_OFFS                   6
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N
N#define USB_HRXS_DATASEQ_OFFS                   7
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_USB_USB_HRXS_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_SEP_CTRL_Bits USB_SEP_CTRL
N  * @{
N  */
N
N#define USB_SEP_CTRL_EPEN_OFFS                  0
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N
N#define USB_SEP_CTRL_EPRDY_OFFS                 1
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N
N#define USB_SEP_CTRL_EPDATASEQ_OFFS             2
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N
N#define USB_SEP_CTRL_EPSSTALL_OFFS              3
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N
N#define USB_SEP_CTRL_EPISOEN_OFFS               4
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_USB_USB_SEP_CTRL_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_SEP_STS_Bits USB_SEP_STS
N  * @{
N  */
N
N#define USB_SEP_STS_SCCRCERR_OFFS               0
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N
N#define USB_SEP_STS_SCBSERR_OFFS                1
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N
N#define USB_SEP_STS_SCRXOF_OFFS                 2
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N
N#define USB_SEP_STS_SCRXTO_OFFS                 3
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N
N#define USB_SEP_STS_SCNAKSENT_OFFS              4
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N
N#define USB_SEP_STS_SCSTALLSENT_OFFS            5
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N
N#define USB_SEP_STS_SCACKRXED_OFFS              6
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N
N#define USB_SEP_STS_SCDATASEQ_OFFS              7
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_USB_USB_SEP_STS_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_SC_Bits USB_SC
N  * @{
N  */
N
N#define USB_SC_SCGEN_OFFS                       0
N#define USB_SC_SCGEN                            ((uint32_t)0x00000001)
N
N#define USB_SC_SCTXLS_OFFS                      1
N#define USB_SC_SCTXLS_MASK                      ((uint32_t)0x00000006)
N
N#define USB_SC_SCDC_OFFS                        3
N#define USB_SC_SCDC                             ((uint32_t)0x00000008)
N
N#define USB_SC_SCFSP_OFFS                       4
N#define USB_SC_SCFSP                            ((uint32_t)0x00000010)
N
N#define USB_SC_SCFSR_OFFS                       5
N#define USB_SC_SCFSR                            ((uint32_t)0x00000020)
N
N
N/** @} */ /* End of group Periph_USB_USB_SC_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_SIS_Bits USB_SIS
N  * @{
N  */
N
N#define USB_SIS_SCTDONE_OFFS                    0
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N
N#define USB_SIS_SCRESUME_OFFS                   1
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N
N#define USB_SIS_SCRESETEV_OFFS                  2
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N
N#define USB_SIS_SCSOFREC_OFFS                   3
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N
N#define USB_SIS_SCNAKSENT_OFFS                  4
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_USB_USB_SIS_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_SIM_Bits USB_SIM
N  * @{
N  */
N
N#define USB_SIM_SCTDONEIE_OFFS                  0
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N
N#define USB_SIM_SCRESUMEIE_OFFS                 1
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N
N#define USB_SIM_SCRESETEVIE_OFFS                2
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N
N#define USB_SIM_SCSOFRECIE_OFFS                 3
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N
N#define USB_SIM_SCNAKSENTIE_OFFS                4
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_USB_USB_SIM_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HSCR_Bits USB_HSCR
N  * @{
N  */
N
N#define USB_HSCR_HOST_MODE_OFFS                 0
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N
N#define USB_HSCR_RESET_CORE_OFFS                1
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N
N#define USB_HSCR_EN_TX_OFFS                     2
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N
N#define USB_HSCR_EN_RX_OFFS                     3
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N
N#define USB_HSCR_DP_PULLUP_OFFS                 4
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N
N#define USB_HSCR_DP_PULLDOWN_OFFS               5
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N
N#define USB_HSCR_DM_PULLUP_OFFS                 6
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N
N#define USB_HSCR_DM_PULLDOWN_OFFS               7
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_USB_USB_HSCR_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @defgroup Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_USB_HSVR_Bits USB_HSVR
N  * @{
N  */
N
N#define USB_HSVR_VERSION_OFFS                   0
N#define USB_HSVR_VERSION_MASK                   ((uint32_t)0x0000000F)
N
N#define USB_HSVR_REVISION_OFFS                  4
N#define USB_HSVR_REVISION_MASK                  ((uint32_t)0x000000F0)
N
N
N/** @} */ /* End of group Periph_USB_USB_HSVR_Bits */
N
N/** @} */ /* End of group Periph_USB_Defines */
N
N/** @} */ /* End of group Periph_USB */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_USB_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_usb_defs.h */
L 84 ".\inc\opora.h" 2
N#include "opora_eeprom_defs.h"
L 1 ".\inc\opora_eeprom_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_eeprom_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the EEPROM peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_eeprom_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_EEPROM_DEFS_H
N#define __OPORA_EEPROM_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_TypeDef EEPROM_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N} EEPROM_TypeDef;
N
N/** @} */ /* End of group Periph_EEPROM_TypeDef */
N
N/** @} */ /* End of group Periph_EEPROM_Data_Structures */
N
N/** @defgroup Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_EEPROM_CMD_Bits EEPROM_CMD
N  * @{
N  */
N
N#define EEPROM_CMD_CON_OFFS                     0
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N
N#define EEPROM_CMD_WR_OFFS                      1
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N
N#define EEPROM_CMD_RD_OFFS                      2
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N
N#define EEPROM_CMD_Delay_OFFS                   3
N#define EEPROM_CMD_Delay_MASK                   ((uint32_t)0x00000038)
N
N#define EEPROM_CMD_XE_OFFS                      6
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N
N#define EEPROM_CMD_YE_OFFS                      7
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N
N#define EEPROM_CMD_SE_OFFS                      8
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N
N#define EEPROM_CMD_IFREN_OFFS                   9
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N
N#define EEPROM_CMD_ERASE_OFFS                   10
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N
N#define EEPROM_CMD_MAS1_OFFS                    11
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N
N#define EEPROM_CMD_PROG_OFFS                    12
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N
N#define EEPROM_CMD_NVSTR_OFFS                   13
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N
N/** @} */ /* End of group Periph_EEPROM_EEPROM_CMD_Bits */
N
N/** @} */ /* End of group Periph_EEPROM_Defines */
N
N/** @} */ /* End of group Periph_EEPROM */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_EEPROM_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_eeprom_defs.h */
L 85 ".\inc\opora.h" 2
N#include "opora_rst_clk_defs.h"
L 1 ".\inc\opora_rst_clk_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_rst_clk_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the RST_CLK peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_rst_clk_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_RST_CLK_DEFS_H
N#define __OPORA_RST_CLK_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_TypeDef RST_CLK_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N       uint32_t RESERVED;
N  __IO uint32_t ETH_CLOCK;
X  volatile uint32_t ETH_CLOCK;
N} RST_CLK_TypeDef;
N
N/** @} */ /* End of group Periph_RST_CLK_TypeDef */
N
N/** @} */ /* End of group Periph_RST_CLK_Data_Structures */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_CLOCK_STATUS_Bits RST_CLK_CLOCK_STATUS
N  * @{
N  */
N
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_OFFS   0
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_OFFS   1
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_OFFS       2
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_CLOCK_STATUS_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_PLL_CONTROL_Bits RST_CLK_PLL_CONTROL
N  * @{
N  */
N
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_OFFS     0
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_OFFS    1
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_OFFS     2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_OFFS    3
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_OFFS    4
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_MASK    ((uint32_t)0x000000F0)
N
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_OFFS    8
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_MASK    ((uint32_t)0x00000F00)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_PLL_CONTROL_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_HS_CONTROL_Bits RST_CLK_HS_CONTROL
N  * @{
N  */
N
N#define RST_CLK_HS_CONTROL_HSE_ON_OFFS          0
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N
N#define RST_CLK_HS_CONTROL_HSE_BYP_OFFS         1
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_HS_CONTROL_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_CPU_CLOCK_Bits RST_CLK_CPU_CLOCK
N  * @{
N  */
N
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_OFFS       0
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_MASK       ((uint32_t)0x00000003)
N
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_OFFS       2
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_OFFS       4
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_MASK       ((uint32_t)0x000000F0)
N
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_OFFS         8
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_MASK         ((uint32_t)0x00000300)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_CPU_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_USB_CLOCK_Bits RST_CLK_USB_CLOCK
N  * @{
N  */
N
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_OFFS       0
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_MASK       ((uint32_t)0x00000003)
N
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_OFFS       2
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N
N#define RST_CLK_USB_CLOCK_CPU_C3_SEL_OFFS       4
N#define RST_CLK_USB_CLOCK_CPU_C3_SEL_MASK       ((uint32_t)0x00000010)
N
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_OFFS       8
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_USB_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_ADC_MCO_CLOCK_Bits RST_CLK_ADC_MCO_CLOCK
N  * @{
N  */
N
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_OFFS   0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_MASK   ((uint32_t)0x00000003)
N
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_OFFS   4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_MASK   ((uint32_t)0x00000030)
N
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_OFFS   8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_MASK   ((uint32_t)0x00000F00)
N
N#define RST_CLK_ADC_MCO_CLOCK_MCO_EN_OFFS       12
N#define RST_CLK_ADC_MCO_CLOCK_MCO_EN            ((uint32_t)0x00001000)
N
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_OFFS   13
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_ADC_MCO_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_RTC_CLOCK_Bits RST_CLK_RTC_CLOCK
N  * @{
N  */
N
N#define RST_CLK_RTC_CLOCK_HSE_SEL_OFFS          0
N#define RST_CLK_RTC_CLOCK_HSE_SEL_MASK          ((uint32_t)0x0000000F)
N
N#define RST_CLK_RTC_CLOCK_HSI_SEL_OFFS          4
N#define RST_CLK_RTC_CLOCK_HSI_SEL_MASK          ((uint32_t)0x000000F0)
N
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_OFFS       8
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_OFFS       9
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_RTC_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_CAN_CLOCK_Bits RST_CLK_CAN_CLOCK
N  * @{
N  */
N
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_OFFS         0
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_MASK         ((uint32_t)0x000000FF)
N
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_OFFS         8
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_MASK         ((uint32_t)0x0000FF00)
N
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_OFFS      24
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_OFFS      25
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_CAN_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_TIM_CLOCK_Bits RST_CLK_TIM_CLOCK
N  * @{
N  */
N
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_OFFS         0
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_MASK         ((uint32_t)0x000000FF)
N
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_OFFS         8
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_MASK         ((uint32_t)0x0000FF00)
N
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_OFFS         16
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_MASK         ((uint32_t)0x00FF0000)
N
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_OFFS      24
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_OFFS      25
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_OFFS      26
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_TIM_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_UART_CLOCK_Bits RST_CLK_UART_CLOCK
N  * @{
N  */
N
N#define RST_CLK_UART_CLOCK_UART1_BRG_OFFS       0
N#define RST_CLK_UART_CLOCK_UART1_BRG_MASK       ((uint32_t)0x000000FF)
N
N#define RST_CLK_UART_CLOCK_UART2_BRG_OFFS       8
N#define RST_CLK_UART_CLOCK_UART2_BRG_MASK       ((uint32_t)0x0000FF00)
N
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_OFFS    24
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_OFFS    25
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_UART_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @defgroup Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_RST_CLK_SSP_CLOCK_Bits RST_CLK_SSP_CLOCK
N  * @{
N  */
N
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_OFFS         0
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_MASK         ((uint32_t)0x000000FF)
N
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_OFFS         8
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_MASK         ((uint32_t)0x0000FF00)
N
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_OFFS      24
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_OFFS      25
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N
N/** @} */ /* End of group Periph_RST_CLK_RST_CLK_SSP_CLOCK_Bits */
N
N/** @} */ /* End of group Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group Periph_RST_CLK */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_RST_CLK_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_rst_clk_defs.h */
L 86 ".\inc\opora.h" 2
N#include "opora_dma_defs.h"
L 1 ".\inc\opora_dma_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_dma_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the DMA peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_dma_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_DMA_DEFS_H
N#define __OPORA_DMA_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_DMA_TypeDef DMA_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N} DMA_TypeDef;
N
N/** @} */ /* End of group Periph_DMA_TypeDef */
N
N/** @} */ /* End of group Periph_DMA_Data_Structures */
N
N/** @defgroup Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_DMA_STATUS_Bits DMA_STATUS
N  * @{
N  */
N
N#define DMA_STATUS_MASTER_ENABLE_OFFS           0
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N
N#define DMA_STATUS_STATE_OFFS                   4
N#define DMA_STATUS_STATE_MASK                   ((uint32_t)0x000000F0)
N
N#define DMA_STATUS_CHNLS_MINUS1_OFFS            16
N#define DMA_STATUS_CHNLS_MINUS1_MASK            ((uint32_t)0x001F0000)
N
N#define DMA_STATUS_TEST_STATUS_OFFS             28
N#define DMA_STATUS_TEST_STATUS_MASK             ((uint32_t)0xF0000000)
N
N
N/** @} */ /* End of group Periph_DMA_DMA_STATUS_Bits */
N
N/** @} */ /* End of group Periph_DMA_Defines */
N
N/** @defgroup Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_DMA_CFG_Bits DMA_CFG
N  * @{
N  */
N
N#define DMA_CFG_MASTER_ENABLE_OFFS              0
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N
N#define DMA_CFG_CHNL_PROT_CTRL_OFFS             5
N#define DMA_CFG_CHNL_PROT_CTRL_MASK             ((uint32_t)0x000000E0)
N
N
N/** @} */ /* End of group Periph_DMA_DMA_CFG_Bits */
N
N/** @} */ /* End of group Periph_DMA_Defines */
N
N/** @} */ /* End of group Periph_DMA */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_DMA_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_dma_defs.h */
L 87 ".\inc\opora.h" 2
N#include "opora_uart_defs.h"
L 1 ".\inc\opora_uart_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_uart_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the UART peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_uart_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_UART_DEFS_H
N#define __OPORA_UART_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_UART UART
N  * @{
N  */
N
N/** @defgroup Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_UART_TypeDef UART_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} UART_TypeDef;
N
N/** @} */ /* End of group Periph_UART_TypeDef */
N
N/** @} */ /* End of group Periph_UART_Data_Structures */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_DR_Bits UART_DR
N  * @{
N  */
N
N#define UART_DR_DATA_OFFS                       0
N#define UART_DR_DATA_MASK                       ((uint32_t)0x000000FF)
N
N#define UART_DR_FE_OFFS                         8
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N
N#define UART_DR_PE_OFFS                         9
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N
N#define UART_DR_BE_OFFS                         10
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N
N#define UART_DR_OE_OFFS                         11
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N
N/** @} */ /* End of group Periph_UART_UART_DR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_RSR_ECR_Bits UART_RSR_ECR
N  * @{
N  */
N
N#define UART_RSR_ECR_FE_OFFS                    0
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N
N#define UART_RSR_ECR_PE_OFFS                    1
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N
N#define UART_RSR_ECR_BE_OFFS                    2
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N
N#define UART_RSR_ECR_OE_OFFS                    3
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_UART_UART_RSR_ECR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_FR_Bits UART_FR
N  * @{
N  */
N
N#define UART_FR_CTS_OFFS                        0
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N
N#define UART_FR_DSR_OFFS                        1
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N
N#define UART_FR_DCD_OFFS                        2
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N
N#define UART_FR_BUSY_OFFS                       3
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N
N#define UART_FR_RXFE_OFFS                       4
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N
N#define UART_FR_TXFF_OFFS                       5
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N
N#define UART_FR_RXFF_OFFS                       6
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N
N#define UART_FR_TXFE_OFFS                       7
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N
N#define UART_FR_RI_OFFS                         8
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N
N/** @} */ /* End of group Periph_UART_UART_FR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_LCR_H_Bits UART_LCR_H
N  * @{
N  */
N
N#define UART_LCR_H_BRK_OFFS                     0
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N
N#define UART_LCR_H_PEN_OFFS                     1
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N
N#define UART_LCR_H_EPS_OFFS                     2
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N
N#define UART_LCR_H_STP2_OFFS                    3
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N
N#define UART_LCR_H_FEN_OFFS                     4
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N
N#define UART_LCR_H_WLEN_OFFS                    5
N#define UART_LCR_H_WLEN_MASK                    ((uint32_t)0x00000060)
N
N#define UART_LCR_H_SPS_OFFS                     7
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_UART_UART_LCR_H_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_CR_Bits UART_CR
N  * @{
N  */
N
N#define UART_CR_UARTEN_OFFS                     0
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N
N#define UART_CR_SIREN_OFFS                      1
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N
N#define UART_CR_SIRLP_OFFS                      2
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N
N#define UART_CR_LBE_OFFS                        7
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N
N#define UART_CR_TXE_OFFS                        8
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N
N#define UART_CR_RXE_OFFS                        9
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N
N#define UART_CR_DTR_OFFS                        10
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N
N#define UART_CR_RTS_OFFS                        11
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N
N#define UART_CR_Out1_OFFS                       12
N#define UART_CR_Out1                            ((uint32_t)0x00001000)
N
N#define UART_CR_Out2_OFFS                       13
N#define UART_CR_Out2                            ((uint32_t)0x00002000)
N
N#define UART_CR_RTSEn_OFFS                      14
N#define UART_CR_RTSEn                           ((uint32_t)0x00004000)
N
N#define UART_CR_CTSEn_OFFS                      15
N#define UART_CR_CTSEn                           ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_UART_UART_CR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_IFLS_Bits UART_IFLS
N  * @{
N  */
N
N#define UART_IFLS_TXIFLSEL_OFFS                 0
N#define UART_IFLS_TXIFLSEL_MASK                 ((uint32_t)0x00000007)
N
N#define UART_IFLS_RXIFLSEL_OFFS                 3
N#define UART_IFLS_RXIFLSEL_MASK                 ((uint32_t)0x00000038)
N
N
N/** @} */ /* End of group Periph_UART_UART_IFLS_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_IMSC_Bits UART_IMSC
N  * @{
N  */
N
N#define UART_IMSC_RIMIM_OFFS                    0
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N
N#define UART_IMSC_CTSMIM_OFFS                   1
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N
N#define UART_IMSC_DCDMIM_OFFS                   2
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N
N#define UART_IMSC_DSRMIM_OFFS                   3
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N
N#define UART_IMSC_RXIM_OFFS                     4
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N
N#define UART_IMSC_TXIM_OFFS                     5
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N
N#define UART_IMSC_RTIM_OFFS                     6
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N
N#define UART_IMSC_FEIM_OFFS                     7
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N
N#define UART_IMSC_PEIM_OFFS                     8
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N
N#define UART_IMSC_BEIM_OFFS                     9
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N
N#define UART_IMSC_OEIM_OFFS                     10
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N
N/** @} */ /* End of group Periph_UART_UART_IMSC_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_RIS_Bits UART_RIS
N  * @{
N  */
N
N#define UART_RIS_RIRMIS_OFFS                    0
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N
N#define UART_RIS_CTSRMIS_OFFS                   1
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N
N#define UART_RIS_DCDRMIS_OFFS                   2
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N
N#define UART_RIS_DSRRMIS_OFFS                   3
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N
N#define UART_RIS_RXRIS_OFFS                     4
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N
N#define UART_RIS_TXRIS_OFFS                     5
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N
N#define UART_RIS_RTRIS_OFFS                     6
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N
N#define UART_RIS_FERIS_OFFS                     7
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N
N#define UART_RIS_PERIS_OFFS                     8
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N
N#define UART_RIS_BERIS_OFFS                     9
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N
N#define UART_RIS_OERIS_OFFS                     10
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N
N/** @} */ /* End of group Periph_UART_UART_RIS_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_MIS_Bits UART_MIS
N  * @{
N  */
N
N#define UART_MIS_RIMMIS_OFFS                    0
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N
N#define UART_MIS_CTSMMIS_OFFS                   1
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N
N#define UART_MIS_DCDMMIS_OFFS                   2
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N
N#define UART_MIS_DSRMMIS_OFFS                   3
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N
N#define UART_MIS_RXMIS_OFFS                     4
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N
N#define UART_MIS_TXMIS_OFFS                     5
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N
N#define UART_MIS_RTMIS_OFFS                     6
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N
N#define UART_MIS_FEMIS_OFFS                     7
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N
N#define UART_MIS_PEMIS_OFFS                     8
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N
N#define UART_MIS_BEMIS_OFFS                     9
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N
N#define UART_MIS_OEMIS_OFFS                     10
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N
N/** @} */ /* End of group Periph_UART_UART_MIS_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_ICR_Bits UART_ICR
N  * @{
N  */
N
N#define UART_ICR_RIMIC_OFFS                     0
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N
N#define UART_ICR_CTSMIC_OFFS                    1
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N
N#define UART_ICR_DCDMIC_OFFS                    2
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N
N#define UART_ICR_DSRMIC_OFFS                    3
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N
N#define UART_ICR_RXIC_OFFS                      4
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N
N#define UART_ICR_TXIC_OFFS                      5
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N
N#define UART_ICR_RTIC_OFFS                      6
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N
N#define UART_ICR_FEIC_OFFS                      7
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N
N#define UART_ICR_PEIC_OFFS                      8
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N
N#define UART_ICR_BEIC_OFFS                      9
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N
N#define UART_ICR_OEIC_OFFS                      10
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N
N/** @} */ /* End of group Periph_UART_UART_ICR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @defgroup Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_UART_DMACR_Bits UART_DMACR
N  * @{
N  */
N
N#define UART_DMACR_RXDMAE_OFFS                  0
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N
N#define UART_DMACR_TXDMAE_OFFS                  1
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N
N#define UART_DMACR_DMAONERR_OFFS                2
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N
N/** @} */ /* End of group Periph_UART_UART_DMACR_Bits */
N
N/** @} */ /* End of group Periph_UART_Defines */
N
N/** @} */ /* End of group Periph_UART */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_UART_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_uart_defs.h */
L 88 ".\inc\opora.h" 2
N#include "opora_spi_defs.h"
L 1 ".\inc\opora_spi_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_spi_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the SPI peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_spi_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_SPI_DEFS_H
N#define __OPORA_SPI_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_SPI SPI
N  * @{
N  */
N
N/** @defgroup Periph_SPI_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_SPI_TypeDef SPI_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t SSPx_CR0;
X  volatile uint32_t SSPx_CR0;
N  __IO uint32_t SSPx_CR1;
X  volatile uint32_t SSPx_CR1;
N  __IO uint32_t SSPx_DR;
X  volatile uint32_t SSPx_DR;
N  __IO uint32_t SSPx_SR;
X  volatile uint32_t SSPx_SR;
N  __IO uint32_t SSPx_CPSR;
X  volatile uint32_t SSPx_CPSR;
N  __IO uint32_t SSPx_IMSC;
X  volatile uint32_t SSPx_IMSC;
N  __IO uint32_t SSPx_RIS;
X  volatile uint32_t SSPx_RIS;
N  __IO uint32_t SSPx_MIS;
X  volatile uint32_t SSPx_MIS;
N  __IO uint32_t SSPx_ICR;
X  volatile uint32_t SSPx_ICR;
N  __IO uint32_t SSPx_DMACR;
X  volatile uint32_t SSPx_DMACR;
N} SPI_TypeDef;
N
N/** @} */ /* End of group Periph_SPI_TypeDef */
N
N/** @} */ /* End of group Periph_SPI_Data_Structures */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_CR0_Bits SPI_SSPX_CR0
N  * @{
N  */
N
N#define SPI_SSPx_CR0_DSS_OFFS                   0
N#define SPI_SSPx_CR0_DSS_MASK                   ((uint32_t)0x0000000F)
N
N#define SPI_SSPx_CR0_FRF_OFFS                   4
N#define SPI_SSPx_CR0_FRF_MASK                   ((uint32_t)0x00000030)
N
N#define SPI_SSPx_CR0_SPO_OFFS                   6
N#define SPI_SSPx_CR0_SPO                        ((uint32_t)0x00000040)
N
N#define SPI_SSPx_CR0_SPH_OFFS                   7
N#define SPI_SSPx_CR0_SPH                        ((uint32_t)0x00000080)
N
N#define SPI_SSPx_CR0_SCR_OFFS                   8
N#define SPI_SSPx_CR0_SCR_MASK                   ((uint32_t)0x0000FF00)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_CR0_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_CR1_Bits SPI_SSPX_CR1
N  * @{
N  */
N
N#define SPI_SSPx_CR1_LBM_OFFS                   0
N#define SPI_SSPx_CR1_LBM                        ((uint32_t)0x00000001)
N
N#define SPI_SSPx_CR1_SSE_OFFS                   1
N#define SPI_SSPx_CR1_SSE                        ((uint32_t)0x00000002)
N
N#define SPI_SSPx_CR1_MS_OFFS                    2
N#define SPI_SSPx_CR1_MS                         ((uint32_t)0x00000004)
N
N#define SPI_SSPx_CR1_SOD_OFFS                   3
N#define SPI_SSPx_CR1_SOD                        ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_CR1_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_SR_Bits SPI_SSPX_SR
N  * @{
N  */
N
N#define SPI_SSPx_SR_TFE_OFFS                    0
N#define SPI_SSPx_SR_TFE                         ((uint32_t)0x00000001)
N
N#define SPI_SSPx_SR_TNF_OFFS                    1
N#define SPI_SSPx_SR_TNF                         ((uint32_t)0x00000002)
N
N#define SPI_SSPx_SR_RNE_OFFS                    2
N#define SPI_SSPx_SR_RNE                         ((uint32_t)0x00000004)
N
N#define SPI_SSPx_SR_RFF_OFFS                    3
N#define SPI_SSPx_SR_RFF                         ((uint32_t)0x00000008)
N
N#define SPI_SSPx_SR_BSY_OFFS                    4
N#define SPI_SSPx_SR_BSY                         ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_SR_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_IMSC_Bits SPI_SSPX_IMSC
N  * @{
N  */
N
N#define SPI_SSPx_IMSC_RORIM_OFFS                0
N#define SPI_SSPx_IMSC_RORIM                     ((uint32_t)0x00000001)
N
N#define SPI_SSPx_IMSC_RTIM_OFFS                 1
N#define SPI_SSPx_IMSC_RTIM                      ((uint32_t)0x00000002)
N
N#define SPI_SSPx_IMSC_RXIM_OFFS                 2
N#define SPI_SSPx_IMSC_RXIM                      ((uint32_t)0x00000004)
N
N#define SPI_SSPx_IMSC_TXIM_OFFS                 3
N#define SPI_SSPx_IMSC_TXIM                      ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_IMSC_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_RIS_Bits SPI_SSPX_RIS
N  * @{
N  */
N
N#define SPI_SSPx_RIS_RORRIS_OFFS                0
N#define SPI_SSPx_RIS_RORRIS                     ((uint32_t)0x00000001)
N
N#define SPI_SSPx_RIS_RTRIS_OFFS                 1
N#define SPI_SSPx_RIS_RTRIS                      ((uint32_t)0x00000002)
N
N#define SPI_SSPx_RIS_RXRIS_OFFS                 2
N#define SPI_SSPx_RIS_RXRIS                      ((uint32_t)0x00000004)
N
N#define SPI_SSPx_RIS_TXRIS_OFFS                 3
N#define SPI_SSPx_RIS_TXRIS                      ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_RIS_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_MIS_Bits SPI_SSPX_MIS
N  * @{
N  */
N
N#define SPI_SSPx_MIS_RORMIS_OFFS                0
N#define SPI_SSPx_MIS_RORMIS                     ((uint32_t)0x00000001)
N
N#define SPI_SSPx_MIS_RTMIS_OFFS                 1
N#define SPI_SSPx_MIS_RTMIS                      ((uint32_t)0x00000002)
N
N#define SPI_SSPx_MIS_RXMIS_OFFS                 2
N#define SPI_SSPx_MIS_RXMIS                      ((uint32_t)0x00000004)
N
N#define SPI_SSPx_MIS_TXMIS_OFFS                 3
N#define SPI_SSPx_MIS_TXMIS                      ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_MIS_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_ICR_Bits SPI_SSPX_ICR
N  * @{
N  */
N
N#define SPI_SSPx_ICR_RORIC_OFFS                 0
N#define SPI_SSPx_ICR_RORIC                      ((uint32_t)0x00000001)
N
N#define SPI_SSPx_ICR_RTIC_OFFS                  1
N#define SPI_SSPx_ICR_RTIC                       ((uint32_t)0x00000002)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_ICR_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @defgroup Periph_SPI_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SPI_SPI_SSPX_DMACR_Bits SPI_SSPX_DMACR
N  * @{
N  */
N
N#define SPI_SSPx_DMACR_RXDMAE_OFFS              0
N#define SPI_SSPx_DMACR_RXDMAE                   ((uint32_t)0x00000001)
N
N#define SPI_SSPx_DMACR_TXDMAE_OFFS              1
N#define SPI_SSPx_DMACR_TXDMAE                   ((uint32_t)0x00000002)
N
N
N/** @} */ /* End of group Periph_SPI_SPI_SSPX_DMACR_Bits */
N
N/** @} */ /* End of group Periph_SPI_Defines */
N
N/** @} */ /* End of group Periph_SPI */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_SPI_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_spi_defs.h */
L 89 ".\inc\opora.h" 2
N#include "opora_mil_std_1553_defs.h"
L 1 ".\inc\opora_mil_std_1553_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_mil_std_1553_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the MIL_STD_1553 peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_mil_std_1553_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_MIL_STD_1553_DEFS_H
N#define __OPORA_MIL_STD_1553_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553 MIL_STD_1553
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_TypeDef MIL_STD_1553_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N       uint32_t RESERVED0[1024];
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t ERROR;
X  volatile uint32_t ERROR;
N  __IO uint32_t CommandWord1;
X  volatile uint32_t CommandWord1;
N  __IO uint32_t CommandWord2;
X  volatile uint32_t CommandWord2;
N  __IO uint32_t ModeData;
X  volatile uint32_t ModeData;
N  __IO uint32_t StatusWord1;
X  volatile uint32_t StatusWord1;
N  __IO uint32_t StatusWord2;
X  volatile uint32_t StatusWord2;
N  __IO uint32_t INTEN;
X  volatile uint32_t INTEN;
N  __IO uint32_t MSG;
X  volatile uint32_t MSG;
N} MIL_STD_1553_TypeDef;
N
N/** @} */ /* End of group Periph_MIL_STD_1553_TypeDef */
N
N/** @} */ /* End of group Periph_MIL_STD_1553_Data_Structures */
N
N/** @defgroup Periph_MIL_STD_1553_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_MIL_STD_1553_CONTROL_Bits MIL_STD_1553_CONTROL
N  * @{
N  */
N
N#define MIL_STD_1553_CONTROL_MR_OFFS            0
N#define MIL_STD_1553_CONTROL_MR                 ((uint32_t)0x00000001)
N
N#define MIL_STD_1553_CONTROL_BCSTART_OFFS       1
N#define MIL_STD_1553_CONTROL_BCSTART            ((uint32_t)0x00000002)
N
N#define MIL_STD_1553_CONTROL_BCMODE_OFFS        2
N#define MIL_STD_1553_CONTROL_BCMODE             ((uint32_t)0x00000004)
N
N#define MIL_STD_1553_CONTROL_RTMODE_OFFS        3
N#define MIL_STD_1553_CONTROL_RTMODE             ((uint32_t)0x00000008)
N
N#define MIL_STD_1553_CONTROL_TRA_OFFS           4
N#define MIL_STD_1553_CONTROL_TRA                ((uint32_t)0x00000010)
N
N#define MIL_STD_1553_CONTROL_TRB_OFFS           5
N#define MIL_STD_1553_CONTROL_TRB                ((uint32_t)0x00000020)
N
N#define MIL_STD_1553_CONTROL_RTA_OFFS           6
N#define MIL_STD_1553_CONTROL_RTA_MASK           ((uint32_t)0x000007C0)
N
N#define MIL_STD_1553_CONTROL_DIV_OFFS           11
N#define MIL_STD_1553_CONTROL_DIV_MASK           ((uint32_t)0x0003F800)
N
N#define MIL_STD_1553_CONTROL_RERR_OFFS          18
N#define MIL_STD_1553_CONTROL_RERR               ((uint32_t)0x00040000)
N
N
N/** @} */ /* End of group Periph_MIL_STD_1553_MIL_STD_1553_CONTROL_Bits */
N
N/** @} */ /* End of group Periph_MIL_STD_1553_Defines */
N
N/** @defgroup Periph_MIL_STD_1553_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_MIL_STD_1553_STATUS_Bits MIL_STD_1553_STATUS
N  * @{
N  */
N
N#define MIL_STD_1553_STATUS_IDLE_OFFS           0
N#define MIL_STD_1553_STATUS_IDLE                ((uint32_t)0x00000001)
N
N#define MIL_STD_1553_STATUS_RFLAGN_OFFS         1
N#define MIL_STD_1553_STATUS_RFLAGN              ((uint32_t)0x00000002)
N
N#define MIL_STD_1553_STATUS_VALMESS_OFFS        2
N#define MIL_STD_1553_STATUS_VALMESS             ((uint32_t)0x00000004)
N
N#define MIL_STD_1553_STATUS_ERR_OFFS            3
N#define MIL_STD_1553_STATUS_ERR                 ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_MIL_STD_1553_MIL_STD_1553_STATUS_Bits */
N
N/** @} */ /* End of group Periph_MIL_STD_1553_Defines */
N
N/** @defgroup Periph_MIL_STD_1553_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_MIL_STD_1553_ERROR_Bits MIL_STD_1553_ERROR
N  * @{
N  */
N
N#define MIL_STD_1553_ERROR_NORCV_OFFS           0
N#define MIL_STD_1553_ERROR_NORCV                ((uint32_t)0x00000001)
N
N#define MIL_STD_1553_ERROR_MANERR_OFFS          1
N#define MIL_STD_1553_ERROR_MANERR               ((uint32_t)0x00000002)
N
N#define MIL_STD_1553_ERROR_SYNCERR_OFFS         2
N#define MIL_STD_1553_ERROR_SYNCERR              ((uint32_t)0x00000004)
N
N#define MIL_STD_1553_ERROR_SEQERR_OFFS          3
N#define MIL_STD_1553_ERROR_SEQERR               ((uint32_t)0x00000008)
N
N#define MIL_STD_1553_ERROR_GAPERR_OFFS          4
N#define MIL_STD_1553_ERROR_GAPERR               ((uint32_t)0x00000010)
N
N#define MIL_STD_1553_ERROR_CONERR_OFFS          5
N#define MIL_STD_1553_ERROR_CONERR               ((uint32_t)0x00000020)
N
N#define MIL_STD_1553_ERROR_PROERR_OFFS          6
N#define MIL_STD_1553_ERROR_PROERR               ((uint32_t)0x00000040)
N
N
N/** @} */ /* End of group Periph_MIL_STD_1553_MIL_STD_1553_ERROR_Bits */
N
N/** @} */ /* End of group Periph_MIL_STD_1553_Defines */
N
N/** @defgroup Periph_MIL_STD_1553_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_MIL_STD_1553_MIL_STD_1553_INTEN_Bits MIL_STD_1553_INTEN
N  * @{
N  */
N
N#define MIL_STD_1553_INTEN_IDLEIE_OFFS          0
N#define MIL_STD_1553_INTEN_IDLEIE               ((uint32_t)0x00000001)
N
N#define MIL_STD_1553_INTEN_RFLAGNIE_OFFS        1
N#define MIL_STD_1553_INTEN_RFLAGNIE             ((uint32_t)0x00000002)
N
N#define MIL_STD_1553_INTEN_VALMESSIE_OFFS       2
N#define MIL_STD_1553_INTEN_VALMESSIE            ((uint32_t)0x00000004)
N
N#define MIL_STD_1553_INTEN_ERRIE_OFFS           3
N#define MIL_STD_1553_INTEN_ERRIE                ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_MIL_STD_1553_MIL_STD_1553_INTEN_Bits */
N
N/** @} */ /* End of group Periph_MIL_STD_1553_Defines */
N
N/** @} */ /* End of group Periph_MIL_STD_1553 */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_MIL_STD_1553_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_mil_std_1553_defs.h */
L 90 ".\inc\opora.h" 2
N#include "opora_power_defs.h"
L 1 ".\inc\opora_power_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_power_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the POWER peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_power_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_POWER_DEFS_H
N#define __OPORA_POWER_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_POWER_TypeDef POWER_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N} POWER_TypeDef;
N
N/** @} */ /* End of group Periph_POWER_TypeDef */
N
N/** @} */ /* End of group Periph_POWER_Data_Structures */
N
N/** @defgroup Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_POWER_PVDCS_Bits POWER_PVDCS
N  * @{
N  */
N
N#define POWER_PVDCS_PVDEN_OFFS                  0
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N
N#define POWER_PVDCS_PBLS_OFFS                   1
N#define POWER_PVDCS_PBLS_MASK                   ((uint32_t)0x00000006)
N
N#define POWER_PVDCS_PLS_OFFS                    3
N#define POWER_PVDCS_PLS_MASK                    ((uint32_t)0x00000038)
N
N#define POWER_PVDCS_PVBD_OFFS                   6
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N
N#define POWER_PVDCS_PVD_OFFS                    7
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N
N#define POWER_PVDCS_IEPVBD_OFFS                 8
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N
N#define POWER_PVDCS_IEPVD_OFFS                  9
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N
N#define POWER_PVDCS_INVB_OFFS                   10
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N
N#define POWER_PVDCS_INV_OFFS                    11
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N
N/** @} */ /* End of group Periph_POWER_POWER_PVDCS_Bits */
N
N/** @} */ /* End of group Periph_POWER_Defines */
N
N/** @} */ /* End of group Periph_POWER */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_POWER_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_power_defs.h */
L 91 ".\inc\opora.h" 2
N#include "opora_wwdg_defs.h"
L 1 ".\inc\opora_wwdg_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_wwdg_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the WWDG peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_wwdg_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_WWDG_DEFS_H
N#define __OPORA_WWDG_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_TypeDef WWDG_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N} WWDG_TypeDef;
N
N/** @} */ /* End of group Periph_WWDG_TypeDef */
N
N/** @} */ /* End of group Periph_WWDG_Data_Structures */
N
N/** @defgroup Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_WWDG_CR_Bits WWDG_CR
N  * @{
N  */
N
N#define WWDG_CR_T_OFFS                          0
N#define WWDG_CR_T_MASK                          ((uint32_t)0x0000007F)
N
N#define WWDG_CR_WDGA_OFFS                       7
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N
N/** @} */ /* End of group Periph_WWDG_WWDG_CR_Bits */
N
N/** @} */ /* End of group Periph_WWDG_Defines */
N
N/** @defgroup Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_WWDG_CFR_Bits WWDG_CFR
N  * @{
N  */
N
N#define WWDG_CFR_W_OFFS                         0
N#define WWDG_CFR_W_MASK                         ((uint32_t)0x0000007F)
N
N#define WWDG_CFR_WGTB_OFFS                      7
N#define WWDG_CFR_WGTB_MASK                      ((uint32_t)0x00000180)
N
N#define WWDG_CFR_EWI_OFFS                       9
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N
N/** @} */ /* End of group Periph_WWDG_WWDG_CFR_Bits */
N
N/** @} */ /* End of group Periph_WWDG_Defines */
N
N/** @} */ /* End of group Periph_WWDG */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_WWDG_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_wwdg_defs.h */
L 92 ".\inc\opora.h" 2
N#include "opora_iwdg_defs.h"
L 1 ".\inc\opora_iwdg_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_iwdg_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the IWDG peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_iwdg_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_IWDG_DEFS_H
N#define __OPORA_IWDG_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_TypeDef IWDG_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N} IWDG_TypeDef;
N
N/** @} */ /* End of group Periph_IWDG_TypeDef */
N
N/** @} */ /* End of group Periph_IWDG_Data_Structures */
N
N/** @defgroup Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_IWDG_SR_Bits IWDG_SR
N  * @{
N  */
N
N#define IWDG_SR_PVU_OFFS                        0
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N
N#define IWDG_SR_RVU_OFFS                        1
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N
N/** @} */ /* End of group Periph_IWDG_IWDG_SR_Bits */
N
N/** @} */ /* End of group Periph_IWDG_Defines */
N
N/** @} */ /* End of group Periph_IWDG */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_IWDG_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_iwdg_defs.h */
L 93 ".\inc\opora.h" 2
N#include "opora_timer_defs.h"
L 1 ".\inc\opora_timer_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_timer_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the TIMER peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_timer_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_TIMER_DEFS_H
N#define __OPORA_TIMER_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TypeDef TIMER_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N} TIMER_TypeDef;
N
N/** @} */ /* End of group Periph_TIMER_TypeDef */
N
N/** @} */ /* End of group Periph_TIMER_Data_Structures */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_CNTRL_Bits TIMER_CNTRL
N  * @{
N  */
N
N#define TIMER_CNTRL_CNT_EN_OFFS                 0
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N
N#define TIMER_CNTRL_ARRB_EN_OFFS                1
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N
N#define TIMER_CNTRL_WR_CMPL_OFFS                2
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N
N#define TIMER_CNTRL_DIR_OFFS                    3
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N
N#define TIMER_CNTRL_FDTS_OFFS                   4
N#define TIMER_CNTRL_FDTS_MASK                   ((uint32_t)0x00000030)
N
N#define TIMER_CNTRL_CNT_MODE_OFFS               6
N#define TIMER_CNTRL_CNT_MODE_MASK               ((uint32_t)0x000000C0)
N
N#define TIMER_CNTRL_EVENT_SEL_OFFS              8
N#define TIMER_CNTRL_EVENT_SEL_MASK              ((uint32_t)0x00000F00)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_CNTRL_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_CH_CNTRL_Bits TIMER_CH_CNTRL
N  * @{
N  */
N
N#define TIMER_CH_CNTRL_CHFLTR_OFFS              0
N#define TIMER_CH_CNTRL_CHFLTR_MASK              ((uint32_t)0x0000000F)
N
N#define TIMER_CH_CNTRL_CHSEL_OFFS               4
N#define TIMER_CH_CNTRL_CHSEL_MASK               ((uint32_t)0x00000030)
N
N#define TIMER_CH_CNTRL_CHPSC_OFFS               6
N#define TIMER_CH_CNTRL_CHPSC_MASK               ((uint32_t)0x000000C0)
N
N#define TIMER_CH_CNTRL_OCCE_OFFS                8
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N
N#define TIMER_CH_CNTRL_OCCM_OFFS                9
N#define TIMER_CH_CNTRL_OCCM_MASK                ((uint32_t)0x00000E00)
N
N#define TIMER_CH_CNTRL_BRKEN_OFFS               12
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N
N#define TIMER_CH_CNTRL_ETREN_OFFS               13
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N
N#define TIMER_CH_CNTRL_WR_CMPL_OFFS             14
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N
N#define TIMER_CH_CNTRL_CAP_nPWM_OFFS            15
N#define TIMER_CH_CNTRL_CAP_nPWM                 ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_CH_CNTRL_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_CH_CNTRL1_Bits TIMER_CH_CNTRL1
N  * @{
N  */
N
N#define TIMER_CH_CNTRL1_SELOE_OFFS              0
N#define TIMER_CH_CNTRL1_SELOE_MASK              ((uint32_t)0x00000003)
N
N#define TIMER_CH_CNTRL1_SELO_OFFS               2
N#define TIMER_CH_CNTRL1_SELO_MASK               ((uint32_t)0x0000000C)
N
N#define TIMER_CH_CNTRL1_INV_OFFS                4
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N
N#define TIMER_CH_CNTRL1_NSELOE_OFFS             8
N#define TIMER_CH_CNTRL1_NSELOE_MASK             ((uint32_t)0x00000300)
N
N#define TIMER_CH_CNTRL1_NSELO_OFFS              10
N#define TIMER_CH_CNTRL1_NSELO_MASK              ((uint32_t)0x00000C00)
N
N#define TIMER_CH_CNTRL1_NINV_OFFS               12
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_CH_CNTRL1_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_CH_DTG_Bits TIMER_CH_DTG
N  * @{
N  */
N
N#define TIMER_CH_DTG_DTGx_OFFS                  0
N#define TIMER_CH_DTG_DTGx_MASK                  ((uint32_t)0x0000000F)
N
N#define TIMER_CH_DTG_EDTS_OFFS                  4
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N
N#define TIMER_CH_DTG_OFFS                       8
N#define TIMER_CH_DTG_MASK                       ((uint32_t)0x0000FF00)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_CH_DTG_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_BRKETR_CNTRL_Bits TIMER_BRKETR_CNTRL
N  * @{
N  */
N
N#define TIMER_BRKETR_CNTRL_BRK_INV_OFFS         0
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N
N#define TIMER_BRKETR_CNTRL_ETR_INV_OFFS         1
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N
N#define TIMER_BRKETR_CNTRL_ETR_PSC_OFFS         2
N#define TIMER_BRKETR_CNTRL_ETR_PSC_MASK         ((uint32_t)0x0000000C)
N
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_OFFS      4
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_MASK      ((uint32_t)0x000000F0)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_BRKETR_CNTRL_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_STATUS_Bits TIMER_STATUS
N  * @{
N  */
N
N#define TIMER_STATUS_CNT_ZERO_EVENT_OFFS        0
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N
N#define TIMER_STATUS_CNT_ARR_EVENT_OFFS         1
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N
N#define TIMER_STATUS_ETR_RE_EVENT_OFFS          2
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N
N#define TIMER_STATUS_ETR_FE_EVENT_OFFS          3
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N
N#define TIMER_STATUS_BRK_EVENT_OFFS             4
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N
N#define TIMER_STATUS_CCR_CAP_EVENT_OFFS         5
N#define TIMER_STATUS_CCR_CAP_EVENT_MASK         ((uint32_t)0x000001E0)
N
N#define TIMER_STATUS_CCR_REF_EVENT_OFFS         9
N#define TIMER_STATUS_CCR_REF_EVENT_MASK         ((uint32_t)0x00001E00)
N
N#define TIMER_STATUS_CCR1_CAP_EVENT_OFFS        13
N#define TIMER_STATUS_CCR1_CAP_EVENT_MASK        ((uint32_t)0x0001E000)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_STATUS_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_IE_Bits TIMER_IE
N  * @{
N  */
N
N#define TIMER_IE_CNT_ZERO_EVENT_IE_OFFS         0
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N
N#define TIMER_IE_CNT_ARR_EVENT_IE_OFFS          1
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N
N#define TIMER_IE_ETR_RE_EVENT_IE_OFFS           2
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N
N#define TIMER_IE_ETR_FE_EVENT_IE_OFFS           3
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N
N#define TIMER_IE_BRK_EVENT_IE_OFFS              4
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N
N#define TIMER_IE_CCR_CAP_EVENT_IE_OFFS          5
N#define TIMER_IE_CCR_CAP_EVENT_IE_MASK          ((uint32_t)0x000001E0)
N
N#define TIMER_IE_CCR_REF_EVENT_IE_OFFS          9
N#define TIMER_IE_CCR_REF_EVENT_IE_MASK          ((uint32_t)0x00001E00)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_IE_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_DMA_RE_Bits TIMER_DMA_RE
N  * @{
N  */
N
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_OFFS     0
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_OFFS      1
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_OFFS       2
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_OFFS       3
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N
N#define TIMER_DMA_RE_BRK_EVENT_RE_OFFS          4
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_OFFS      5
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_MASK      ((uint32_t)0x000001E0)
N
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_OFFS      9
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_MASK      ((uint32_t)0x00001E00)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_DMA_RE_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @defgroup Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_TIMER_CH_CNTRL2_Bits TIMER_CH_CNTRL2
N  * @{
N  */
N
N#define TIMER_CH_CNTRL2_CHSEL1_OFFS             0
N#define TIMER_CH_CNTRL2_CHSEL1_MASK             ((uint32_t)0x00000003)
N
N#define TIMER_CH_CNTRL2_CCR1_EN_OFFS            2
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N
N#define TIMER_CH_CNTRL2_CCRRLD_OFFS             3
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N
N/** @} */ /* End of group Periph_TIMER_TIMER_CH_CNTRL2_Bits */
N
N/** @} */ /* End of group Periph_TIMER_Defines */
N
N/** @} */ /* End of group Periph_TIMER */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_TIMER_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_timer_defs.h */
L 94 ".\inc\opora.h" 2
N#include "opora_adc_defs.h"
L 1 ".\inc\opora_adc_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_adc_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the ADC peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_adc_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_ADC_DEFS_H
N#define __OPORA_ADC_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_ADC_TypeDef ADC_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N} ADC_TypeDef;
N
N/** @} */ /* End of group Periph_ADC_TypeDef */
N
N/** @} */ /* End of group Periph_ADC_Data_Structures */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC1_CFG_Bits ADC1_CFG
N  * @{
N  */
N
N#define ADC1_CFG_Cfg_REG_ADON_OFFS              0
N#define ADC1_CFG_Cfg_REG_ADON                   ((uint32_t)0x00000001)
N
N#define ADC1_CFG_Cfg_REG_GO_OFFS                1
N#define ADC1_CFG_Cfg_REG_GO                     ((uint32_t)0x00000002)
N
N#define ADC1_CFG_Cfg_REG_CLKS_OFFS              2
N#define ADC1_CFG_Cfg_REG_CLKS                   ((uint32_t)0x00000004)
N
N#define ADC1_CFG_Cfg_REG_SAMPLE_OFFS            3
N#define ADC1_CFG_Cfg_REG_SAMPLE                 ((uint32_t)0x00000008)
N
N#define ADC1_CFG_Cfg_REG_CHS_OFFS               4
N#define ADC1_CFG_Cfg_REG_CHS_MASK               ((uint32_t)0x000001F0)
N
N#define ADC1_CFG_Cfg_REG_CHCH_OFFS              9
N#define ADC1_CFG_Cfg_REG_CHCH                   ((uint32_t)0x00000200)
N
N#define ADC1_CFG_Cfg_REG_RNGC_OFFS              10
N#define ADC1_CFG_Cfg_REG_RNGC                   ((uint32_t)0x00000400)
N
N#define ADC1_CFG_Cfg_M_REF_OFFS                 11
N#define ADC1_CFG_Cfg_M_REF                      ((uint32_t)0x00000800)
N
N#define ADC1_CFG_Cfg_REG_DIVCLK_OFFS            12
N#define ADC1_CFG_Cfg_REG_DIVCLK_MASK            ((uint32_t)0x0000F000)
N
N#define ADC1_CFG_Cfg_Sync_Conver_OFFS           16
N#define ADC1_CFG_Cfg_Sync_Conver                ((uint32_t)0x00010000)
N
N#define ADC1_CFG_TS_EN_OFFS                     17
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N
N#define ADC1_CFG_TS_BUF_EN_OFFS                 18
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N
N#define ADC1_CFG_SEL_TS_OFFS                    19
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N
N#define ADC1_CFG_SEL_VREF_OFFS                  20
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N
N#define ADC1_CFG_TR_OFFS                        21
N#define ADC1_CFG_TR_MASK                        ((uint32_t)0x01E00000)
N
N#define ADC1_CFG_Delay_Go_OFFS                  25
N#define ADC1_CFG_Delay_Go_MASK                  ((uint32_t)0x0E000000)
N
N#define ADC1_CFG_Delay_ADC_OFFS                 28
N#define ADC1_CFG_Delay_ADC_MASK                 ((uint32_t)0xF0000000)
N
N
N/** @} */ /* End of group Periph_ADC_ADC1_CFG_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC2_CFG_Bits ADC2_CFG
N  * @{
N  */
N
N#define ADC2_CFG_Cfg_REG_ADON_OFFS              0
N#define ADC2_CFG_Cfg_REG_ADON                   ((uint32_t)0x00000001)
N
N#define ADC2_CFG_Cfg_REG_GO_OFFS                1
N#define ADC2_CFG_Cfg_REG_GO                     ((uint32_t)0x00000002)
N
N#define ADC2_CFG_Cfg_REG_CLKS_OFFS              2
N#define ADC2_CFG_Cfg_REG_CLKS                   ((uint32_t)0x00000004)
N
N#define ADC2_CFG_Cfg_REG_SAMPLE_OFFS            3
N#define ADC2_CFG_Cfg_REG_SAMPLE                 ((uint32_t)0x00000008)
N
N#define ADC2_CFG_Cfg_REG_CHS_OFFS               4
N#define ADC2_CFG_Cfg_REG_CHS_MASK               ((uint32_t)0x000001F0)
N
N#define ADC2_CFG_Cfg_REG_CHCH_OFFS              9
N#define ADC2_CFG_Cfg_REG_CHCH                   ((uint32_t)0x00000200)
N
N#define ADC2_CFG_Cfg_REG_RNGC_OFFS              10
N#define ADC2_CFG_Cfg_REG_RNGC                   ((uint32_t)0x00000400)
N
N#define ADC2_CFG_Cfg_M_REF_OFFS                 11
N#define ADC2_CFG_Cfg_M_REF                      ((uint32_t)0x00000800)
N
N#define ADC2_CFG_Cfg_REG_DIVCLK_OFFS            12
N#define ADC2_CFG_Cfg_REG_DIVCLK_MASK            ((uint32_t)0x0000F000)
N
N#define ADC2_CFG_ADC1_OP_OFFS                   17
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N
N#define ADC2_CFG_ADC2_OP_OFFS                   18
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N
N#define ADC2_CFG_Delay_Go_OFFS                  25
N#define ADC2_CFG_Delay_Go_MASK                  ((uint32_t)0x0E000000)
N
N
N/** @} */ /* End of group Periph_ADC_ADC2_CFG_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC1_RESULT_Bits ADC1_RESULT
N  * @{
N  */
N
N#define ADC1_RESULT_OFFS                        0
N#define ADC1_RESULT_MASK                        ((uint32_t)0x00000FFF)
N
N#define ADC1_RESULT_CHANNEL_OFFS                16
N#define ADC1_RESULT_CHANNEL_MASK                ((uint32_t)0x0FFF0000)
N
N
N/** @} */ /* End of group Periph_ADC_ADC1_RESULT_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC2_RESULT_Bits ADC2_RESULT
N  * @{
N  */
N
N#define ADC2_RESULT_OFFS                        0
N#define ADC2_RESULT_MASK                        ((uint32_t)0x00000FFF)
N
N#define ADC2_RESULT_CHANNEL_OFFS                16
N#define ADC2_RESULT_CHANNEL_MASK                ((uint32_t)0x0FFF0000)
N
N
N/** @} */ /* End of group Periph_ADC_ADC2_RESULT_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC1_STATUS_Bits ADC1_STATUS
N  * @{
N  */
N
N#define ADC1_STATUS_Flg_REG_OVERWRITE_OFFS      0
N#define ADC1_STATUS_Flg_REG_OVERWRITE           ((uint32_t)0x00000001)
N
N#define ADC1_STATUS_Flg_REG_AWOIFEN_OFFS        1
N#define ADC1_STATUS_Flg_REG_AWOIFEN             ((uint32_t)0x00000002)
N
N#define ADC1_STATUS_Flg_REG_EOCIF_OFFS          2
N#define ADC1_STATUS_Flg_REG_EOCIF               ((uint32_t)0x00000004)
N
N#define ADC1_STATUS_AWOIF_IE_OFFS               3
N#define ADC1_STATUS_AWOIF_IE                    ((uint32_t)0x00000008)
N
N#define ADC1_STATUS_ECOIF_IE_OFFS               4
N#define ADC1_STATUS_ECOIF_IE                    ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_ADC_ADC1_STATUS_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @defgroup Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC_ADC2_STATUS_Bits ADC2_STATUS
N  * @{
N  */
N
N#define ADC2_STATUS_Flg_REG_OVERWRITE_OFFS      0
N#define ADC2_STATUS_Flg_REG_OVERWRITE           ((uint32_t)0x00000001)
N
N#define ADC2_STATUS_Flg_REG_AWOIFEN_OFFS        1
N#define ADC2_STATUS_Flg_REG_AWOIFEN             ((uint32_t)0x00000002)
N
N#define ADC2_STATUS_Flg_REG_EOCIF_OFFS          2
N#define ADC2_STATUS_Flg_REG_EOCIF               ((uint32_t)0x00000004)
N
N#define ADC2_STATUS_AWOIF_IE_OFFS               3
N#define ADC2_STATUS_AWOIF_IE                    ((uint32_t)0x00000008)
N
N#define ADC2_STATUS_ECOIF_IE_OFFS               4
N#define ADC2_STATUS_ECOIF_IE                    ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_ADC_ADC2_STATUS_Bits */
N
N/** @} */ /* End of group Periph_ADC_Defines */
N
N/** @} */ /* End of group Periph_ADC */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_ADC_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_adc_defs.h */
L 95 ".\inc\opora.h" 2
N#include "opora_dac_defs.h"
L 1 ".\inc\opora_dac_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_dac_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the DAC peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_dac_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_DAC_DEFS_H
N#define __OPORA_DAC_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_DAC_TypeDef DAC_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N} DAC_TypeDef;
N
N/** @} */ /* End of group Periph_DAC_TypeDef */
N
N/** @} */ /* End of group Periph_DAC_Data_Structures */
N
N/** @defgroup Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_DAC_CFG_Bits DAC_CFG
N  * @{
N  */
N
N#define DAC_CFG_Cfg_M_REF0_OFFS                 0
N#define DAC_CFG_Cfg_M_REF0                      ((uint32_t)0x00000001)
N
N#define DAC_CFG_Cfg_M_REF1_OFFS                 1
N#define DAC_CFG_Cfg_M_REF1                      ((uint32_t)0x00000002)
N
N#define DAC_CFG_Cfg_ON_DAC0_OFFS                2
N#define DAC_CFG_Cfg_ON_DAC0                     ((uint32_t)0x00000004)
N
N#define DAC_CFG_Cfg_ON_DAC1_OFFS                3
N#define DAC_CFG_Cfg_ON_DAC1                     ((uint32_t)0x00000008)
N
N#define DAC_CFG_Cfg_SYNC_A_OFFS                 4
N#define DAC_CFG_Cfg_SYNC_A                      ((uint32_t)0x00000010)
N
N
N/** @} */ /* End of group Periph_DAC_DAC_CFG_Bits */
N
N/** @} */ /* End of group Periph_DAC_Defines */
N
N/** @defgroup Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_DAC1_DATA_Bits DAC1_DATA
N  * @{
N  */
N
N#define DAC1_DATA_DAC0DATA_OFFS                 0
N#define DAC1_DATA_DAC0DATA_MASK                 ((uint32_t)0x00000FFF)
N
N#define DAC1_DATA_DAC1DATA_OFFS                 16
N#define DAC1_DATA_DAC1DATA_MASK                 ((uint32_t)0x0FFF0000)
N
N
N/** @} */ /* End of group Periph_DAC_DAC1_DATA_Bits */
N
N/** @} */ /* End of group Periph_DAC_Defines */
N
N/** @defgroup Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_DAC2_DATA_Bits DAC2_DATA
N  * @{
N  */
N
N#define DAC2_DATA_DAC1DATA_OFFS                 0
N#define DAC2_DATA_DAC1DATA_MASK                 ((uint32_t)0x00000FFF)
N
N#define DAC2_DATA_DAC0DATA_OFFS                 16
N#define DAC2_DATA_DAC0DATA_MASK                 ((uint32_t)0x0FFF0000)
N
N
N/** @} */ /* End of group Periph_DAC_DAC2_DATA_Bits */
N
N/** @} */ /* End of group Periph_DAC_Defines */
N
N/** @} */ /* End of group Periph_DAC */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_DAC_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_dac_defs.h */
L 96 ".\inc\opora.h" 2
N#include "opora_port_defs.h"
L 1 ".\inc\opora_port_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_port_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the PORT peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_port_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_PORT_DEFS_H
N#define __OPORA_PORT_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_PORT_TypeDef PORT_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N  __IO uint32_t SETTX;
X  volatile uint32_t SETTX;
N  __IO uint32_t CLRTX;
X  volatile uint32_t CLRTX;
N  __IO uint32_t RDTX;
X  volatile uint32_t RDTX;
N} PORT_TypeDef;
N
N/** @} */ /* End of group Periph_PORT_TypeDef */
N
N/** @} */ /* End of group Periph_PORT_Data_Structures */
N
N/** @defgroup Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_PORT_FUNC_Bits PORT_FUNC
N  * @{
N  */
N
N#define PORT_FUNC_MODE0_OFFS                    0
N#define PORT_FUNC_MODE0_MASK                    ((uint32_t)0x00000003)
N
N#define PORT_FUNC_MODE1_OFFS                    2
N#define PORT_FUNC_MODE1_MASK                    ((uint32_t)0x0000000C)
N
N#define PORT_FUNC_MODE2_OFFS                    4
N#define PORT_FUNC_MODE2_MASK                    ((uint32_t)0x00000030)
N
N#define PORT_FUNC_MODE3_OFFS                    6
N#define PORT_FUNC_MODE3_MASK                    ((uint32_t)0x000000C0)
N
N#define PORT_FUNC_MODE4_OFFS                    8
N#define PORT_FUNC_MODE4_MASK                    ((uint32_t)0x00000300)
N
N#define PORT_FUNC_MODE5_OFFS                    10
N#define PORT_FUNC_MODE5_MASK                    ((uint32_t)0x00000C00)
N
N#define PORT_FUNC_MODE6_OFFS                    12
N#define PORT_FUNC_MODE6_MASK                    ((uint32_t)0x00003000)
N
N#define PORT_FUNC_MODE7_OFFS                    14
N#define PORT_FUNC_MODE7_MASK                    ((uint32_t)0x0000C000)
N
N#define PORT_FUNC_MODE8_OFFS                    16
N#define PORT_FUNC_MODE8_MASK                    ((uint32_t)0x00030000)
N
N#define PORT_FUNC_MODE9_OFFS                    18
N#define PORT_FUNC_MODE9_MASK                    ((uint32_t)0x000C0000)
N
N#define PORT_FUNC_MODE10_OFFS                   20
N#define PORT_FUNC_MODE10_MASK                   ((uint32_t)0x00300000)
N
N#define PORT_FUNC_MODE11_OFFS                   22
N#define PORT_FUNC_MODE11_MASK                   ((uint32_t)0x00C00000)
N
N#define PORT_FUNC_MODE12_OFFS                   24
N#define PORT_FUNC_MODE12_MASK                   ((uint32_t)0x03000000)
N
N#define PORT_FUNC_MODE13_OFFS                   26
N#define PORT_FUNC_MODE13_MASK                   ((uint32_t)0x0C000000)
N
N#define PORT_FUNC_MODE14_OFFS                   28
N#define PORT_FUNC_MODE14_MASK                   ((uint32_t)0x30000000)
N
N#define PORT_FUNC_MODE15_OFFS                   30
N#define PORT_FUNC_MODE15_MASK                   ((uint32_t)0xC0000000)
N
N
N/** @} */ /* End of group Periph_PORT_PORT_FUNC_Bits */
N
N/** @} */ /* End of group Periph_PORT_Defines */
N
N/** @defgroup Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_PORT_PWR_Bits PORT_PWR
N  * @{
N  */
N
N#define PORT_PWR_PWR0_OFFS                      0
N#define PORT_PWR_PWR0_MASK                      ((uint32_t)0x00000003)
N
N#define PORT_PWR_PWR1_OFFS                      2
N#define PORT_PWR_PWR1_MASK                      ((uint32_t)0x0000000C)
N
N#define PORT_PWR_PWR2_OFFS                      4
N#define PORT_PWR_PWR2_MASK                      ((uint32_t)0x00000030)
N
N#define PORT_PWR_PWR3_OFFS                      6
N#define PORT_PWR_PWR3_MASK                      ((uint32_t)0x000000C0)
N
N#define PORT_PWR_PWR4_OFFS                      8
N#define PORT_PWR_PWR4_MASK                      ((uint32_t)0x00000300)
N
N#define PORT_PWR_PWR5_OFFS                      10
N#define PORT_PWR_PWR5_MASK                      ((uint32_t)0x00000C00)
N
N#define PORT_PWR_PWR6_OFFS                      12
N#define PORT_PWR_PWR6_MASK                      ((uint32_t)0x00003000)
N
N#define PORT_PWR_PWR7_OFFS                      14
N#define PORT_PWR_PWR7_MASK                      ((uint32_t)0x0000C000)
N
N#define PORT_PWR_PWR8_OFFS                      16
N#define PORT_PWR_PWR8_MASK                      ((uint32_t)0x00030000)
N
N#define PORT_PWR_PWR9_OFFS                      18
N#define PORT_PWR_PWR9_MASK                      ((uint32_t)0x000C0000)
N
N#define PORT_PWR_PWR10_OFFS                     20
N#define PORT_PWR_PWR10_MASK                     ((uint32_t)0x00300000)
N
N#define PORT_PWR_PWR11_OFFS                     22
N#define PORT_PWR_PWR11_MASK                     ((uint32_t)0x00C00000)
N
N#define PORT_PWR_PWR12_OFFS                     24
N#define PORT_PWR_PWR12_MASK                     ((uint32_t)0x03000000)
N
N#define PORT_PWR_PWR13_OFFS                     26
N#define PORT_PWR_PWR13_MASK                     ((uint32_t)0x0C000000)
N
N#define PORT_PWR_PWR14_OFFS                     28
N#define PORT_PWR_PWR14_MASK                     ((uint32_t)0x30000000)
N
N#define PORT_PWR_PWR15_OFFS                     30
N#define PORT_PWR_PWR15_MASK                     ((uint32_t)0xC0000000)
N
N
N/** @} */ /* End of group Periph_PORT_PORT_PWR_Bits */
N
N/** @} */ /* End of group Periph_PORT_Defines */
N
N/** @} */ /* End of group Periph_PORT */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_PORT_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_port_defs.h */
L 97 ".\inc\opora.h" 2
N#include "opora_arinc429r_defs.h"
L 1 ".\inc\opora_arinc429r_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_arinc429r_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the ARINC429R peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_arinc429r_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_ARINC429R_DEFS_H
N#define __OPORA_ARINC429R_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R ARINC429R
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_TypeDef ARINC429R_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CONTROL1;
X  volatile uint32_t CONTROL1;
N  __IO uint32_t CONTROL2;
X  volatile uint32_t CONTROL2;
N  __IO uint32_t CONTROL3;
X  volatile uint32_t CONTROL3;
N  __IO uint32_t STATUS1;
X  volatile uint32_t STATUS1;
N  __IO uint32_t STATUS2;
X  volatile uint32_t STATUS2;
N       uint32_t RESERVED0[2];
N  __IO uint32_t CHANNEL;
X  volatile uint32_t CHANNEL;
N  __IO uint32_t LABEL;
X  volatile uint32_t LABEL;
N  __IO uint32_t DATA_R;
X  volatile uint32_t DATA_R;
N} ARINC429R_TypeDef;
N
N/** @} */ /* End of group Periph_ARINC429R_TypeDef */
N
N/** @} */ /* End of group Periph_ARINC429R_Data_Structures */
N
N/** @defgroup Periph_ARINC429R_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_ARINC429R_CONTROL1_Bits ARINC429R_CONTROL1
N  * @{
N  */
N
N#define ARINC429R_CONTROL1_CH_EN1_OFFS          0
N#define ARINC429R_CONTROL1_CH_EN1               ((uint32_t)0x00000001)
N
N#define ARINC429R_CONTROL1_CH_EN2_OFFS          1
N#define ARINC429R_CONTROL1_CH_EN2               ((uint32_t)0x00000002)
N
N#define ARINC429R_CONTROL1_CH_EN3_OFFS          2
N#define ARINC429R_CONTROL1_CH_EN3               ((uint32_t)0x00000004)
N
N#define ARINC429R_CONTROL1_CH_EN4_OFFS          3
N#define ARINC429R_CONTROL1_CH_EN4               ((uint32_t)0x00000008)
N
N#define ARINC429R_CONTROL1_CH_EN5_OFFS          4
N#define ARINC429R_CONTROL1_CH_EN5               ((uint32_t)0x00000010)
N
N#define ARINC429R_CONTROL1_CH_EN6_OFFS          5
N#define ARINC429R_CONTROL1_CH_EN6               ((uint32_t)0x00000020)
N
N#define ARINC429R_CONTROL1_CH_EN7_OFFS          6
N#define ARINC429R_CONTROL1_CH_EN7               ((uint32_t)0x00000040)
N
N#define ARINC429R_CONTROL1_CH_EN8_OFFS          7
N#define ARINC429R_CONTROL1_CH_EN8               ((uint32_t)0x00000080)
N
N#define ARINC429R_CONTROL1_CLK1_OFFS            14
N#define ARINC429R_CONTROL1_CLK1                 ((uint32_t)0x00004000)
N
N#define ARINC429R_CONTROL1_CLK2_OFFS            15
N#define ARINC429R_CONTROL1_CLK2                 ((uint32_t)0x00008000)
N
N#define ARINC429R_CONTROL1_CLK3_OFFS            16
N#define ARINC429R_CONTROL1_CLK3                 ((uint32_t)0x00010000)
N
N#define ARINC429R_CONTROL1_CLK4_OFFS            17
N#define ARINC429R_CONTROL1_CLK4                 ((uint32_t)0x00020000)
N
N#define ARINC429R_CONTROL1_CLK5_OFFS            18
N#define ARINC429R_CONTROL1_CLK5                 ((uint32_t)0x00040000)
N
N#define ARINC429R_CONTROL1_CLK6_OFFS            19
N#define ARINC429R_CONTROL1_CLK6                 ((uint32_t)0x00080000)
N
N#define ARINC429R_CONTROL1_CLK7_OFFS            20
N#define ARINC429R_CONTROL1_CLK7                 ((uint32_t)0x00100000)
N
N#define ARINC429R_CONTROL1_CLK8_OFFS            21
N#define ARINC429R_CONTROL1_CLK8                 ((uint32_t)0x00200000)
N
N#define ARINC429R_CONTROL1_DIV_OFFS             28
N#define ARINC429R_CONTROL1_DIV_MASK             ((uint32_t)0xF0000000)
N
N
N/** @} */ /* End of group Periph_ARINC429R_ARINC429R_CONTROL1_Bits */
N
N/** @} */ /* End of group Periph_ARINC429R_Defines */
N
N/** @defgroup Periph_ARINC429R_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_ARINC429R_CONTROL2_Bits ARINC429R_CONTROL2
N  * @{
N  */
N
N#define ARINC429R_CONTROL2_DIV_OFFS             0
N#define ARINC429R_CONTROL2_DIV_MASK             ((uint32_t)0x00000007)
N
N#define ARINC429R_CONTROL2_LB_EN1_OFFS          3
N#define ARINC429R_CONTROL2_LB_EN1               ((uint32_t)0x00000008)
N
N#define ARINC429R_CONTROL2_LB_EN2_OFFS          4
N#define ARINC429R_CONTROL2_LB_EN2               ((uint32_t)0x00000010)
N
N#define ARINC429R_CONTROL2_LB_EN3_OFFS          5
N#define ARINC429R_CONTROL2_LB_EN3               ((uint32_t)0x00000020)
N
N#define ARINC429R_CONTROL2_LB_EN4_OFFS          6
N#define ARINC429R_CONTROL2_LB_EN4               ((uint32_t)0x00000040)
N
N#define ARINC429R_CONTROL2_LB_EN5_OFFS          7
N#define ARINC429R_CONTROL2_LB_EN5               ((uint32_t)0x00000080)
N
N#define ARINC429R_CONTROL2_LB_EN6_OFFS          8
N#define ARINC429R_CONTROL2_LB_EN6               ((uint32_t)0x00000100)
N
N#define ARINC429R_CONTROL2_LB_EN7_OFFS          9
N#define ARINC429R_CONTROL2_LB_EN7               ((uint32_t)0x00000200)
N
N#define ARINC429R_CONTROL2_LB_EN8_OFFS          10
N#define ARINC429R_CONTROL2_LB_EN8               ((uint32_t)0x00000400)
N
N#define ARINC429R_CONTROL2_SD_EN1_OFFS          17
N#define ARINC429R_CONTROL2_SD_EN1               ((uint32_t)0x00020000)
N
N#define ARINC429R_CONTROL2_SD_EN2_OFFS          18
N#define ARINC429R_CONTROL2_SD_EN2               ((uint32_t)0x00040000)
N
N#define ARINC429R_CONTROL2_SD_EN3_OFFS          19
N#define ARINC429R_CONTROL2_SD_EN3               ((uint32_t)0x00080000)
N
N#define ARINC429R_CONTROL2_SD_EN4_OFFS          20
N#define ARINC429R_CONTROL2_SD_EN4               ((uint32_t)0x00100000)
N
N#define ARINC429R_CONTROL2_SD_EN5_OFFS          21
N#define ARINC429R_CONTROL2_SD_EN5               ((uint32_t)0x00200000)
N
N#define ARINC429R_CONTROL2_SD_EN6_OFFS          22
N#define ARINC429R_CONTROL2_SD_EN6               ((uint32_t)0x00400000)
N
N#define ARINC429R_CONTROL2_SD_EN7_OFFS          23
N#define ARINC429R_CONTROL2_SD_EN7               ((uint32_t)0x00800000)
N
N#define ARINC429R_CONTROL2_SD_EN8_OFFS          24
N#define ARINC429R_CONTROL2_SD_EN8               ((uint32_t)0x01000000)
N
N
N/** @} */ /* End of group Periph_ARINC429R_ARINC429R_CONTROL2_Bits */
N
N/** @} */ /* End of group Periph_ARINC429R_Defines */
N
N/** @defgroup Periph_ARINC429R_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_ARINC429R_CONTROL3_Bits ARINC429R_CONTROL3
N  * @{
N  */
N
N#define ARINC429R_CONTROL3_SDI1_1_OFFS          0
N#define ARINC429R_CONTROL3_SDI1_1               ((uint32_t)0x00000001)
N
N#define ARINC429R_CONTROL3_SDI1_2_OFFS          1
N#define ARINC429R_CONTROL3_SDI1_2               ((uint32_t)0x00000002)
N
N#define ARINC429R_CONTROL3_SDI1_3_OFFS          2
N#define ARINC429R_CONTROL3_SDI1_3               ((uint32_t)0x00000004)
N
N#define ARINC429R_CONTROL3_SDI1_4_OFFS          3
N#define ARINC429R_CONTROL3_SDI1_4               ((uint32_t)0x00000008)
N
N#define ARINC429R_CONTROL3_SDI1_5_OFFS          4
N#define ARINC429R_CONTROL3_SDI1_5               ((uint32_t)0x00000010)
N
N#define ARINC429R_CONTROL3_SDI1_6_OFFS          5
N#define ARINC429R_CONTROL3_SDI1_6               ((uint32_t)0x00000020)
N
N#define ARINC429R_CONTROL3_SDI1_7_OFFS          6
N#define ARINC429R_CONTROL3_SDI1_7               ((uint32_t)0x00000040)
N
N#define ARINC429R_CONTROL3_SDI1_8_OFFS          7
N#define ARINC429R_CONTROL3_SDI1_8               ((uint32_t)0x00000080)
N
N#define ARINC429R_CONTROL3_SDI2_1_OFFS          14
N#define ARINC429R_CONTROL3_SDI2_1               ((uint32_t)0x00004000)
N
N#define ARINC429R_CONTROL3_SDI2_2_OFFS          15
N#define ARINC429R_CONTROL3_SDI2_2               ((uint32_t)0x00008000)
N
N#define ARINC429R_CONTROL3_SDI2_3_OFFS          16
N#define ARINC429R_CONTROL3_SDI2_3               ((uint32_t)0x00010000)
N
N#define ARINC429R_CONTROL3_SDI2_4_OFFS          17
N#define ARINC429R_CONTROL3_SDI2_4               ((uint32_t)0x00020000)
N
N#define ARINC429R_CONTROL3_SDI2_5_OFFS          18
N#define ARINC429R_CONTROL3_SDI2_5               ((uint32_t)0x00040000)
N
N#define ARINC429R_CONTROL3_SDI2_6_OFFS          19
N#define ARINC429R_CONTROL3_SDI2_6               ((uint32_t)0x00080000)
N
N#define ARINC429R_CONTROL3_SDI2_7_OFFS          20
N#define ARINC429R_CONTROL3_SDI2_7               ((uint32_t)0x00100000)
N
N#define ARINC429R_CONTROL3_SDI2_8_OFFS          21
N#define ARINC429R_CONTROL3_SDI2_8               ((uint32_t)0x00200000)
N
N#define ARINC429R_CONTROL3_INTEDR_OFFS          28
N#define ARINC429R_CONTROL3_INTEDR               ((uint32_t)0x10000000)
N
N#define ARINC429R_CONTROL3_INTEER_OFFS          29
N#define ARINC429R_CONTROL3_INTEER               ((uint32_t)0x20000000)
N
N#define ARINC429R_CONTROL3_INTEFF_OFFS          30
N#define ARINC429R_CONTROL3_INTEFF               ((uint32_t)0x40000000)
N
N#define ARINC429R_CONTROL3_INTEHF_OFFS          31
N#define ARINC429R_CONTROL3_INTEHF               ((uint32_t)0x80000000)
N
N
N/** @} */ /* End of group Periph_ARINC429R_ARINC429R_CONTROL3_Bits */
N
N/** @} */ /* End of group Periph_ARINC429R_Defines */
N
N/** @defgroup Periph_ARINC429R_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_ARINC429R_STATUS1_Bits ARINC429R_STATUS1
N  * @{
N  */
N
N#define ARINC429R_STATUS1_DR1_OFFS              0
N#define ARINC429R_STATUS1_DR1                   ((uint32_t)0x00000001)
N
N#define ARINC429R_STATUS1_DR2_OFFS              1
N#define ARINC429R_STATUS1_DR2                   ((uint32_t)0x00000002)
N
N#define ARINC429R_STATUS1_DR3_OFFS              2
N#define ARINC429R_STATUS1_DR3                   ((uint32_t)0x00000004)
N
N#define ARINC429R_STATUS1_DR4_OFFS              3
N#define ARINC429R_STATUS1_DR4                   ((uint32_t)0x00000008)
N
N#define ARINC429R_STATUS1_DR5_OFFS              4
N#define ARINC429R_STATUS1_DR5                   ((uint32_t)0x00000010)
N
N#define ARINC429R_STATUS1_DR6_OFFS              5
N#define ARINC429R_STATUS1_DR6                   ((uint32_t)0x00000020)
N
N#define ARINC429R_STATUS1_DR7_OFFS              6
N#define ARINC429R_STATUS1_DR7                   ((uint32_t)0x00000040)
N
N#define ARINC429R_STATUS1_DR8_OFFS              7
N#define ARINC429R_STATUS1_DR8                   ((uint32_t)0x00000080)
N
N#define ARINC429R_STATUS1_ERR1_OFFS             14
N#define ARINC429R_STATUS1_ERR1                  ((uint32_t)0x00004000)
N
N#define ARINC429R_STATUS1_ERR2_OFFS             15
N#define ARINC429R_STATUS1_ERR2                  ((uint32_t)0x00008000)
N
N#define ARINC429R_STATUS1_ERR3_OFFS             16
N#define ARINC429R_STATUS1_ERR3                  ((uint32_t)0x00010000)
N
N#define ARINC429R_STATUS1_ERR4_OFFS             17
N#define ARINC429R_STATUS1_ERR4                  ((uint32_t)0x00020000)
N
N#define ARINC429R_STATUS1_ERR5_OFFS             18
N#define ARINC429R_STATUS1_ERR5                  ((uint32_t)0x00040000)
N
N#define ARINC429R_STATUS1_ERR6_OFFS             19
N#define ARINC429R_STATUS1_ERR6                  ((uint32_t)0x00080000)
N
N#define ARINC429R_STATUS1_ERR7_OFFS             20
N#define ARINC429R_STATUS1_ERR7                  ((uint32_t)0x00100000)
N
N#define ARINC429R_STATUS1_ERR8_OFFS             21
N#define ARINC429R_STATUS1_ERR8                  ((uint32_t)0x00200000)
N
N
N/** @} */ /* End of group Periph_ARINC429R_ARINC429R_STATUS1_Bits */
N
N/** @} */ /* End of group Periph_ARINC429R_Defines */
N
N/** @defgroup Periph_ARINC429R_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429R_ARINC429R_STATUS2_Bits ARINC429R_STATUS2
N  * @{
N  */
N
N#define ARINC429R_STATUS2_FF1_OFFS              0
N#define ARINC429R_STATUS2_FF1                   ((uint32_t)0x00000001)
N
N#define ARINC429R_STATUS2_FF2_OFFS              1
N#define ARINC429R_STATUS2_FF2                   ((uint32_t)0x00000002)
N
N#define ARINC429R_STATUS2_FF3_OFFS              2
N#define ARINC429R_STATUS2_FF3                   ((uint32_t)0x00000004)
N
N#define ARINC429R_STATUS2_FF4_OFFS              3
N#define ARINC429R_STATUS2_FF4                   ((uint32_t)0x00000008)
N
N#define ARINC429R_STATUS2_FF5_OFFS              4
N#define ARINC429R_STATUS2_FF5                   ((uint32_t)0x00000010)
N
N#define ARINC429R_STATUS2_FF6_OFFS              5
N#define ARINC429R_STATUS2_FF6                   ((uint32_t)0x00000020)
N
N#define ARINC429R_STATUS2_FF7_OFFS              6
N#define ARINC429R_STATUS2_FF7                   ((uint32_t)0x00000040)
N
N#define ARINC429R_STATUS2_FF8_OFFS              7
N#define ARINC429R_STATUS2_FF8                   ((uint32_t)0x00000080)
N
N#define ARINC429R_STATUS2_HF1_OFFS              14
N#define ARINC429R_STATUS2_HF1                   ((uint32_t)0x00004000)
N
N#define ARINC429R_STATUS2_HF2_OFFS              15
N#define ARINC429R_STATUS2_HF2                   ((uint32_t)0x00008000)
N
N#define ARINC429R_STATUS2_HF3_OFFS              16
N#define ARINC429R_STATUS2_HF3                   ((uint32_t)0x00010000)
N
N#define ARINC429R_STATUS2_HF4_OFFS              17
N#define ARINC429R_STATUS2_HF4                   ((uint32_t)0x00020000)
N
N#define ARINC429R_STATUS2_HF5_OFFS              18
N#define ARINC429R_STATUS2_HF5                   ((uint32_t)0x00040000)
N
N#define ARINC429R_STATUS2_HF6_OFFS              19
N#define ARINC429R_STATUS2_HF6                   ((uint32_t)0x00080000)
N
N#define ARINC429R_STATUS2_HF7_OFFS              20
N#define ARINC429R_STATUS2_HF7                   ((uint32_t)0x00100000)
N
N#define ARINC429R_STATUS2_HF8_OFFS              21
N#define ARINC429R_STATUS2_HF8                   ((uint32_t)0x00200000)
N
N
N/** @} */ /* End of group Periph_ARINC429R_ARINC429R_STATUS2_Bits */
N
N/** @} */ /* End of group Periph_ARINC429R_Defines */
N
N/** @} */ /* End of group Periph_ARINC429R */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_ARINC429R_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_arinc429r_defs.h */
L 98 ".\inc\opora.h" 2
N#include "opora_bkp_defs.h"
L 1 ".\inc\opora_bkp_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_bkp_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the BKP peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_bkp_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_BKP_DEFS_H
N#define __OPORA_BKP_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_BKP_TypeDef BKP_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N} BKP_TypeDef;
N
N/** @} */ /* End of group Periph_BKP_TypeDef */
N
N/** @} */ /* End of group Periph_BKP_Data_Structures */
N
N/** @defgroup Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_BKP_REG_0E_Bits BKP_REG_0E
N  * @{
N  */
N
N#define BKP_REG_0E_LOW_OFFS                     0
N#define BKP_REG_0E_LOW_MASK                     ((uint32_t)0x00000007)
N
N#define BKP_REG_0E_SelectRI_OFFS                3
N#define BKP_REG_0E_SelectRI_MASK                ((uint32_t)0x00000038)
N
N#define BKP_REG_0E_JTAGA_OFFS                   6
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N
N#define BKP_REG_0E_JTAGB_OFFS                   7
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N
N#define BKP_REG_0E_Trim_OFFS                    8
N#define BKP_REG_0E_Trim_MASK                    ((uint32_t)0x00000700)
N
N#define BKP_REG_0E_FPOR_OFFS                    11
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N
N#define BKP_REG_0E_BKP_REG_OFFS                 12
N#define BKP_REG_0E_BKP_REG_MASK                 ((uint32_t)0xFFFFF000)
N
N
N/** @} */ /* End of group Periph_BKP_BKP_REG_0E_Bits */
N
N/** @} */ /* End of group Periph_BKP_Defines */
N
N/** @defgroup Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_BKP_REG_0F_Bits BKP_REG_0F
N  * @{
N  */
N
N#define BKP_REG_0F_LSE_ON_OFFS                  0
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N
N#define BKP_REG_0F_LSE_BYP_OFFS                 1
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N
N#define BKP_REG_0F_RTC_SEL_OFFS                 2
N#define BKP_REG_0F_RTC_SEL_MASK                 ((uint32_t)0x0000000C)
N
N#define BKP_REG_0F_RTC_EN_OFFS                  4
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N
N#define BKP_REG_0F_CAL_OFFS                     5
N#define BKP_REG_0F_CAL_MASK                     ((uint32_t)0x00001FE0)
N
N#define BKP_REG_0F_LSE_RDY_OFFS                 13
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N
N#define BKP_REG_0F_BKP_REG_OFFS                 14
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N
N#define BKP_REG_0F_LSI_ON_OFFS                  15
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N
N#define BKP_REG_0F_LSI_TRIM_OFFS                16
N#define BKP_REG_0F_LSI_TRIM_MASK                ((uint32_t)0x001F0000)
N
N#define BKP_REG_0F_LSI_RDY_OFFS                 21
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N
N#define BKP_REG_0F_HSI_ON_OFFS                  22
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N
N#define BKP_REG_0F_HSI_RDY_OFFS                 23
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N
N#define BKP_REG_0F_HSI_TRIM_OFFS                24
N#define BKP_REG_0F_HSI_TRIM_MASK                ((uint32_t)0x3F000000)
N
N#define BKP_REG_0F_STANDBY_OFFS                 30
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N
N#define BKP_REG_0F_RTC_RESET_OFFS               31
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N
N/** @} */ /* End of group Periph_BKP_BKP_REG_0F_Bits */
N
N/** @} */ /* End of group Periph_BKP_Defines */
N
N/** @defgroup Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_BKP_RTC_CS_Bits BKP_RTC_CS
N  * @{
N  */
N
N#define BKP_RTC_CS_OWF_OFFS                     0
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N
N#define BKP_RTC_CS_SECF_OFFS                    1
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N
N#define BKP_RTC_CS_ALRF_OFFS                    2
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N
N#define BKP_RTC_CS_OWF_IE_OFFS                  3
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N
N#define BKP_RTC_CS_SECF_IE_OFFS                 4
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N
N#define BKP_RTC_CS_ALRF_IE_OFFS                 5
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N
N#define BKP_RTC_CS_WEC_OFFS                     6
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N
N/** @} */ /* End of group Periph_BKP_BKP_RTC_CS_Bits */
N
N/** @} */ /* End of group Periph_BKP_Defines */
N
N/** @} */ /* End of group Periph_BKP */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_BKP_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_bkp_defs.h */
L 99 ".\inc\opora.h" 2
N#include "opora_arinc429t_defs.h"
L 1 ".\inc\opora_arinc429t_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_arinc429t_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the ARINC429T peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_arinc429t_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_ARINC429T_DEFS_H
N#define __OPORA_ARINC429T_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T ARINC429T
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T_TypeDef ARINC429T_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint32_t CONTROL1;
X  volatile uint32_t CONTROL1;
N  __IO uint32_t CONTROL2;
X  volatile uint32_t CONTROL2;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t DATA1_T;
X  volatile uint32_t DATA1_T;
N  __IO uint32_t DATA2_T;
X  volatile uint32_t DATA2_T;
N  __IO uint32_t DATA3_T;
X  volatile uint32_t DATA3_T;
N  __IO uint32_t DATA4_T;
X  volatile uint32_t DATA4_T;
N} ARINC429T_TypeDef;
N
N/** @} */ /* End of group Periph_ARINC429T_TypeDef */
N
N/** @} */ /* End of group Periph_ARINC429T_Data_Structures */
N
N/** @defgroup Periph_ARINC429T_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T_ARINC429T_CONTROL1_Bits ARINC429T_CONTROL1
N  * @{
N  */
N
N#define ARINC429T_CONTROL1_CH_EN1_OFFS          0
N#define ARINC429T_CONTROL1_CH_EN1               ((uint32_t)0x00000001)
N
N#define ARINC429T_CONTROL1_CLK1_OFFS            1
N#define ARINC429T_CONTROL1_CLK1                 ((uint32_t)0x00000002)
N
N#define ARINC429T_CONTROL1_EN_PAR1_OFFS         2
N#define ARINC429T_CONTROL1_EN_PAR1              ((uint32_t)0x00000004)
N
N#define ARINC429T_CONTROL1_ODD1_OFFS            3
N#define ARINC429T_CONTROL1_ODD1                 ((uint32_t)0x00000008)
N
N#define ARINC429T_CONTROL1_CH_EN2_OFFS          4
N#define ARINC429T_CONTROL1_CH_EN2               ((uint32_t)0x00000010)
N
N#define ARINC429T_CONTROL1_CLK2_OFFS            5
N#define ARINC429T_CONTROL1_CLK2                 ((uint32_t)0x00000020)
N
N#define ARINC429T_CONTROL1_EN_PAR2_OFFS         6
N#define ARINC429T_CONTROL1_EN_PAR2              ((uint32_t)0x00000040)
N
N#define ARINC429T_CONTROL1_ODD2_OFFS            7
N#define ARINC429T_CONTROL1_ODD2                 ((uint32_t)0x00000080)
N
N#define ARINC429T_CONTROL1_DIV_OFFS             8
N#define ARINC429T_CONTROL1_DIV_MASK             ((uint32_t)0x00007F00)
N
N#define ARINC429T_CONTROL1_INTE_FFT1_OFFS       15
N#define ARINC429T_CONTROL1_INTE_FFT1            ((uint32_t)0x00008000)
N
N#define ARINC429T_CONTROL1_INTE_TXR1_OFFS       16
N#define ARINC429T_CONTROL1_INTE_TXR1            ((uint32_t)0x00010000)
N
N#define ARINC429T_CONTROL1_INTE_HFT1_OFFS       17
N#define ARINC429T_CONTROL1_INTE_HFT1            ((uint32_t)0x00020000)
N
N#define ARINC429T_CONTROL1_INTE_FFT2_OFFS       18
N#define ARINC429T_CONTROL1_INTE_FFT2            ((uint32_t)0x00040000)
N
N#define ARINC429T_CONTROL1_INTE_TXR2_OFFS       19
N#define ARINC429T_CONTROL1_INTE_TXR2            ((uint32_t)0x00080000)
N
N#define ARINC429T_CONTROL1_INTE_HFT2_OFFS       20
N#define ARINC429T_CONTROL1_INTE_HFT2            ((uint32_t)0x00100000)
N
N
N/** @} */ /* End of group Periph_ARINC429T_ARINC429T_CONTROL1_Bits */
N
N/** @} */ /* End of group Periph_ARINC429T_Defines */
N
N/** @defgroup Periph_ARINC429T_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T_ARINC429T_CONTROL2_Bits ARINC429T_CONTROL2
N  * @{
N  */
N
N#define ARINC429T_CONTROL2_CH_EN3_OFFS          0
N#define ARINC429T_CONTROL2_CH_EN3               ((uint32_t)0x00000001)
N
N#define ARINC429T_CONTROL2_CLK3_OFFS            1
N#define ARINC429T_CONTROL2_CLK3                 ((uint32_t)0x00000002)
N
N#define ARINC429T_CONTROL2_EN_PAR3_OFFS         2
N#define ARINC429T_CONTROL2_EN_PAR3              ((uint32_t)0x00000004)
N
N#define ARINC429T_CONTROL2_ODD3_OFFS            3
N#define ARINC429T_CONTROL2_ODD3                 ((uint32_t)0x00000008)
N
N#define ARINC429T_CONTROL2_CH_EN4_OFFS          4
N#define ARINC429T_CONTROL2_CH_EN4               ((uint32_t)0x00000010)
N
N#define ARINC429T_CONTROL2_CLK4_OFFS            5
N#define ARINC429T_CONTROL2_CLK4                 ((uint32_t)0x00000020)
N
N#define ARINC429T_CONTROL2_EN_PAR4_OFFS         6
N#define ARINC429T_CONTROL2_EN_PAR4              ((uint32_t)0x00000040)
N
N#define ARINC429T_CONTROL2_ODD4_OFFS            7
N#define ARINC429T_CONTROL2_ODD4                 ((uint32_t)0x00000080)
N
N#define ARINC429T_CONTROL2_INTE_FFT3_OFFS       15
N#define ARINC429T_CONTROL2_INTE_FFT3            ((uint32_t)0x00008000)
N
N#define ARINC429T_CONTROL2_INTE_TXR3_OFFS       16
N#define ARINC429T_CONTROL2_INTE_TXR3            ((uint32_t)0x00010000)
N
N#define ARINC429T_CONTROL2_INTE_HFT3_OFFS       17
N#define ARINC429T_CONTROL2_INTE_HFT3            ((uint32_t)0x00020000)
N
N#define ARINC429T_CONTROL2_INTE_FFT4_OFFS       18
N#define ARINC429T_CONTROL2_INTE_FFT4            ((uint32_t)0x00040000)
N
N#define ARINC429T_CONTROL2_INTE_TXR4_OFFS       19
N#define ARINC429T_CONTROL2_INTE_TXR4            ((uint32_t)0x00080000)
N
N#define ARINC429T_CONTROL2_INTE_HFT4_OFFS       20
N#define ARINC429T_CONTROL2_INTE_HFT4            ((uint32_t)0x00100000)
N
N
N/** @} */ /* End of group Periph_ARINC429T_ARINC429T_CONTROL2_Bits */
N
N/** @} */ /* End of group Periph_ARINC429T_Defines */
N
N/** @defgroup Periph_ARINC429T_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ARINC429T_ARINC429T_STATUS_Bits ARINC429T_STATUS
N  * @{
N  */
N
N#define ARINC429T_STATUS_TX_R1_OFFS             0
N#define ARINC429T_STATUS_TX_R1                  ((uint32_t)0x00000001)
N
N#define ARINC429T_STATUS_FFT1_OFFS              1
N#define ARINC429T_STATUS_FFT1                   ((uint32_t)0x00000002)
N
N#define ARINC429T_STATUS_HFT1_OFFS              2
N#define ARINC429T_STATUS_HFT1                   ((uint32_t)0x00000004)
N
N#define ARINC429T_STATUS_TX_R2_OFFS             3
N#define ARINC429T_STATUS_TX_R2                  ((uint32_t)0x00000008)
N
N#define ARINC429T_STATUS_FFT2_OFFS              4
N#define ARINC429T_STATUS_FFT2                   ((uint32_t)0x00000010)
N
N#define ARINC429T_STATUS_HFT2_OFFS              5
N#define ARINC429T_STATUS_HFT2                   ((uint32_t)0x00000020)
N
N#define ARINC429T_STATUS_TX_R3_OFFS             8
N#define ARINC429T_STATUS_TX_R3                  ((uint32_t)0x00000100)
N
N#define ARINC429T_STATUS_FFT3_OFFS              9
N#define ARINC429T_STATUS_FFT3                   ((uint32_t)0x00000200)
N
N#define ARINC429T_STATUS_HFT3_OFFS              10
N#define ARINC429T_STATUS_HFT3                   ((uint32_t)0x00000400)
N
N#define ARINC429T_STATUS_TX_R4_OFFS             11
N#define ARINC429T_STATUS_TX_R4                  ((uint32_t)0x00000800)
N
N#define ARINC429T_STATUS_FFT4_OFFS              12
N#define ARINC429T_STATUS_FFT4                   ((uint32_t)0x00001000)
N
N#define ARINC429T_STATUS_HFT4_OFFS              13
N#define ARINC429T_STATUS_HFT4                   ((uint32_t)0x00002000)
N
N
N/** @} */ /* End of group Periph_ARINC429T_ARINC429T_STATUS_Bits */
N
N/** @} */ /* End of group Periph_ARINC429T_Defines */
N
N/** @} */ /* End of group Periph_ARINC429T */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_ARINC429T_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_arinc429t_defs.h */
L 100 ".\inc\opora.h" 2
N#include "opora_ext_bus_cntrl_defs.h"
L 1 ".\inc\opora_ext_bus_cntrl_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_ext_bus_cntrl_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the EXT_BUS_CNTRL peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_ext_bus_cntrl_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_EXT_BUS_CNTRL_DEFS_H
N#define __OPORA_EXT_BUS_CNTRL_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_EXT_BUS_CNTRL EXT_BUS_CNTRL
N  * @{
N  */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_TypeDef EXT_BUS_CNTRL_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t EXT_BUS_CONTROL;
X  volatile uint32_t EXT_BUS_CONTROL;
N} EXT_BUS_CNTRL_TypeDef;
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_TypeDef */
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_Data_Structures */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_EXT_BUS_CNTRL_NAND_CYCLES_Bits EXT_BUS_CNTRL_NAND_CYCLES
N  * @{
N  */
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rc_OFFS     0
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rc_MASK     ((uint32_t)0x0000000F)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_wc_OFFS     4
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_wc_MASK     ((uint32_t)0x000000F0)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rea_OFFS    8
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rea_MASK    ((uint32_t)0x00000F00)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_wp_OFFS     12
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_wp_MASK     ((uint32_t)0x0000F000)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_whr_OFFS    16
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_whr_MASK    ((uint32_t)0x000F0000)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_alea_OFFS   20
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_alea_MASK   ((uint32_t)0x00F00000)
N
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rr_OFFS     24
N#define EXT_BUS_CNTRL_NAND_CYCLES_t_rr_MASK     ((uint32_t)0x0F000000)
N
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_EXT_BUS_CNTRL_NAND_CYCLES_Bits */
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_Defines */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EXT_BUS_CNTRL_EXT_BUS_CNTRL_EXT_BUS_CONTROL_Bits EXT_BUS_CNTRL_EXT_BUS_CONTROL
N  * @{
N  */
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_ROM_OFFS  0
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_ROM       ((uint32_t)0x00000001)
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_RAM_OFFS  1
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_RAM       ((uint32_t)0x00000002)
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_NAND_OFFS 2
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_NAND      ((uint32_t)0x00000004)
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_CPOL_OFFS 3
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_CPOL      ((uint32_t)0x00000008)
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_BUSY_OFFS 7
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_BUSY      ((uint32_t)0x00000080)
N
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_WAIT_STATE_OFFS 12
N#define EXT_BUS_CNTRL_EXT_BUS_CONTROL_WAIT_STATE_MASK ((uint32_t)0x0000F000)
N
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_EXT_BUS_CNTRL_EXT_BUS_CONTROL_Bits */
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL_Defines */
N
N/** @} */ /* End of group Periph_EXT_BUS_CNTRL */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_EXT_BUS_CNTRL_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_ext_bus_cntrl_defs.h */
L 101 ".\inc\opora.h" 2
N#include "opora_ethernet_defs.h"
L 1 ".\inc\opora_ethernet_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_ethernet_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the ETHERNET peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_ethernet_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_ETHERNET_DEFS_H
N#define __OPORA_ETHERNET_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET ETHERNET
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_TypeDef ETHERNET_TypeDef
N  * @{
N  */
N
Ntypedef struct {
N  __IO uint16_t Delimiter;	//00 offset
X  volatile uint16_t Delimiter;	
N  __IO uint16_t MAC_T;		//02
X  volatile uint16_t MAC_T;		
N  __IO uint16_t MAC_M;		//04
X  volatile uint16_t MAC_M;		
N  __IO uint16_t MAC_H;		//06
X  volatile uint16_t MAC_H;		
N  __IO uint16_t HASH0;		//08
X  volatile uint16_t HASH0;		
N  __IO uint16_t HASH1;		//0A
X  volatile uint16_t HASH1;		
N  __IO uint16_t HASH2;		//0C
X  volatile uint16_t HASH2;		
N  __IO uint16_t HASH3;		//0E
X  volatile uint16_t HASH3;		
N  __IO uint16_t IPG;		//10
X  volatile uint16_t IPG;		
N  __IO uint16_t PSC;		//12
X  volatile uint16_t PSC;		
N  __IO uint16_t BAG;		//14
X  volatile uint16_t BAG;		
N  __IO uint16_t JitterWnd;	//16
X  volatile uint16_t JitterWnd;	
N  __IO uint16_t R_CFG;		//18
X  volatile uint16_t R_CFG;		
N  __IO uint16_t X_CFG;		//1A
X  volatile uint16_t X_CFG;		
N  __IO uint32_t G_CFG;		//1C
X  volatile uint32_t G_CFG;		
N  __IO uint16_t IMR;		//20
X  volatile uint16_t IMR;		
N  __IO uint16_t IFR;		//22
X  volatile uint16_t IFR;		
N  __IO uint16_t MDIO_CTRL;	//24
X  volatile uint16_t MDIO_CTRL;	
N  __IO uint16_t MDIO_DATA;	//26
X  volatile uint16_t MDIO_DATA;	
N  __IO uint16_t R_Head;		//28
X  volatile uint16_t R_Head;		
N  __IO uint16_t X_Tail;		//2A
X  volatile uint16_t X_Tail;		
N  __IO uint16_t R_Tail;		//2C
X  volatile uint16_t R_Tail;		
N  __IO uint16_t X_Head;		//2E
X  volatile uint16_t X_Head;		
N  __IO uint16_t STAT;		//30
X  volatile uint16_t STAT;		
N  __IO uint16_t RESERV;		//32
X  volatile uint16_t RESERV;		
N  __IO uint16_t PHY_CTRL;	//34
X  volatile uint16_t PHY_CTRL;	
N  __IO uint16_t PHY_STATUS;	//36
X  volatile uint16_t PHY_STATUS;	
N} ETHERNET_TypeDef;
N
N/** @} */ /* End of group Periph_ETHERNET_TypeDef */
N
N/** @} */ /* End of group Periph_ETHERNET_Data_Structures */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_R_CFG_Bits ETHERNET_ETH_R_CFG
N  * @{
N  */
N
N#define ETHERNET_ETH_R_CFG_MCA_EN_OFFS          0
N#define ETHERNET_ETH_R_CFG_MCA_EN               ((uint32_t)0x00000001)
N
N#define ETHERNET_ETH_R_CFG_BCA_EN_OFFS          1
N#define ETHERNET_ETH_R_CFG_BCA_EN               ((uint32_t)0x00000002)
N
N#define ETHERNET_ETH_R_CFG_UCA_EN_OFFS          2
N#define ETHERNET_ETH_R_CFG_UCA_EN               ((uint32_t)0x00000004)
N
N#define ETHERNET_ETH_R_CFG_AC_EN_OFFS           3
N#define ETHERNET_ETH_R_CFG_AC_EN                ((uint32_t)0x00000008)
N
N#define ETHERNET_ETH_R_CFG_EF_EN_OFFS           4
N#define ETHERNET_ETH_R_CFG_EF_EN                ((uint32_t)0x00000010)
N
N#define ETHERNET_ETH_R_CFG_CF_EN_OFFS           5
N#define ETHERNET_ETH_R_CFG_CF_EN                ((uint32_t)0x00000020)
N
N#define ETHERNET_ETH_R_CFG_LF_EN_OFFS           6
N#define ETHERNET_ETH_R_CFG_LF_EN                ((uint32_t)0x00000040)
N
N#define ETHERNET_ETH_R_CFG_SF_EN_OFFS           7
N#define ETHERNET_ETH_R_CFG_SF_EN                ((uint32_t)0x00000080)
N
N#define ETHERNET_ETH_R_CFG_EVNT_MODE_OFFS       8
N#define ETHERNET_ETH_R_CFG_EVNT_MODE_MASK       ((uint32_t)0x00000700)
N
N#define ETHERNET_ETH_R_CFG_MSB1st_OFFS          12
N#define ETHERNET_ETH_R_CFG_MSB1st               ((uint32_t)0x00001000)
N
N#define ETHERNET_ETH_R_CFG_BE_OFFS              13
N#define ETHERNET_ETH_R_CFG_BE                   ((uint32_t)0x00002000)
N
N#define ETHERNET_ETH_R_CFG_RST_OFFS             15
N#define ETHERNET_ETH_R_CFG_RST                  ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_R_CFG_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_X_CFG_Bits ETHERNET_ETH_X_CFG
N  * @{
N  */
N
N#define ETHERNET_ETH_X_CFG_RtryCnt_OFFS         0
N#define ETHERNET_ETH_X_CFG_RtryCnt_MASK         ((uint32_t)0x0000000F)
N
N#define ETHERNET_ETH_X_CFG_IPG_EN_OFFS          4
N#define ETHERNET_ETH_X_CFG_IPG_EN               ((uint32_t)0x00000010)
N
N#define ETHERNET_ETH_X_CFG_CRC_EN_OFFS          5
N#define ETHERNET_ETH_X_CFG_CRC_EN               ((uint32_t)0x00000020)
N
N#define ETHERNET_ETH_X_CFG_PRE_EN_OFFS          6
N#define ETHERNET_ETH_X_CFG_PRE_EN               ((uint32_t)0x00000040)
N
N#define ETHERNET_ETH_X_CFG_PAD_EN_OFFS          7
N#define ETHERNET_ETH_X_CFG_PAD_EN               ((uint32_t)0x00000080)
N
N#define ETHERNET_ETH_X_CFG_EVNT_MODE_OFFS       8
N#define ETHERNET_ETH_X_CFG_EVNT_MODE_MASK       ((uint32_t)0x00000700)
N
N#define ETHERNET_ETH_X_CFG_MSB1st_OFFS          12
N#define ETHERNET_ETH_X_CFG_MSB1st               ((uint32_t)0x00001000)
N
N#define ETHERNET_ETH_X_CFG_BE_OFFS              13
N#define ETHERNET_ETH_X_CFG_BE                   ((uint32_t)0x00002000)
N
N#define ETHERNET_ETH_X_CFG_RST_OFFS             15
N#define ETHERNET_ETH_X_CFG_RST                  ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_X_CFG_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_G_CFG_Bits ETHERNET_ETH_G_CFG
N  * @{
N  */
N
N#define ETHERNET_ETH_G_CFG_ColWnd_OFFS          0
N#define ETHERNET_ETH_G_CFG_ColWnd_MASK          ((uint32_t)0x000000FF)
N
N#define ETHERNET_ETH_G_CFG_PAUSE_EN_OFFS        8
N#define ETHERNET_ETH_G_CFG_PAUSE_EN             ((uint32_t)0x00000100)
N
N#define ETHERNET_ETH_G_CFG_DTRM_EN_OFFS         9
N#define ETHERNET_ETH_G_CFG_DTRM_EN              ((uint32_t)0x00000200)
N
N#define ETHERNET_ETH_G_CFG_HD_EN_OFFS           10
N#define ETHERNET_ETH_G_CFG_HD_EN                ((uint32_t)0x00000400)
N
N#define ETHERNET_ETH_G_CFG_DLB_OFFS             11
N#define ETHERNET_ETH_G_CFG_DLB                  ((uint32_t)0x00000800)
N
N#define ETHERNET_ETH_G_CFG_AB_MODE_OFFS         12
N#define ETHERNET_ETH_G_CFG_AB_MODE              ((uint32_t)0x00001000)
N
N#define ETHERNET_ETH_G_CFG_SOFT_OFFS            14
N#define ETHERNET_ETH_G_CFG_SOFT                 ((uint32_t)0x00004000)
N
N#define ETHERNET_ETH_G_CFG_FREE_OFFS            15
N#define ETHERNET_ETH_G_CFG_FREE                 ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_G_CFG_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_IMR_Bits ETHERNET_ETH_IMR
N  * @{
N  */
N
N#define ETHERNET_ETH_IMR_RF_OK_OFFS             0
N#define ETHERNET_ETH_IMR_RF_OK                  ((uint32_t)0x00000001)
N
N#define ETHERNET_ETH_IMR_MISSED_F_OFFS          1
N#define ETHERNET_ETH_IMR_MISSED_F               ((uint32_t)0x00000002)
N
N#define ETHERNET_ETH_IMR_OVF_OFFS               2
N#define ETHERNET_ETH_IMR_OVF                    ((uint32_t)0x00000004)
N
N#define ETHERNET_ETH_IMR_SMB_ERR_OFFS           3
N#define ETHERNET_ETH_IMR_SMB_ERR                ((uint32_t)0x00000008)
N
N#define ETHERNET_ETH_IMR_CRC_ERR_OFFS           4
N#define ETHERNET_ETH_IMR_CRC_ERR                ((uint32_t)0x00000010)
N
N#define ETHERNET_ETH_IMR_CF_OFFS                5
N#define ETHERNET_ETH_IMR_CF                     ((uint32_t)0x00000020)
N
N#define ETHERNET_ETH_IMR_LF_OFFS                6
N#define ETHERNET_ETH_IMR_LF                     ((uint32_t)0x00000040)
N
N#define ETHERNET_ETH_IMR_SF_OFFS                7
N#define ETHERNET_ETH_IMR_SF                     ((uint32_t)0x00000080)
N
N#define ETHERNET_ETH_IMR_XF_OK_OFFS             8
N#define ETHERNET_ETH_IMR_XF_OK                  ((uint32_t)0x00000100)
N
N#define ETHERNET_ETH_IMR_XF_ERR_OFFS            9
N#define ETHERNET_ETH_IMR_XF_ERR                 ((uint32_t)0x00000200)
N
N#define ETHERNET_ETH_IMR_UNDF_OFFS              10
N#define ETHERNET_ETH_IMR_UNDF                   ((uint32_t)0x00000400)
N
N#define ETHERNET_ETH_IMR_LC_OFFS                11
N#define ETHERNET_ETH_IMR_LC                     ((uint32_t)0x00000800)
N
N#define ETHERNET_ETH_IMR_CRS_LOST_OFFS          12
N#define ETHERNET_ETH_IMR_CRS_LOST               ((uint32_t)0x00001000)
N
N#define ETHERNET_ETH_IMR_MII_RDY_OFFS           15
N#define ETHERNET_ETH_IMR_MII_RDY                ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_IMR_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_IFR_Bits ETHERNET_ETH_IFR
N  * @{
N  */
N
N#define ETHERNET_ETH_IFR_RF_OK_OFFS             0
N#define ETHERNET_ETH_IFR_RF_OK                  ((uint32_t)0x00000001)
N
N#define ETHERNET_ETH_IFR_MISSED_F_OFFS          1
N#define ETHERNET_ETH_IFR_MISSED_F               ((uint32_t)0x00000002)
N
N#define ETHERNET_ETH_IFR_OVF_OFFS               2
N#define ETHERNET_ETH_IFR_OVF                    ((uint32_t)0x00000004)
N
N#define ETHERNET_ETH_IFR_SMB_ERR_OFFS           3
N#define ETHERNET_ETH_IFR_SMB_ERR                ((uint32_t)0x00000008)
N
N#define ETHERNET_ETH_IFR_CRC_ERR_OFFS           4
N#define ETHERNET_ETH_IFR_CRC_ERR                ((uint32_t)0x00000010)
N
N#define ETHERNET_ETH_IFR_CF_OFFS                5
N#define ETHERNET_ETH_IFR_CF                     ((uint32_t)0x00000020)
N
N#define ETHERNET_ETH_IFR_LF_OFFS                6
N#define ETHERNET_ETH_IFR_LF                     ((uint32_t)0x00000040)
N
N#define ETHERNET_ETH_IFR_SF_OFFS                7
N#define ETHERNET_ETH_IFR_SF                     ((uint32_t)0x00000080)
N
N#define ETHERNET_ETH_IFR_XF_OK_OFFS             8
N#define ETHERNET_ETH_IFR_XF_OK                  ((uint32_t)0x00000100)
N
N#define ETHERNET_ETH_IFR_XF_ERR_OFFS            9
N#define ETHERNET_ETH_IFR_XF_ERR                 ((uint32_t)0x00000200)
N
N#define ETHERNET_ETH_IFR_UNDF_OFFS              10
N#define ETHERNET_ETH_IFR_UNDF                   ((uint32_t)0x00000400)
N
N#define ETHERNET_ETH_IFR_LC_OFFS                11
N#define ETHERNET_ETH_IFR_LC                     ((uint32_t)0x00000800)
N
N#define ETHERNET_ETH_IFR_CRS_LOST_OFFS          12
N#define ETHERNET_ETH_IFR_CRS_LOST               ((uint32_t)0x00001000)
N
N#define ETHERNET_ETH_IFR_MII_RDY_OFFS           15
N#define ETHERNET_ETH_IFR_MII_RDY                ((uint32_t)0x00008000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_IFR_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_MDIO_CTRL_Bits ETHERNET_ETH_MDIO_CTRL
N  * @{
N  */
N
N#define ETHERNET_ETH_MDIO_CTRL_RG_A_OFFS        0
N#define ETHERNET_ETH_MDIO_CTRL_RG_A_MASK        ((uint32_t)0x0000001F)
N
N#define ETHERNET_ETH_MDIO_CTRL_DIV_OFFS         5
N#define ETHERNET_ETH_MDIO_CTRL_DIV_MASK         ((uint32_t)0x000000E0)
N
N#define ETHERNET_ETH_MDIO_CTRL_PHY_A_OFFS       8
N#define ETHERNET_ETH_MDIO_CTRL_PHY_A_MASK       ((uint32_t)0x00001F00)
N
N#define ETHERNET_ETH_MDIO_CTRL_OP_OFFS          13
N#define ETHERNET_ETH_MDIO_CTRL_OP               ((uint32_t)0x00002000)
N
N#define ETHERNET_ETH_MDIO_CTRL_PRE_EN_OFFS      14
N#define ETHERNET_ETH_MDIO_CTRL_PRE_EN           ((uint32_t)0x00004000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_MDIO_CTRL_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @defgroup Periph_ETHERNET_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ETHERNET_ETHERNET_ETH_BUFF_STAT_Bits ETHERNET_ETH_BUFF_STAT
N  * @{
N  */
N
N#define ETHERNET_ETH_Buff_Stat_R_EMPTY_OFFS     0
N#define ETHERNET_ETH_Buff_Stat_R_EMPTY          ((uint32_t)0x00000001)
N
N#define ETHERNET_ETH_Buff_Stat_R_AEMPTY_OFFS    1
N#define ETHERNET_ETH_Buff_Stat_R_AEMPTY         ((uint32_t)0x00000002)
N
N#define ETHERNET_ETH_Buff_Stat_R_HALF_OFFS      2
N#define ETHERNET_ETH_Buff_Stat_R_HALF           ((uint32_t)0x00000004)
N
N#define ETHERNET_ETH_Buff_Stat_R_AFULL_OFFS     3
N#define ETHERNET_ETH_Buff_Stat_R_AFULL          ((uint32_t)0x00000008)
N
N#define ETHERNET_ETH_Buff_Stat_R_FULL_OFFS      4
N#define ETHERNET_ETH_Buff_Stat_R_FULL           ((uint32_t)0x00000010)
N
N#define ETHERNET_ETH_Buff_Stat_X_EMPTY_OFFS     8
N#define ETHERNET_ETH_Buff_Stat_X_EMPTY          ((uint32_t)0x00000100)
N
N#define ETHERNET_ETH_Buff_Stat_X_AEMPTY_OFFS    9
N#define ETHERNET_ETH_Buff_Stat_X_AEMPTY         ((uint32_t)0x00000200)
N
N#define ETHERNET_ETH_Buff_Stat_X_HALF_OFFS      10
N#define ETHERNET_ETH_Buff_Stat_X_HALF           ((uint32_t)0x00000400)
N
N#define ETHERNET_ETH_Buff_Stat_X_AFULL_OFFS     11
N#define ETHERNET_ETH_Buff_Stat_X_AFULL          ((uint32_t)0x00000800)
N
N#define ETHERNET_ETH_Buff_Stat_X_FULL_OFFS      12
N#define ETHERNET_ETH_Buff_Stat_X_FULL           ((uint32_t)0x00001000)
N
N
N/** @} */ /* End of group Periph_ETHERNET_ETHERNET_ETH_BUFF_STAT_Bits */
N
N/** @} */ /* End of group Periph_ETHERNET_Defines */
N
N/** @} */ /* End of group Periph_ETHERNET */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_ETHERNET_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_ethernet_defs.h */
L 102 ".\inc\opora.h" 2
N#include "opora_sys_defs.h"
L 1 ".\inc\opora_sys_defs.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_sys_defs.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the SYS peripheral unit used in the Milandr OPORA
N  *          microcontrollers.
N  ******************************************************************************
N  * @copy
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_sys_defs.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_SYS_DEFS_H
N#define __OPORA_SYS_DEFS_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @addtogroup __OPORA_Peripheral_Units OPORA Peripheral Units
N  * @{
N  */
N
N/** @defgroup Periph_SYS SYS
N  * @{
N  */
N
N/** @defgroup Periph_SYS_Data_Structures Data Structures
N  * @{
N  */
N
N/** @defgroup Periph_SYS_TypeDef SYS_TypeDef
N  * @{
N  */
N
Ntypedef struct {				 //Offset
N       uint32_t RESERVED0[2];	 //00
N  __IO uint32_t ACTLR;			 //08
X  volatile uint32_t ACTLR;			 
N       uint32_t RESERVED1;		 //0C
N  __IO uint32_t STCSR;			 //10
X  volatile uint32_t STCSR;			 
N  __IO uint32_t STRVR;			 //14
X  volatile uint32_t STRVR;			 
N  __IO uint32_t STCVR;			 //18
X  volatile uint32_t STCVR;			 
N  __IO uint32_t STCR;			 //1C
X  volatile uint32_t STCR;			 
N       uint32_t RESERVED2[56];	 //20
N  __IO uint32_t ISER;			 //100
X  volatile uint32_t ISER;			 
N       uint32_t RESERVED3[31];	 //104
N  __IO uint32_t ICER;			 //180
X  volatile uint32_t ICER;			 
N       uint32_t RESERVED4[31];	 //184
N  __IO uint32_t ISPR;			 //200
X  volatile uint32_t ISPR;			 
N       uint32_t RESERVED5[31];	 //204
N  __IO uint32_t ICPR;			 //280
X  volatile uint32_t ICPR;			 
N       uint32_t RESERVED6[95];	 //284
N  __IO uint32_t IPR0;			 //400
X  volatile uint32_t IPR0;			 
N  __IO uint32_t IPR1;			 //404
X  volatile uint32_t IPR1;			 
N  __IO uint32_t IPR2;			 //408
X  volatile uint32_t IPR2;			 
N  __IO uint32_t IPR3;			 //40C
X  volatile uint32_t IPR3;			 
N  __IO uint32_t IPR4;			 //410
X  volatile uint32_t IPR4;			 
N  __IO uint32_t IPR5;			 //414
X  volatile uint32_t IPR5;			 
N  __IO uint32_t IPR6;			 //418
X  volatile uint32_t IPR6;			 
N  __IO uint32_t IPR7;			 //41C
X  volatile uint32_t IPR7;			 
N       uint32_t RESERVED7[568];	 //420
N  __IO uint32_t CPUID;			 //D00
X  volatile uint32_t CPUID;			 
N  __IO uint32_t ICSR;			 //D04
X  volatile uint32_t ICSR;			 
N       uint32_t RESERVED8;		 //D08
N  __IO uint32_t AIRCR;			 //D0C
X  volatile uint32_t AIRCR;			 
N       uint32_t RESERVED9;		 //D10
N  __IO uint32_t CCR;			 //D14
X  volatile uint32_t CCR;			 
N       uint32_t RESERVED10;		 //D18
N  __IO uint32_t SHPR2;			 //D1C
X  volatile uint32_t SHPR2;			 
N  __IO uint32_t SHPR3;			 //D20
X  volatile uint32_t SHPR3;			 
N  __IO uint32_t SHCSR;			 //D24
X  volatile uint32_t SHCSR;			 
N} SYS_TypeDef;
N
N/** @} */ /* End of group Periph_SYS_TypeDef */
N
N/** @} */ /* End of group Periph_SYS_Data_Structures */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_ACTLR_Bits SYS_ACTLR
N  * @{
N  */
N
N#define SYS_ACTLR_ITCMLAEN_OFFS                 0
N#define SYS_ACTLR_ITCMLAEN                      ((uint32_t)0x00000001)
N
N#define SYS_ACTLR_ITCMUAEN_OFFS                 1
N#define SYS_ACTLR_ITCMUAEN                      ((uint32_t)0x00000002)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_ACTLR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_STCSR_Bits SYS_STCSR
N  * @{
N  */
N
N#define SYS_STCSR_ENABLE_OFFS                   0
N#define SYS_STCSR_ENABLE                        ((uint32_t)0x00000001)
N
N#define SYS_STCSR_TICKINT_OFFS                  1
N#define SYS_STCSR_TICKINT                       ((uint32_t)0x00000002)
N
N#define SYS_STCSR_CLKSOURCE_OFFS                2
N#define SYS_STCSR_CLKSOURCE                     ((uint32_t)0x00000004)
N
N#define SYS_STCSR_COUNTFLAG_OFFS                16
N#define SYS_STCSR_COUNTFLAG                     ((uint32_t)0x00010000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_STCSR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_STCR_Bits SYS_STCR
N  * @{
N  */
N
N#define SYS_STCR_TENMS_OFFS                     0
N#define SYS_STCR_TENMS_MASK                     ((uint32_t)0x00FFFFFF)
N
N#define SYS_STCR_SKEW_OFFS                      30
N#define SYS_STCR_SKEW                           ((uint32_t)0x40000000)
N
N#define SYS_STCR_NOREF_OFFS                     31
N#define SYS_STCR_NOREF                          ((uint32_t)0x80000000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_STCR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_IPR_Bits SYS_IPR
N  * @{
N  */
N
N#define SYS_IPR_PRI_N_OFFS                      0
N#define SYS_IPR_PRI_N_MASK                      ((uint32_t)0x00000003)
N
N#define SYS_IPR_PRI_N1_OFFS                     8
N#define SYS_IPR_PRI_N1_MASK                     ((uint32_t)0x00000300)
N
N#define SYS_IPR_PRI_N2_OFFS                     16
N#define SYS_IPR_PRI_N2_MASK                     ((uint32_t)0x00030000)
N
N#define SYS_IPR_PRI_N3_OFFS                     24
N#define SYS_IPR_PRI_N3_MASK                     ((uint32_t)0x03000000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_IPR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_CPUID_Bits SYS_CPUID
N  * @{
N  */
N
N#define SYS_CPUID_REVISION_OFFS                 0
N#define SYS_CPUID_REVISION_MASK                 ((uint32_t)0x0000000F)
N
N#define SYS_CPUID_PARTNO_OFFS                   4
N#define SYS_CPUID_PARTNO_MASK                   ((uint32_t)0x0000FFF0)
N
N#define SYS_CPUID_Const_0xF_OFFS                16
N#define SYS_CPUID_Const_0xF_MASK                ((uint32_t)0x000F0000)
N
N#define SYS_CPUID_VARIANT_OFFS                  20
N#define SYS_CPUID_VARIANT_MASK                  ((uint32_t)0x00F00000)
N
N#define SYS_CPUID_IMPLEMENTER_OFFS              24
N#define SYS_CPUID_IMPLEMENTER_MASK              ((uint32_t)0xFF000000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_CPUID_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_ICSR_Bits SYS_ICSR
N  * @{
N  */
N
N#define SYS_ICSR_VECTACTIVE_OFFS                0
N#define SYS_ICSR_VECTACTIVE_MASK                ((uint32_t)0x0000003F)
N
N#define SYS_ICSR_VECTPENDING_OFFS               12
N#define SYS_ICSR_VECTPENDING_MASK               ((uint32_t)0x0003F000)
N
N#define SYS_ICSR_ISRPENDING_OFFS                22
N#define SYS_ICSR_ISRPENDING                     ((uint32_t)0x00400000)
N
N#define SYS_ICSR_ISRPREEMPT_OFFS                23
N#define SYS_ICSR_ISRPREEMPT                     ((uint32_t)0x00800000)
N
N#define SYS_ICSR_PENDSTCLR_OFFS                 25
N#define SYS_ICSR_PENDSTCLR                      ((uint32_t)0x02000000)
N
N#define SYS_ICSR_PENDSTSET_OFFS                 26
N#define SYS_ICSR_PENDSTSET                      ((uint32_t)0x04000000)
N
N#define SYS_ICSR_PENDSVCLR_OFFS                 27
N#define SYS_ICSR_PENDSVCLR                      ((uint32_t)0x08000000)
N
N#define SYS_ICSR_PENDSVSET_OFFS                 28
N#define SYS_ICSR_PENDSVSET                      ((uint32_t)0x10000000)
N
N#define SYS_ICSR_NMIPENDSET_OFFS                31
N#define SYS_ICSR_NMIPENDSET                     ((uint32_t)0x80000000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_ICSR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_AIRCR_Bits SYS_AIRCR
N  * @{
N  */
N
N#define SYS_AIRCR_VECTCLRACTIVE_OFFS            0
N#define SYS_AIRCR_VECTCLRACTIVE                 ((uint32_t)0x00000001)
N
N#define SYS_AIRCR_SYSRESETREQ_OFFS              1
N#define SYS_AIRCR_SYSRESETREQ                   ((uint32_t)0x00000002)
N
N#define SYS_AIRCR_ENDIANESS_OFFS                14
N#define SYS_AIRCR_ENDIANESS                     ((uint32_t)0x00004000)
N
N#define SYS_AIRCR_VECTKEYSTAT_OFFS              15
N#define SYS_AIRCR_VECTKEYSTAT_MASK              ((uint32_t)0x7FFF8000)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_AIRCR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_CCR_Bits SYS_CCR
N  * @{
N  */
N
N#define SYS_CCR_UNALIGN_TRP_OFFS                0
N#define SYS_CCR_UNALIGN_TRP                     ((uint32_t)0x00000001)
N
N#define SYS_CCR_STKALIGN_OFFS                   6
N#define SYS_CCR_STKALIGN                        ((uint32_t)0x00000040)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_CCR_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @defgroup Periph_SYS_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SYS_SYS_SHPR3_Bits SYS_SHPR3
N  * @{
N  */
N
N#define SYS_SHPR3_PRI_14_OFFS                   0
N#define SYS_SHPR3_PRI_14_MASK                   ((uint32_t)0x00000003)
N
N#define SYS_SHPR3_PRI_15_OFFS                   8
N#define SYS_SHPR3_PRI_15_MASK                   ((uint32_t)0x00000300)
N
N
N/** @} */ /* End of group Periph_SYS_SYS_SHPR3_Bits */
N
N/** @} */ /* End of group Periph_SYS_Defines */
N
N/** @} */ /* End of group Periph_SYS */
N
N/** @} */ /* End of group __OPORA_Peripheral_Units */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __OPORA_SYS_DEFS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE opora_sys_defs.h */
L 103 ".\inc\opora.h" 2
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define CAN1_BASE			  0x40000000
N#define CAN2_BASE			  0x40008000
N#define USB_BASE			  0x40010000
N#define EEPROM_BASE 		  0x40018000
N#define RST_CLK_BASE		  0x40020000
N#define DMA_BASE			  0x40028000
N#define UART1_BASE			  0x40030000
N#define UART2_BASE			  0x40038000
N#define SPI1_BASE			  0x40040000
N#define MIL_STD_15531_BASE	  0x40048000
N#define MIL_STD_15532_BASE	  0x40050000
N#define POWER_BASE			  0x40058000
N#define WWDG_BASE			  0x40060000
N#define IWDG_BASE			  0x40068000
N#define TIMER1_BASE 		  0x40070000
N#define TIMER2_BASE 		  0x40078000
N#define TIMER3_BASE 		  0x40080000
N#define ADC_BASE			  0x40088000
N#define DAC_BASE			  0x40090000
N#define TIMER4_BASE 		  0x40098000
N#define SPI2_BASE			  0x400A0000
N#define PORTA_BASE			  0x400A8000
N#define PORTB_BASE			  0x400B0000
N#define PORTC_BASE			  0x400B8000
N#define PORTD_BASE			  0x400C0000
N#define PORTE_BASE			  0x400C8000
N#define ARINC429R_BASE		  0x400D0000
N#define BKP_BASE			  0x400D8000
N#define ARINC429T_BASE		  0x400E0000
N#define PORTF_BASE			  0x400E8000
N#define EXT_BUS_CNTRL_BASE	  0x400F0000
N#define SPI3_BASE			  0x400F8000
N#define ETHERNET_BASE		  0x30000000
N#define SYS_BASE			  0xE000E000
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define CAN1				  ((CAN_TypeDef 		  *)CAN1_BASE		  )
N#define CAN2				  ((CAN_TypeDef 		  *)CAN2_BASE		  )
N#define USB 				  ((USB_TypeDef 		  *)USB_BASE		  )
N#define EEPROM				  ((EEPROM_TypeDef		  *)EEPROM_BASE 	  )
N#define RST_CLK 			  ((RST_CLK_TypeDef 	  *)RST_CLK_BASE	  )
N#define DMA 				  ((DMA_TypeDef 		  *)DMA_BASE		  )
N#define UART1				  ((UART_TypeDef		  *)UART1_BASE		  )
N#define UART2				  ((UART_TypeDef		  *)UART2_BASE		  )
N#define SPI1				  ((SPI_TypeDef 		  *)SPI1_BASE		  )
N#define MIL_STD_15531		  ((MIL_STD_1553_TypeDef  *)MIL_STD_15531_BASE)
N#define MIL_STD_15532		  ((MIL_STD_1553_TypeDef  *)MIL_STD_15532_BASE)
N#define POWER				  ((POWER_TypeDef		  *)POWER_BASE		  )
N#define WWDG				  ((WWDG_TypeDef		  *)WWDG_BASE		  )
N#define IWDG				  ((IWDG_TypeDef		  *)IWDG_BASE		  )
N#define TIMER1				  ((TIMER_TypeDef		  *)TIMER1_BASE 	  )
N#define TIMER2				  ((TIMER_TypeDef		  *)TIMER2_BASE 	  )
N#define TIMER3				  ((TIMER_TypeDef		  *)TIMER3_BASE 	  )
N#define ADC 				  ((ADC_TypeDef 		  *)ADC_BASE		  )
N#define DAC 				  ((DAC_TypeDef 		  *)DAC_BASE		  )
N#define TIMER4				  ((TIMER_TypeDef		  *)TIMER4_BASE 	  )
N#define SPI2				  ((SPI_TypeDef 		  *)SPI2_BASE		  )
N#define PORTA				  ((PORT_TypeDef		  *)PORTA_BASE		  )
N#define PORTB				  ((PORT_TypeDef		  *)PORTB_BASE		  )
N#define PORTC				  ((PORT_TypeDef		  *)PORTC_BASE		  )
N#define PORTD				  ((PORT_TypeDef		  *)PORTD_BASE		  )
N#define PORTE				  ((PORT_TypeDef		  *)PORTE_BASE		  )
N#define ARINC429R			  ((ARINC429R_TypeDef	  *)ARINC429R_BASE	  )
N#define BKP 				  ((BKP_TypeDef 		  *)BKP_BASE		  )
N#define ARINC429T			  ((ARINC429T_TypeDef	  *)ARINC429T_BASE	  )
N#define PORTF				  ((PORT_TypeDef		  *)PORTF_BASE		  )
N#define EXT_BUS_CNTRL		  ((EXT_BUS_CNTRL_TypeDef *)EXT_BUS_CNTRL_BASE)
N#define SPI3				  ((SPI_TypeDef 		  *)SPI3_BASE		  )
N#define ETHERNET			  ((ETHERNET_TypeDef	  *)ETHERNET_BASE	  )
N#define SYS 				  ((SYS_TypeDef 		  *)SYS_BASE		  )
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N
N#endif /* __OPORA_H */
N
N/*
N* END OF FILE OPORA.h */
L 26 "src\1986BE9x_usb_device.c" 2
N#include "opora_rst_clk.h"
L 1 ".\inc\opora_rst_clk.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_rst_clk.h
N  * @author  Phyton Application Team and Milandr Application Team
N  * @version V1.0.0
N  * @date    16/06/2010
N  * @brief   This file contains all the functions prototypes for the RST_CLK
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON AND MILANDR SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_rst_clk.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_RST_CLK_H
N#define __OPORA_RST_CLK_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "opora.h"
N#include "1986BE9x_lib.h"
L 1 ".\inc\1986BE9x_lib.h" 1
N/**
N  ******************************************************************************
N  * @file    1986BE9x_lib.h
N  * @author  Phyton Application Team
N  * @version V1.0.1
N  * @date    23/03/2011
N  * @brief   This file contains all file IDs of the Milandr 1986BE9x
N  *          firmware library source files.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE 1986BE9x_lib.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9X_LIB_H
N#define __1986BE9X_LIB_H
N
N#define  FILEID__1986BE9X_CAN_C               1
N#define  FILEID__1986BE9X_USB_C               2
N#define  FILEID__1986BE9X_EEPROM_C            3
N#define  FILEID__1986BE9X_RST_CLK_C           4
N#define  FILEID__1986BE9X_DMA_C               5
N#define  FILEID__1986BE9X_UART_C              6
N#define  FILEID__1986BE9X_SSP_C               7
N#define  FILEID__1986BE9X_I2C_C               8
N#define  FILEID__1986BE9X_POWER_C             9
N#define  FILEID__1986BE9X_WWDG_C             10
N#define  FILEID__1986BE9X_IWDG_C             11
N#define  FILEID__1986BE9X_TIMER_C            12
N#define  FILEID__1986BE9X_ADC_C              13
N#define  FILEID__1986BE9X_DAC_C              14
N#define  FILEID__1986BE9X_COMP_C             15
N#define  FILEID__1986BE9X_PORT_C             16
N#define  FILEID__1986BE9X_BKP_C              17
N#define  FILEID__1986BE9X_EXT_BUS_C          18
N#define  FILEID__1986BE9X_USB_DEVICE_C       19
N#define  FILEID__1986BE9X_USB_CDC_C          20
N
N#define  FILEID__USER_LO                    100
N
N/* Supported USB Device Classes */
N#define USB_DEVICE_CLASS_CDC 2
N
N#endif /* __1986BE9X_LIB_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE 1986BE9x_lib.h */
N
L 31 ".\inc\opora_rst_clk.h" 2
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup RST_CLK
N  * @{
N  */
N
N/** @defgroup RST_CLK_Exported_Types RST_CLK Exported Types
N  * @{
N  */
N
N/**
N  * @brief Structure type for modules clocks frequencies expressed in Hz
N  */
N
Ntypedef struct
N{
N  uint32_t CPU_CLK_Frequency;
N  uint32_t USB_CLK_Frequency;
N  uint32_t ADC_CLK_Frequency;
N  uint32_t RTCHSI_Frequency;
N  uint32_t RTCHSE_Frequency;
N}RST_CLK_FreqTypeDef;
N
N/**
N  * @brief RST_CLK unit non-volatile settings init structure
N  */
N
Ntypedef struct {
N     uint32_t REG_0F;
N} Init_NonVolatile_RST_CLK_TypeDef;
N
N/** @} */ /* End of group RST_CLK_Exported_Types */
N
N/** @defgroup RST_CLK_Exported_Constants RST_CLK Exported Constants
N  * @{
N  */
N
N/** @defgroup HSE_configuration HSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE (High Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_HSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_HSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_HSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) || \
N                                              ((HSE) == RST_CLK_HSE_ON)  || \
N                                              ((HSE) == RST_CLK_HSE_Bypass))
X#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) ||                                               ((HSE) == RST_CLK_HSE_ON)  ||                                               ((HSE) == RST_CLK_HSE_Bypass))
N
N/** @} */ /* End of group HSE_configuration */
N
N/** @defgroup LSE_configuration LSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK LSE (Low Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_LSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_LSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_LSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) || \
N                                              ((LSE) == RST_CLK_LSE_ON)  || \
N                                              ((LSE) == RST_CLK_LSE_Bypass))
X#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) ||                                               ((LSE) == RST_CLK_LSE_ON)  ||                                               ((LSE) == RST_CLK_LSE_Bypass))
N
N/** @} */ /* End of group LSE_configuration */
N
N/** @defgroup CPU_PLL_entry_clock_source CPU PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_CPU_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
X#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group CPU_PLL_entry_clock_source */
N
N/** @defgroup CPU_PLL_clock_multiplier CPU_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK PLL_CPU_MUL multiplier of the CPU_C1 clock constants
N  */
N
N#define RST_CLK_CPU_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_CPU_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_CPU_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_CPU_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_CPU_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_CPU_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_CPU_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_CPU_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPU_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_CPU_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_CPU_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_CPU_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_CPU_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPU_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group CPU_PLL_clock_multiplier */
N
N
N/** @defgroup USB_PLL_entry_clock_source USB PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_USB_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
X#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group USB_PLL_entry_clock_source */
N
N/** @defgroup USB_PLL_clock_multiplier USB_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_C1 clock PLL_USB_MUL multiplier constants
N  */
N
N#define RST_CLK_USB_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_USB_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_USB_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_USB_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_USB_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_USB_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_USB_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_USB_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_USB_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_USB_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_USB_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_USB_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_USB_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_USB_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group USB_PLL_clock_multiplier */
N
N
N/** @defgroup CPU_CLK_divider CPU CLK divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL output clock CPU_CLK_DIV divider constants
N  */
N
N#define RST_CLK_CPUclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkDIV2                    ((uint32_t)0x00000080)
N#define RST_CLK_CPUclkDIV4                    ((uint32_t)0x00000090)
N#define RST_CLK_CPUclkDIV8                    ((uint32_t)0x000000A0)
N#define RST_CLK_CPUclkDIV16                   ((uint32_t)0x000000B0)
N#define RST_CLK_CPUclkDIV32                   ((uint32_t)0x000000C0)
N#define RST_CLK_CPUclkDIV64                   ((uint32_t)0x000000D0)
N#define RST_CLK_CPUclkDIV128                  ((uint32_t)0x000000E0)
N#define RST_CLK_CPUclkDIV256                  ((uint32_t)0x000000F0)
N
N#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV2)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV4)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV8)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV16)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV32)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV64)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV128) || \
N                                               ((DIV) == RST_CLK_CPUclkDIV256))
X#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   ||                                                ((DIV) == RST_CLK_CPUclkDIV2)   ||                                                ((DIV) == RST_CLK_CPUclkDIV4)   ||                                                ((DIV) == RST_CLK_CPUclkDIV8)   ||                                                ((DIV) == RST_CLK_CPUclkDIV16)  ||                                                ((DIV) == RST_CLK_CPUclkDIV32)  ||                                                ((DIV) == RST_CLK_CPUclkDIV64)  ||                                                ((DIV) == RST_CLK_CPUclkDIV128) ||                                                ((DIV) == RST_CLK_CPUclkDIV256))
N
N/** @} */ /* End of group CPU_CLK_divider */
N
N/** @defgroup CPU_CLK_selector CPU CLK selector
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_CLK source CPU_CLK selector constants
N  */
N
N#define RST_CLK_CPUclkHSI                     ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkCPU_C3                  ((uint32_t)0x00000100)
N#define RST_CLK_CPUclkLSE                     ((uint32_t)0x00000200)
N#define RST_CLK_CPUclkLSI                     ((uint32_t)0x00000300)
N
N#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    || \
N                                               ((SRC) == RST_CLK_CPUclkCPU_C3) || \
N                                               ((SRC) == RST_CLK_CPUclkLSE)    || \
N                                               ((SRC) == RST_CLK_CPUclkLSI))
X#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    ||                                                ((SRC) == RST_CLK_CPUclkCPU_C3) ||                                                ((SRC) == RST_CLK_CPUclkLSE)    ||                                                ((SRC) == RST_CLK_CPUclkLSI))
N
N/** @} */ /* End of group CPU_CLK_selector */
N
N/** @defgroup ADC_MCO_CLOCK_source ADC clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CLK selector constants
N  */
N#define RST_CLK_ADCclkCPU_C1                  ((uint32_t)0x00000020)
N#define RST_CLK_ADCclkUSB_C1                  ((uint32_t)0x00000021)
N#define RST_CLK_ADCclkCPU_C2                  ((uint32_t)0x00000022)
N#define RST_CLK_ADCclkUSB_C2                  ((uint32_t)0x00000023)
N#define RST_CLK_ADCclkLSE                     ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkLSI                     ((uint32_t)0x00000010)
N#define RST_CLK_ADCclkHSI_C1                  ((uint32_t)0x00000030)
N
N#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkCPU_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkLSE)    || \
N                                               ((SRC) == RST_CLK_ADCclkLSI)    || \
N                                               ((SRC) == RST_CLK_ADCclkHSI_C1))
X#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C1) ||                                                ((SRC) == RST_CLK_ADCclkCPU_C2) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C2) ||                                                ((SRC) == RST_CLK_ADCclkLSE)    ||                                                ((SRC) == RST_CLK_ADCclkLSI)    ||                                                ((SRC) == RST_CLK_ADCclkHSI_C1))
N/** @} */ /* End of group ADC_MCO_CLOCK_source */
N
N/** @defgroup ADC_MCO_CS3_SEL ADC clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CS2_SEL output clock ADC_CS3_SEL divider constants
N  */
N
N#define RST_CLK_ADCclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkDIV2                    ((uint32_t)0x00000001)
N#define RST_CLK_ADCclkDIV3                    ((uint32_t)0x00000002)
N#define RST_CLK_ADCclkDIV4                    ((uint32_t)0x00000003)
N#define RST_CLK_ADCclkDIV5                    ((uint32_t)0x00000004)
N#define RST_CLK_ADCclkDIV6                    ((uint32_t)0x00000005)
N#define RST_CLK_ADCclkDIV7                    ((uint32_t)0x00000006)
N#define RST_CLK_ADCclkDIV8                    ((uint32_t)0x00000007)
N#define RST_CLK_ADCclkDIV9                    ((uint32_t)0x00000008)
N#define RST_CLK_ADCclkDIV10                   ((uint32_t)0x00000009)
N#define RST_CLK_ADCclkDIV11                   ((uint32_t)0x0000000A)
N#define RST_CLK_ADCclkDIV12                   ((uint32_t)0x0000000B)
N#define RST_CLK_ADCclkDIV13                   ((uint32_t)0x0000000C)
N#define RST_CLK_ADCclkDIV14                   ((uint32_t)0x0000000D)
N#define RST_CLK_ADCclkDIV15                   ((uint32_t)0x0000000E)
N#define RST_CLK_ADCclkDIV16                   ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_ADCclkDivValue(SRC)        ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group ADC_MCO_CS3_SEL */
N
N
N/** @defgroup CLK_peripheral CLK peripheral
N  * @{
N  */
N
N/**
N  * @brief RST_CLK peripheral modules clock constants
N  */
N
N#define PCLK_BIT(BASE)              ((uint32_t)(1 << ((((uint32_t)BASE) >> 15) & 0x1F)))
N
N#define RST_CLK_PCLK_CAN1           PCLK_BIT(CAN1_BASE)
N#define RST_CLK_PCLK_CAN2           PCLK_BIT(CAN2_BASE)
N#define RST_CLK_PCLK_USB            PCLK_BIT(USB_BASE)
N#define RST_CLK_PCLK_EEPROM         PCLK_BIT(EEPROM_BASE)
N#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(RST_CLK_BASE)
N#define RST_CLK_PCLK_DMA            PCLK_BIT(DMA_BASE)
N#define RST_CLK_PCLK_UART1          PCLK_BIT(UART1_BASE)
N#define RST_CLK_PCLK_UART2          PCLK_BIT(UART2_BASE)
N#define RST_CLK_PCLK_SPI1           PCLK_BIT(SPI1_BASE)
N#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MIL_STD_15531_BASE)
N#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MIL_STD_15532_BASE)
N#define RST_CLK_PCLK_POWER          PCLK_BIT(POWER_BASE)
N#define RST_CLK_PCLK_WWDG           PCLK_BIT(WWDG_BASE)
N#define RST_CLK_PCLK_IWDG           PCLK_BIT(IWDG_BASE)
N#define RST_CLK_PCLK_TIMER1         PCLK_BIT(TIMER1_BASE)
N#define RST_CLK_PCLK_TIMER2         PCLK_BIT(TIMER2_BASE)
N#define RST_CLK_PCLK_TIMER3         PCLK_BIT(TIMER3_BASE)
N#define RST_CLK_PCLK_ADC            PCLK_BIT(ADC_BASE)
N#define RST_CLK_PCLK_DAC            PCLK_BIT(DAC_BASE)
N#define RST_CLK_PCLK_TIMER4         PCLK_BIT(TIMER4_BASE)
N#define RST_CLK_PCLK_SPI2           PCLK_BIT(SPI2_BASE)
N#define RST_CLK_PCLK_PORTA          PCLK_BIT(PORTA_BASE)
N#define RST_CLK_PCLK_PORTB          PCLK_BIT(PORTB_BASE)
N#define RST_CLK_PCLK_PORTC          PCLK_BIT(PORTC_BASE)
N#define RST_CLK_PCLK_PORTD          PCLK_BIT(PORTD_BASE)
N#define RST_CLK_PCLK_PORTE          PCLK_BIT(PORTE_BASE)
N#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(ARINC429R_BASE)
N#define RST_CLK_PCLK_BKP            PCLK_BIT(BKP_BASE)
N#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(ARINC429T_BASE)
N#define RST_CLK_PCLK_PORTF          PCLK_BIT(PORTF_BASE)
N#define RST_CLK_PCLK_EXT_BUS_CNTRL  PCLK_BIT(EXT_BUS_BASE)
N#define RST_CLK_PCLK_SPI3           PCLK_BIT(SPI3_BASE)
N
N#define IS_RST_CLK_PCLK(PCLK)       (((PCLK)>=0) && ((PCLK)<32))
N
N/** @} */ /* End of group CLK_peripheral */
N
N/** @defgroup RST_CLK_Flag RST_CLK Flag
N  * @{
N  */
N
N/**
N  * @brief RST_CLK flag identifiers
N  */
N
N#define RST_CLK_FLAG_HSIRDY                   ((uint32_t)(0x00 | 23))
N#define RST_CLK_FLAG_LSIRDY                   ((uint32_t)(0x00 | 21))
N#define RST_CLK_FLAG_LSERDY                   ((uint32_t)(0x00 | 13))
N
N#define RST_CLK_FLAG_HSERDY                   ((uint32_t)(0x20 |  2))
N#define RST_CLK_FLAG_PLLCPURDY                ((uint32_t)(0x20 |  1))
N#define RST_CLK_FLAG_PLLUSBRDY                ((uint32_t)(0x20 |  0))
N
N#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_LSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_LSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLCPURDY) || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
X#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_LSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_LSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_PLLCPURDY) ||                                                ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
N
N/** @} */ /* End of group RST_CLK_Flag */
N
N#define IS_RCC_CLK_HSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x3F)
N#define IS_RCC_CLK_LSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x1F)
N
N/** @defgroup RST_CLK_HSI_C1_SEL HSI clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSI clock HSI_C1_SEL divider constants
N  */
N
N#define RST_CLK_HSIclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSIclkDIV2                    ((uint32_t)0x00000001)
N#define RST_CLK_HSIclkDIV3                    ((uint32_t)0x00000002)
N#define RST_CLK_HSIclkDIV4                    ((uint32_t)0x00000003)
N#define RST_CLK_HSIclkDIV5                    ((uint32_t)0x00000004)
N#define RST_CLK_HSIclkDIV6                    ((uint32_t)0x00000005)
N#define RST_CLK_HSIclkDIV7                    ((uint32_t)0x00000006)
N#define RST_CLK_HSIclkDIV8                    ((uint32_t)0x00000007)
N#define RST_CLK_HSIclkDIV9                    ((uint32_t)0x00000008)
N#define RST_CLK_HSIclkDIV10                   ((uint32_t)0x00000009)
N#define RST_CLK_HSIclkDIV11                   ((uint32_t)0x0000000A)
N#define RST_CLK_HSIclkDIV12                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSIclkDIV13                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSIclkDIV14                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSIclkDIV15                   ((uint32_t)0x0000000E)
N#define RST_CLK_HSIclkDIV16                   ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSIclkDivValue(SRC)        ((SRC >= 0) && (SRC < 16))
N
N/** @} */ /* End of group RST_CLK_HSI_C1_SEL */
N
N/** @defgroup RST_CLK_HSE_C1_SEL HSE clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE clock HSE_C1_SEL divider constants for RTC_CLOCK
N  */
N
N#define RST_CLK_HSEclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSEclkDIV2                    ((uint32_t)0x00000001)
N#define RST_CLK_HSEclkDIV3                    ((uint32_t)0x00000002)
N#define RST_CLK_HSEclkDIV4                    ((uint32_t)0x00000003)
N#define RST_CLK_HSEclkDIV5                    ((uint32_t)0x00000004)
N#define RST_CLK_HSEclkDIV6                    ((uint32_t)0x00000005)
N#define RST_CLK_HSEclkDIV7                    ((uint32_t)0x00000006)
N#define RST_CLK_HSEclkDIV8                    ((uint32_t)0x00000007)
N#define RST_CLK_HSEclkDIV9                    ((uint32_t)0x00000008)
N#define RST_CLK_HSEclkDIV10                   ((uint32_t)0x00000009)
N#define RST_CLK_HSEclkDIV11                   ((uint32_t)0x0000000A)
N#define RST_CLK_HSEclkDIV12                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSEclkDIV13                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSEclkDIV14                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSEclkDIV15                   ((uint32_t)0x0000000E)
N#define RST_CLK_HSEclkDIV16                   ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSEclkDivValue(SRC)        ((SRC >= 0) && (SRC < 16))
N
N/** @} */ /* End of group RST_CLK_HSE_C1_SEL */
N
N/** @} */ /* End of group RST_CLK_Exported_Constants */
N
N/** @defgroup RST_CLK_Exported_Macros RST_CLK Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group RST_CLK_Exported_Macros */
N
N/** @defgroup RST_CLK_Exported_Functions RST_CLK Exported Functions
N  * @{
N  */
N
Nvoid RST_CLK_DeInit(void);
Nvoid RST_CLK_WarmDeInit(void);
N
Nvoid RST_CLK_HSEconfig(uint32_t RST_CLK_HSE);
NErrorStatus RST_CLK_HSEstatus(void);
N
Nvoid RST_CLK_LSEconfig(uint32_t RST_CLK_LSE);
NErrorStatus RST_CLK_LSEstatus(void);
N
Nvoid RST_CLK_HSIcmd(FunctionalState NewState);
Nvoid RST_CLK_HSIadjust(uint8_t HSItrimValue);
NErrorStatus RST_CLK_HSIstatus(void);
N
Nvoid RST_CLK_LSIcmd(FunctionalState NewState);
NErrorStatus RST_CLK_LSIstatus(void);
N
Nvoid RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul);
Nvoid RST_CLK_CPU_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_CPU_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_CPU_PLLstatus(void);
N
Nvoid RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue);
Nvoid RST_CLK_CPUclkSelection(uint32_t CPU_CLK);
N
Nvoid RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul);
Nvoid RST_CLK_USB_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_USB_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_USB_PLLstatus(void);
N
Nvoid RST_CLK_USBclkPrescaler(FunctionalState NewState);
Nvoid RST_CLK_USBclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_ADCclkSelection(uint32_t ADC_CLK);
Nvoid RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue);
Nvoid RST_CLK_ADCclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue);
Nvoid RST_CLK_RTC_HSIclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue);
Nvoid RST_CLK_RTC_HSEclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState);
N
Nvoid RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks);
N
NFlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG);
N
N/** @} */ /* End of group RST_CLK_Exported_Functions */
N
N/** @} */ /* End of group RST_CLK */
N
N/** @} */ /* End of group __1986BE9x_StdPeriph_Driver */
N
N#endif /* __1986BE9x_RST_CLK_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE 1986BE9x_rst_clk.h */
N
L 27 "src\1986BE9x_usb_device.c" 2
N#include "1986BE9x_usb_handlers.h"
L 1 ".\inc\1986BE9x_usb_handlers.h" 1
N/**
N  ******************************************************************************
N  * @file    1986be9x_usb_handlers.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    18/03/2011
N  * @brief   USB Library user-defined handlers definition file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  * FILE 1986be9x_usb_handlers.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9x_USB_HANDLERS_H
N#define __1986BE9x_USB_HANDLERS_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "1986BE9x_usb_default_handlers.h"
L 1 ".\inc\1986BE9x_usb_default_handlers.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\1986be9x_usb_default_handlers.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    18/03/2011
N  * @brief   USB Library handlers definition file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  * FILE 1986be9x_usb_default_handlers.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9x_USB_DEFAULT_HANDLERS_H
N#define __1986BE9x_USB_DEFAULT_HANDLERS_H
N
N
N/* Includes ------------------------------------------------------------------*/
N#include "1986BE9x_usb_cdc.h"
L 1 ".\inc\1986BE9x_usb_cdc.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\1986BE9x_usb_CDC.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    02/03/2011
N  * @brief   This file contains all the interface types and function prototypes
N  *          of the:
N  *          [1] Communication Device Class driver as of USB Class Definitions
N  *              for Communications Devices Rev.1.2 (Errata 1);
N  *          [2] USB Communication Class Subclass Specification for PSTN
N  *              Devices Rev.1.2.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE 1986BE9x_usb_device.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9x_USB_CDC_H
N#define __1986BE9x_USB_CDC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "opora.h"
N#include "1986BE9x_lib.h"
N#include "1986BE9x_usb_device.h"
L 1 ".\inc\1986BE9x_usb_device.h" 1
N/**
N  ******************************************************************************
N  * @file    USB_Library\1986BE9x_usb_device.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    21/02/2011
N  * @brief   This file contains all the interface types and function prototypes
N  *          of the EndPoint and Device drivers as of USB Specification Rev.2.0
N  *          Chapter 9
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE 1986BE9x_usb_device.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9x_USB_DEVICE_H
N#define __1986BE9x_USB_DEVICE_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "opora.h"
N#include "1986BE9x_lib.h"
N#include "opora_usb.h"
L 1 ".\inc\opora_usb.h" 1
N/**
N  ******************************************************************************
N  * @file    opora_usb.h
N  * @author  Phyton Application Team and Milandr Application Team
N  * @version V1.0.0
N  * @date    26/01/2012
N  * @brief   This file contains all the functions prototypes for the USB
N  *          SFR access layer
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON AND MILANDR SHALL NOT BE HELD LIABLE FOR ANY DIRECT, 
N  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE opora_usb.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __OPORA_USB_H
N#define __OPORA_USB_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "opora.h"
N#include "1986BE9x_lib.h"
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_Exported_Types USB Exported Types
N  * @{
N  */
N
N/**
N  * @brief EndPoints enumeration
N  */
N
Ntypedef enum
N{
N  USB_EP0  = 0,
N  USB_EP1  = 1,
N  USB_EP2  = 2,
N  USB_EP3  = 3,
N  Num_USB_EndPoints
N}USB_EP_TypeDef;
N
N#define IS_USB_ENDPOINT(ENDPOINT)       (((ENDPOINT) >= 0) && ((ENDPOINT) < Num_USB_EndPoints))
N
N/**
N  * @brief USB Clock Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t USB_USBC1_Source;       /*!< Specifies the source for USB_C1, if USB_C2 source is set to USB_C1.
N                                        This parameter is one of @ref USB_USBC1_Select_Source values. */
N  uint32_t USB_PLLUSBMUL;          /*!< Specifies the source for USB_C1, if USB_C2 source is set to USB_PLL.
N                                        This parameter is one of @ref USB_PLLUSB_Select_Source values. */
N}USB_Clock_TypeDef;
N
Ntypedef struct
N{
N  uint8_t USB_Version;               /*!< USB Version. */
N  uint8_t USB_Revision;              /*!< USB Revision. */
N}USB_Version_TypeDef;
N
N/** @} */ /* End of group USB_Exported_Types */
N
N/** @defgroup USB_USBC2_Source USB USBC2 Source
N  * @{
N  */
N
N#define USB_PLL                         ((uint32_t)0x00000004)
N
N/** @} */ /* End of group USB_USBC2_Source */
N
N/** @defgroup USB_USBC1_Source USB USBC1 Source
N  * @{
N  */
N
N#define USB_C1HSIdiv1                  ((uint32_t)0x00000000)
N#define USB_C1HSIdiv2                  ((uint32_t)0x00000001)
N#define USB_C1HSEdiv1                  ((uint32_t)0x00000002)
N#define USB_C1HSEdiv2                  ((uint32_t)0x00000003)
N
N#define IS_USBC1_CLOCK_BRG(CLOCK)      (((CLOCK) >= 0) && ((CLOCK) <= 3))
N
N/** @} */ /* End of group USB_USBC1_Source */
N
N/** @defgroup USB_PLLUSB_Source USB PLLUSB Source
N  * @{
N  */
N
N#define USB_PLLUSBMUL1                 ((uint32_t)0x00000000)
N#define USB_PLLUSBMUL2                 ((uint32_t)0x00000001)
N#define USB_PLLUSBMUL3                 ((uint32_t)0x00000002)
N#define USB_PLLUSBMUL4                 ((uint32_t)0x00000003)
N#define USB_PLLUSBMUL5                 ((uint32_t)0x00000004)
N#define USB_PLLUSBMUL6                 ((uint32_t)0x00000005)
N#define USB_PLLUSBMUL7                 ((uint32_t)0x00000006)
N#define USB_PLLUSBMUL8                 ((uint32_t)0x00000007)
N#define USB_PLLUSBMUL9                 ((uint32_t)0x00000008)
N#define USB_PLLUSBMUL10                ((uint32_t)0x00000009)
N#define USB_PLLUSBMUL11                ((uint32_t)0x0000000A)
N#define USB_PLLUSBMUL12                ((uint32_t)0x0000000B)
N#define USB_PLLUSBMUL13                ((uint32_t)0x0000000C)
N#define USB_PLLUSBMUL14                ((uint32_t)0x0000000D)
N#define USB_PLLUSBMUL15                ((uint32_t)0x0000000E)
N#define USB_PLLUSBMUL16                ((uint32_t)0x0000000F)
N
N#define IS_PLLUSBMUL(MUL)              (((MUL) >= 0) && ((MUL) < 16))
N
N#define USB_CLOCK_48MHz                ((uint32_t)48000000)
N#define IS_USB_CLOCK(MUL,USBC1)        (((USBC1 == USB_C1HSIdiv1) && (((MUL + 1)* HSI_Value) == USB_CLOCK_48MHz))       || \
N                                        ((USBC1 == USB_C1HSIdiv2) && (((MUL + 1)* (HSI_Value / 2)) == USB_CLOCK_48MHz)) || \
N                                        ((USBC1 == USB_C1HSEdiv1) && (((MUL + 1)* HSE_Value) == USB_CLOCK_48MHz))       || \
N                                        ((USBC1 == USB_C1HSEdiv2) && (((MUL + 1)* (HSE_Value / 2)) == USB_CLOCK_48MHz)))
X#define IS_USB_CLOCK(MUL,USBC1)        (((USBC1 == USB_C1HSIdiv1) && (((MUL + 1)* HSI_Value) == USB_CLOCK_48MHz))       ||                                         ((USBC1 == USB_C1HSIdiv2) && (((MUL + 1)* (HSI_Value / 2)) == USB_CLOCK_48MHz)) ||                                         ((USBC1 == USB_C1HSEdiv1) && (((MUL + 1)* HSE_Value) == USB_CLOCK_48MHz))       ||                                         ((USBC1 == USB_C1HSEdiv2) && (((MUL + 1)* (HSE_Value / 2)) == USB_CLOCK_48MHz)))
N
N/** @} */ /* End of group USB_PLLUSB_Source */
N
N/** @defgroup USB_HOST_REGS_Values USB_HOST Register Values
N  * @{
N  */
N
N/** @defgroup USB_HSCR_Values USB_HSCR Values
N  * @{
N  */
N
N#define USB_HSCR_HOST_MODE_Host              (uint32_t)(1 << USB_HSCR_HOST_MODE_OFFS)
N#define USB_HSCR_HOST_MODE_Device            (uint32_t)(1 << (USB_HSCR_HOST_MODE_OFFS + 16))
N
N#define USB_HSCR_RESET_CORE_Reset            (uint32_t)(1 << USB_HSCR_RESET_CORE_OFFS)
N#define USB_HSCR_RESET_CORE_Work             (uint32_t)(1 << (USB_HSCR_RESET_CORE_OFFS + 16))
N
N#define USB_HSCR_EN_TX_Set                   (uint32_t)(1 << USB_HSCR_EN_TX_OFFS)
N#define USB_HSCR_EN_TX_Reset                 (uint32_t)(1 << (USB_HSCR_EN_TX_OFFS + 16))
N
N#define USB_HSCR_EN_RX_Set                   (uint32_t)(1 << USB_HSCR_EN_RX_OFFS)
N#define USB_HSCR_EN_RX_Reset                 (uint32_t)(1 << (USB_HSCR_EN_RX_OFFS + 16))
N
N#define USB_HSCR_DP_PULLUP_Set               (uint32_t)(1 << USB_HSCR_DP_PULLUP_OFFS)
N#define USB_HSCR_DP_PULLUP_Reset             (uint32_t)(1 << (USB_HSCR_DP_PULLUP_OFFS + 16))
N
N#define USB_HSCR_DP_PULLDOWN_Set             (uint32_t)(1 << USB_HSCR_DP_PULLDOWN_OFFS)
N#define USB_HSCR_DP_PULLDOWN_Reset           (uint32_t)(1 << (USB_HSCR_DP_PULLDOWN_OFFS + 16))
N
N#define USB_HSCR_DM_PULLUP_Set               (uint32_t)(1 << USB_HSCR_DM_PULLUP_OFFS)
N#define USB_HSCR_DM_PULLUP_Reset             (uint32_t)(1 << (USB_HSCR_DM_PULLUP_OFFS + 16))
N
N#define USB_HSCR_DM_PULLDOWN_Set             (uint32_t)(1 << USB_HSCR_DM_PULLDOWN_OFFS)
N#define USB_HSCR_DM_PULLDOWN_Reset           (uint32_t)(1 << (USB_HSCR_DM_PULLDOWN_OFFS + 16))
N
N#define USB_HSCR_SET_MASK                    (USB_HSCR_HOST_MODE_Host   | \
N                                              USB_HSCR_RESET_CORE_Reset | \
N                                              USB_HSCR_EN_TX_Set        | \
N                                              USB_HSCR_EN_RX_Set        | \
N                                              USB_HSCR_DP_PULLUP_Set    | \
N                                              USB_HSCR_DP_PULLDOWN_Set  | \
N                                              USB_HSCR_DM_PULLUP_Set    | \
N                                              USB_HSCR_DM_PULLDOWN_Set)
X#define USB_HSCR_SET_MASK                    (USB_HSCR_HOST_MODE_Host   |                                               USB_HSCR_RESET_CORE_Reset |                                               USB_HSCR_EN_TX_Set        |                                               USB_HSCR_EN_RX_Set        |                                               USB_HSCR_DP_PULLUP_Set    |                                               USB_HSCR_DP_PULLDOWN_Set  |                                               USB_HSCR_DM_PULLUP_Set    |                                               USB_HSCR_DM_PULLDOWN_Set)
N
N#define USB_HSCR_RESET_MASK                  (USB_HSCR_SET_MASK << 16)
N
N#define IS_USB_HSCR_VALUE(VALUE)             ((((VALUE) & (~(USB_HSCR_SET_MASK | USB_HSCR_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HSCR_VALUE(VALUE)             ((((VALUE) & (~(USB_HSCR_SET_MASK | USB_HSCR_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N/** @} */ /* End of group USB_HSCR_Values */
N
N/** @defgroup USB_HTXC_Values USB_HTXC Values
N  * @{
N  */
N
N#define USB_HTXC_TREQ_Set                    (uint32_t)(1 << USB_HTXC_TREQ_OFFS)
N#define USB_HTXC_TREQ_Reset                  (uint32_t)(1 << (USB_HTXC_TREQ_OFFS + 16))
N
N#define USB_HTXC_SOFS_Set                    (uint32_t)(1 << USB_HTXC_SOFS_OFFS)
N#define USB_HTXC_SOFS_Reset                  (uint32_t)(1 << (USB_HTXC_SOFS_OFFS + 16))
N
N#define USB_HTXC_PREEN_Set                   (uint32_t)(1 << USB_HTXC_PREEN_OFFS)
N#define USB_HTXC_PREEN_Reset                 (uint32_t)(1 << (USB_HTXC_PREEN_OFFS + 16))
N
N#define USB_HTXC_ISOEN_Set                   (uint32_t)(1 << USB_HTXC_ISOEN_OFFS)
N#define USB_HTXC_ISOEN_Reset                 (uint32_t)(1 << (USB_HTXC_ISOEN_OFFS + 16))
N
N#define USB_HTXC_SET_MASK                    (USB_HTXC_TREQ_Set  | \
N                                              USB_HTXC_SOFS_Set  | \
N                                              USB_HTXC_PREEN_Set | \
N                                              USB_HTXC_ISOEN_Set)
X#define USB_HTXC_SET_MASK                    (USB_HTXC_TREQ_Set  |                                               USB_HTXC_SOFS_Set  |                                               USB_HTXC_PREEN_Set |                                               USB_HTXC_ISOEN_Set)
N
N#define USB_HTXC_RESET_MASK                  (USB_HTXC_SET_MASK << 16)
N
N#define IS_USB_HTXC_VALUE(VALUE)             ((((VALUE) & (~(USB_HTXC_SET_MASK | USB_HTXC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXC_VALUE(VALUE)             ((((VALUE) & (~(USB_HTXC_SET_MASK | USB_HTXC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXC_Values */
N
N/** @defgroup USB_HTXT_Values USB_HTXT Values
N  * @{
N  */
N
N#define USB_HTXT_TTYPE_Setup                 (uint32_t)(0x00000000)
N#define USB_HTXT_TTYPE_In                    (uint32_t)(0x00000001)
N#define USB_HTXT_TTYPE_Outdata0              (uint32_t)(0x00000002)
N#define USB_HTXT_TTYPE_Outdata1              (uint32_t)(0x00000003)
N
N#define IS_USB_HTXT_VALUE(VALUE)             (((VALUE) == USB_HTXT_TTYPE_Setup)    || \
N                                              ((VALUE) == USB_HTXT_TTYPE_In)       || \
N                                              ((VALUE) == USB_HTXT_TTYPE_Outdata0) || \
N                                              ((VALUE) == USB_HTXT_TTYPE_Outdata1))
X#define IS_USB_HTXT_VALUE(VALUE)             (((VALUE) == USB_HTXT_TTYPE_Setup)    ||                                               ((VALUE) == USB_HTXT_TTYPE_In)       ||                                               ((VALUE) == USB_HTXT_TTYPE_Outdata0) ||                                               ((VALUE) == USB_HTXT_TTYPE_Outdata1))
N
N/** @} */ /* End of group USB_HTXT_Values */
N
N/** @defgroup USB_HTXLC_Values USB_HTXLC Values
N  * @{
N  */
N
N#define USB_HTXLC_TXLC_DM_Set                (uint32_t)(1 << USB_HTXLC_OFFS)
N#define USB_HTXLC_TXLC_DM_Reset              (uint32_t)(1 << (USB_HTXLC_OFFS + 16))
N
N#define USB_HTXLC_TXLC_DP_Set                (uint32_t)(1 << (USB_HTXLC_OFFS + 1))
N#define USB_HTXLC_TXLC_DP_Reset              (uint32_t)(1 << (USB_HTXLC_OFFS + 16 + 1))
N
N#define USB_HTXLC_DC_Direct                  (uint32_t)(1 << USB_HTXLC_DC_OFFS)
N#define USB_HTXLC_DC_Normal                  (uint32_t)(1 << (USB_HTXLC_DC_OFFS + 16))
N
N#define USB_HTXLC_FSPL_Full                  (uint32_t)(1 << USB_HTXLC_FSPL_OFFS)
N#define USB_HTXLC_FSPL_Low                   (uint32_t)(1 << (USB_HTXLC_FSPL_OFFS + 16))
N
N#define USB_HTXLC_FSLR_12Mb                  (uint32_t)(1 << USB_HTXLC_FSLR_OFFS)
N#define USB_HTXLC_FSPL_1_5Mb                 (uint32_t)(1 << (USB_HTXLC_FSLR_OFFS + 16))
N
N#define USB_HTXLC_SET_MASK                   (USB_HTXLC_TXLC_DM_Set  | \
N                                              USB_HTXLC_TXLC_DP_Set  | \
N                                              USB_HTXLC_DC_Direct | \
N                                              USB_HTXLC_FSPL_Full | \
N                                              USB_HTXLC_FSLR_12Mb)
X#define USB_HTXLC_SET_MASK                   (USB_HTXLC_TXLC_DM_Set  |                                               USB_HTXLC_TXLC_DP_Set  |                                               USB_HTXLC_DC_Direct |                                               USB_HTXLC_FSPL_Full |                                               USB_HTXLC_FSLR_12Mb)
N
N#define USB_HTXLC_RESET_MASK                 (USB_HTXLC_SET_MASK << 16)
N
N#define IS_USB_HTXLC_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXLC_SET_MASK | USB_HTXLC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXLC_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXLC_SET_MASK | USB_HTXLC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXLC_Values */
N
N/** @defgroup USB_HTXSE_Values USB_HTXSE Values
N  * @{
N  */
N
N#define USB_HTXSE_SOFEN_Auto                 (uint32_t)(0x00000001)
N#define USB_HTXSE_SOFEN_NonAuto              (uint32_t)(0x00000001 << 16)
N
N#define IS_USB_HTXSE_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXSE_SOFEN_Auto | USB_HTXSE_SOFEN_NonAuto))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HTXSE_VALUE(VALUE)            ((((VALUE) & (~(USB_HTXSE_SOFEN_Auto | USB_HTXSE_SOFEN_NonAuto))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HTXSE_Values */
N
N/** @defgroup USB_HIS_Values USB_HIS Values
N  * @{
N  */
N
N#define USB_HIS_TDONE_Set                    USB_HIS_TDONE
N
N#define USB_HIS_RESUME_Set                   USB_HIS_RESUME
N
N#define USB_HIS_CONEV_Set                    USB_HIS_CONEV
N
N#define USB_HIS_SOFS_Set                     USB_HIS_SOFS
N
N#define IS_USB_HIS_VALUE(VALUE)              (((VALUE) == USB_HIS_TDONE_Set)  || \
N                                              ((VALUE) == USB_HIS_RESUME_Set) || \
N                                              ((VALUE) == USB_HIS_CONEV_Set)  || \
N                                              ((VALUE) == USB_HIS_SOFS_Set))
X#define IS_USB_HIS_VALUE(VALUE)              (((VALUE) == USB_HIS_TDONE_Set)  ||                                               ((VALUE) == USB_HIS_RESUME_Set) ||                                               ((VALUE) == USB_HIS_CONEV_Set)  ||                                               ((VALUE) == USB_HIS_SOFS_Set))
N
N/** @} */ /* End of group USB_HIS_Values */
N
N/** @defgroup USB_HIM_Values USB_HIM Values
N  * @{
N  */
N
N#define USB_HIM_TDONEIE_Set                  (uint32_t)(1 << USB_HIM_TDONEIE_OFFS)
N#define USB_HIM_TDONEIE_Reset                (uint32_t)(1 << (USB_HIM_TDONEIE_OFFS + 16))
N
N#define USB_HIM_RESUMEIE_Set                 (uint32_t)(1 << USB_HIM_RESUMEIE_OFFS)
N#define USB_HIM_RESUMEIE_Reset               (uint32_t)(1 << (USB_HIM_RESUMEIE_OFFS + 16))
N
N#define USB_HIM_CONEVIE_Set                  (uint32_t)(1 << USB_HIM_CONEVIE_OFFS)
N#define USB_HIM_CONEVIE_Reset                (uint32_t)(1 << (USB_HIM_CONEVIE_OFFS + 16))
N
N#define USB_HIM_SOFIE_Set                    (uint32_t)(1 << USB_HIM_SOFIE_OFFS)
N#define USB_HIM_SOFIE_Reset                  (uint32_t)(1 << (USB_HIM_SOFIE_OFFS + 16))
N
N#define USB_HIM_SET_MASK                     (USB_HIM_TDONEIE_Set  | \
N                                              USB_HIM_RESUMEIE_Set | \
N                                              USB_HIM_CONEVIE_Set  | \
N                                              USB_HIM_SOFIE_Set)
X#define USB_HIM_SET_MASK                     (USB_HIM_TDONEIE_Set  |                                               USB_HIM_RESUMEIE_Set |                                               USB_HIM_CONEVIE_Set  |                                               USB_HIM_SOFIE_Set)
N
N#define USB_HIM_RESET_MASK                   (USB_HIM_SET_MASK << 16)
N
N#define IS_USB_HIM_VALUE(VALUE)              ((((VALUE) & (~(USB_HIM_SET_MASK | USB_HIM_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HIM_VALUE(VALUE)              ((((VALUE) & (~(USB_HIM_SET_MASK | USB_HIM_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HIM_Values */
N
N/** @defgroup USB_HRXS_Values USB_HRXS Values
N  * @{
N  */
N
N#define USB_HRXS_CRCERR_Set                  (uint32_t)(1 << USB_HRXS_CRCERR_OFFS)
N#define USB_HRXS_CRCERR_Reset                (uint32_t)(1 << (USB_HRXS_CRCERR_OFFS + 16))
N
N#define USB_HRXS_BSERR_Set                   (uint32_t)(1 << USB_HRXS_BSERR_OFFS)
N#define USB_HRXS_BSERR_Reset                 (uint32_t)(1 << (USB_HRXS_BSERR_OFFS + 16))
N
N#define USB_HRXS_RXOF_Set                    (uint32_t)(1 << USB_HRXS_RXOF_OFFS)
N#define USB_HRXS_RXOF_Reset                  (uint32_t)(1 << (USB_HRXS_RXOF_OFFS + 16))
N
N#define USB_HRXS_RXTO_Set                    (uint32_t)(1 << USB_HRXS_RXTO_OFFS)
N#define USB_HRXS_RXTO_Reset                  (uint32_t)(1 << (USB_HRXS_RXTO_OFFS + 16))
N
N#define USB_HRXS_NAKRXED_Set                 (uint32_t)(1 << USB_HRXS_NAKRXED_OFFS)
N#define USB_HRXS_NAKRXED_Reset               (uint32_t)(1 << (USB_HRXS_NAKRXED_OFFS + 16))
N
N#define USB_HRXS_STALLRXED_Set               (uint32_t)(1 << USB_HRXS_STALLRXED_OFFS)
N#define USB_HRXS_STALLRXED_Reset             (uint32_t)(1 << (USB_HRXS_STALLRXED_OFFS + 16))
N
N#define USB_HRXS_ACKRXED_Set                 (uint32_t)(1 << USB_HRXS_ACKRXED_OFFS)
N#define USB_HRXS_ACKRXED_Reset               (uint32_t)(1 << (USB_HRXS_ACKRXED_OFFS + 16))
N
N#define USB_HRXS_DATASEQ_Data1               (uint32_t)(1 << USB_HRXS_DATASEQ_OFFS)
N#define USB_HRXS_DATASEQ_Data0               (uint32_t)(1 << (USB_HRXS_DATASEQ_OFFS + 16))
N
N#define USB_HRXS_SET_MASK                    (USB_HRXS_CRCERR_Set    | \
N                                              USB_HRXS_BSERR_Set     | \
N                                              USB_HRXS_RXOF_Set      | \
N                                              USB_HRXS_RXTO_Set      | \
N                                              USB_HRXS_NAKRXED_Set   | \
N                                              USB_HRXS_STALLRXED_Set | \
N                                              USB_HRXS_ACKRXED_Set   | \
N                                              USB_HRXS_DATASEQ_Data1)
X#define USB_HRXS_SET_MASK                    (USB_HRXS_CRCERR_Set    |                                               USB_HRXS_BSERR_Set     |                                               USB_HRXS_RXOF_Set      |                                               USB_HRXS_RXTO_Set      |                                               USB_HRXS_NAKRXED_Set   |                                               USB_HRXS_STALLRXED_Set |                                               USB_HRXS_ACKRXED_Set   |                                               USB_HRXS_DATASEQ_Data1)
N
N#define USB_HRXS_RESET_MASK                  (USB_HRXS_SET_MASK << 16)
N
N#define IS_USB_HRXS_VALUE(VALUE)             ((((VALUE) & (~(USB_HRXS_SET_MASK | USB_HRXS_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_HRXS_VALUE(VALUE)             ((((VALUE) & (~(USB_HRXS_SET_MASK | USB_HRXS_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_HRXS_Values */
N
N/** @defgroup USB_HRXCS_Values USB_HRXCS Values
N  * @{
N  */
N
N#define USB_HRXCS_RXLS_Disconnect            (uint32_t)(0x00000000)
N#define USB_HRXCS_RXLS_LowSpeed              (uint32_t)(0x00000001)
N#define USB_HRXCS_RXLS_FullSpeed             (uint32_t)(0x00000002)
N
N#define IS_USB_HRXCS_VALUE(VALUE)            (((VALUE) == USB_HRXCS_RXLS_Disconnect) || \
N                                              ((VALUE) == USB_HRXCS_RXLS_LowSpeed)   || \
N                                              ((VALUE) == USB_HRXCS_RXLS_FullSpeed))
X#define IS_USB_HRXCS_VALUE(VALUE)            (((VALUE) == USB_HRXCS_RXLS_Disconnect) ||                                               ((VALUE) == USB_HRXCS_RXLS_LowSpeed)   ||                                               ((VALUE) == USB_HRXCS_RXLS_FullSpeed))
N
N/** @} */ /* End of group USB_HRXCS_Values */
N
N#define IS_USB_HTXA_VALUE(VALUE)             ((VALUE)  < 0x00000080)
N#define IS_USB_HTXE_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HFN_VALUE(VALUE)              ((VALUE)  < 0x00000800)
N#define IS_USB_HRXP_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HRXA_VALUE(VALUE)             ((VALUE)  < 0x00000080)
N#define IS_USB_HRXE_VALUE(VALUE)             ((VALUE)  < 0x00000010)
N#define IS_USB_HSTM_VALUE(VALUE)             ((VALUE)  < 0x00000100)
N#define IS_USB_HRXFD_VALUE(VALUE)            ((VALUE)  < 0x00000100)
N#define IS_USB_HRXFDC_VALUE(VALUE)           ((VALUE)  < 0x00010000)
N#define IS_USB_HRXFC_VALUE(VALUE)            ((VALUE) == 0x00000001)
N#define IS_USB_HTXFD_VALUE(VALUE)            ((VALUE)  < 0x00000100)
N#define IS_USB_HTXFC_VALUE(VALUE)            ((VALUE) == 0x00000001)
N
N/** @} */ /* End of group USB_HOST_REGS_Values */
N
N/** @defgroup USB_DEVICE_REGS_Values USB_DEVICE Register Values
N  * @{
N  */
N
N/** @defgroup USB_SEPx_CTRL_Values USB_SEPx_CTRL Values
N  * @{
N  */
N
N#define USB_SEPx_CTRL_EPEN_Enable            (uint32_t)(1 << USB_SEP_CTRL_EPEN_OFFS)
N#define USB_SEPx_CTRL_EPEN_Disable           (uint32_t)(1 << (USB_SEP_CTRL_EPEN_OFFS + 16))
N
N#define USB_SEPx_CTRL_EPRDY_Ready            (uint32_t)(1 << USB_SEP_CTRL_EPRDY_OFFS)
N#define USB_SEPx_CTRL_EPRDY_NotReady         (uint32_t)(1 << (USB_SEP_CTRL_EPRDY_OFFS + 16))
N
N#define USB_SEPx_CTRL_EPDATASEQ_Data1        (uint32_t)(1 << USB_SEP_CTRL_EPDATASEQ_OFFS)
N#define USB_SEPx_CTRL_EPDATASEQ_Data0        (uint32_t)(1 << (USB_SEP_CTRL_EPDATASEQ_OFFS + 16))
N
N#define USB_SEPx_CTRL_EPSSTALL_Reply         (uint32_t)(1 << USB_SEP_CTRL_EPSSTALL_OFFS)
N#define USB_SEPx_CTRL_EPSSTALL_NotReply      (uint32_t)(1 << (USB_SEP_CTRL_EPSSTALL_OFFS + 16))
N
N#define USB_SEPx_CTRL_EPISOEN_Set            (uint32_t)(1 << USB_SEP_CTRL_EPISOEN_OFFS)
N#define USB_SEPx_CTRL_EPISOEN_Reset          (uint32_t)(1 << (USB_SEP_CTRL_EPISOEN_OFFS + 16))
N
N#define USB_SEPx_CTRL_SET_MASK               (USB_SEPx_CTRL_EPEN_Enable     | \
N                                              USB_SEPx_CTRL_EPRDY_Ready     | \
N                                              USB_SEPx_CTRL_EPDATASEQ_Data1 | \
N                                              USB_SEPx_CTRL_EPSSTALL_Reply  | \
N                                              USB_SEPx_CTRL_EPISOEN_Set)
X#define USB_SEPx_CTRL_SET_MASK               (USB_SEPx_CTRL_EPEN_Enable     |                                               USB_SEPx_CTRL_EPRDY_Ready     |                                               USB_SEPx_CTRL_EPDATASEQ_Data1 |                                               USB_SEPx_CTRL_EPSSTALL_Reply  |                                               USB_SEPx_CTRL_EPISOEN_Set)
N
N#define USB_SEPx_CTRL_RESET_MASK             (USB_SEPx_CTRL_SET_MASK << 16)
N
N#define IS_USB_SEPx_CTRL_VALUE(VALUE)        ((((VALUE) & (~(USB_SEPx_CTRL_SET_MASK | USB_SEPx_CTRL_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SEPx_CTRL_VALUE(VALUE)        ((((VALUE) & (~(USB_SEPx_CTRL_SET_MASK | USB_SEPx_CTRL_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SEPx_CTRL_Values */
N
N/** @defgroup USB_SEPx_STS_Values USB_SEPx_STS Values
N  * @{
N  */
N
N#define USB_SEPx_STS_SCCRCERR_Set            (uint32_t)(1 << USB_SEP_STS_SCCRCERR_OFFS)
N#define USB_SEPx_STS_SCCRCERR_Reset          (uint32_t)(1 << (USB_SEP_STS_SCCRCERR_OFFS + 16))
N
N#define USB_SEPx_STS_SCBSERR_Set             (uint32_t)(1 << USB_SEP_STS_SCBSERR_OFFS)
N#define USB_SEPx_STS_SCBSERR_Reset           (uint32_t)(1 << (USB_SEP_STS_SCBSERR_OFFS + 16))
N
N#define USB_SEPx_STS_SCRXOF_Set              (uint32_t)(1 << USB_SEP_STS_SCRXOF_OFFS)
N#define USB_SEPx_STS_SCRXOF_Reset            (uint32_t)(1 << (USB_SEP_STS_SCRXOF_Pos + 16))
N
N#define USB_SEPx_STS_SCRXTO_Set              (uint32_t)(1 << USB_SEP_STS_SCRXTO_OFFS)
N#define USB_SEPx_STS_SCRXTO_Reset            (uint32_t)(1 << (USB_SEP_STS_SCRXTO_OFFS + 16))
N
N#define USB_SEPx_STS_SCNAKSENT_Set            (uint32_t)(1 << USB_SEP_STS_SCNAKSENT_OFFS)
N#define USB_SEPx_STS_SCNAKSENT_Reset         (uint32_t)(1 << (USB_SEP_STS_SCNAKSENT_OFFS + 16))
N
N#define USB_SEPx_STS_SCSTALLSENT_Set         (uint32_t)(1 << USB_SEP_STS_SCSTALLSENT_OFFS)
N#define USB_SEPx_STS_SCSTALLSENT_Reset       (uint32_t)(1 << (USB_SEP_STS_SCSTALLSENT_OFFS + 16))
N
N#define USB_SEPx_STS_SCACKRXED_Set           (uint32_t)(1 << USB_SEP_STS_SCACKRXED_OFFS)
N#define USB_SEPx_STS_SCACKRXED_Reset         (uint32_t)(1 << (USB_SEP_STS_SCACKRXED_OFFS + 16))
N
N#define USB_SEPx_STS_SCDATASEQ_Data1         (uint32_t)(1 << USB_SEP_STS_SCDATASEQ_OFFS)
N#define USB_SEPx_STS_SCDATASEQ_Data0         (uint32_t)(1 << (USB_SEP_STS_SCDATASEQ_OFFS + 16))
N
N#define USB_SEPx_STS_SET_MASK                (USB_SEPx_STS_SCCRCERR_Set    | \
N                                              USB_SEPx_STS_SCBSERR_Set     | \
N                                              USB_SEPx_STS_SCRXOF_Set      | \
N                                              USB_SEPx_STS_SCRXTO_Set      | \
N                                              USB_SEPx_STS_SCSTALLSENT_Set | \
N                                              USB_SEPx_STS_SCNAKSENT_Set   | \
N                                              USB_SEPx_STS_SCACKRXED_Set   | \
N                                              USB_SEPx_STS_SCDATASEQ_Data1)
X#define USB_SEPx_STS_SET_MASK                (USB_SEPx_STS_SCCRCERR_Set    |                                               USB_SEPx_STS_SCBSERR_Set     |                                               USB_SEPx_STS_SCRXOF_Set      |                                               USB_SEPx_STS_SCRXTO_Set      |                                               USB_SEPx_STS_SCSTALLSENT_Set |                                               USB_SEPx_STS_SCNAKSENT_Set   |                                               USB_SEPx_STS_SCACKRXED_Set   |                                               USB_SEPx_STS_SCDATASEQ_Data1)
N
N#define USB_SEPx_STS_RESET_MASK              (USB_SEPx_STS_SET_MASK << 16)
N
N#define IS_USB_SEPx_STS_VALUE(VALUE)         ((((VALUE) & (~(USB_SEPx_STS_SET_MASK | USB_SEPx_STS_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SEPx_STS_VALUE(VALUE)         ((((VALUE) & (~(USB_SEPx_STS_SET_MASK | USB_SEPx_STS_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SEPx_STS_Values */
N
N/** @defgroup USB_SEPx_TS_Values USB_SEPx_TS Values
N  * @{
N  */
N
N#define USB_SEPx_TS_SCTTYPE_Setup            (uint32_t)(0x00000000)
N#define USB_SEPx_TS_SCTTYPE_In               (uint32_t)(0x00000001)
N#define USB_SEPx_TS_SCTTYPE_Outdata          (uint32_t)(0x00000002)
N
N#define USB_SEPx_TS_SCTTYPE_Msk              (uint32_t)(0x00000003)
N
N#define IS_USB_SEPx_TS_VALUE(VALUE)          (((VALUE) == USB_SEPx_TS_SCTTYPE_Setup)   || \
N                                              ((VALUE) == USB_SEPx_TS_SCTTYPE_In)      || \
N                                              ((VALUE) == USB_SEPx_TS_SCTTYPE_Outdata))
X#define IS_USB_SEPx_TS_VALUE(VALUE)          (((VALUE) == USB_SEPx_TS_SCTTYPE_Setup)   ||                                               ((VALUE) == USB_SEPx_TS_SCTTYPE_In)      ||                                               ((VALUE) == USB_SEPx_TS_SCTTYPE_Outdata))
N
N/** @} */ /* End of group USB_SEPx_TS_Values */
N
N/** @defgroup USB_SEPx_NTS_Values USB_SEPx_NTS Values
N  * @{
N  */
N
N#define USB_SEPx_NTS_NTTTYPE_Setup           (uint32_t)(0x00000000)
N#define USB_SEPx_NTS_NTTTYPE_In              (uint32_t)(0x00000001)
N#define USB_SEPx_NTS_NTTTYPE_Outdata         (uint32_t)(0x00000002)
N
N#define USB_SEPx_NTS_NTTTYPE_Msk             (uint32_t)(0x00000003)
N
N#define IS_USB_SEPx_NTS_VALUE(VALUE)         (((VALUE) == USB_SEPx_NTS_NTTTYPE_Setup)   || \
N                                              ((VALUE) == USB_SEPx_NTS_NTTTYPE_In)      || \
N                                              ((VALUE) == USB_SEPx_NTS_NTTTYPE_Outdata))
X#define IS_USB_SEPx_NTS_VALUE(VALUE)         (((VALUE) == USB_SEPx_NTS_NTTTYPE_Setup)   ||                                               ((VALUE) == USB_SEPx_NTS_NTTTYPE_In)      ||                                               ((VALUE) == USB_SEPx_NTS_NTTTYPE_Outdata))
N
N/** @} */ /* End of group USB_SEPx_NTS_Values */
N
N/** @defgroup USB_SC_Values USB_SC Values
N  * @{
N  */
N
N#define USB_SC_SCGEN_Set                     (uint32_t)(1 << USB_SC_SCGEN_OFFS)
N#define USB_SC_SCGEN_Reset                   (uint32_t)(1 << (USB_SC_SCGEN_OFFS + 16))
N
N#define USB_SC_SCTXLS_DM_Set                 (uint32_t)(1 << USB_SC_SCTXLS_OFFS)
N#define USB_SC_SCTXLS_DM_Reset               (uint32_t)(1 << (USB_SC_SCTXLS_OFFS + 16))
N
N#define USB_SC_SCTXLS_DP_Set                 (uint32_t)(1 << (USB_SC_SCTXLS_OFFS + 1))
N#define USB_SC_SCTXLS_DP_Reset               (uint32_t)(1 << (USB_SC_SCTXLS_OFFS + 16 + 1))
N
N#define USB_SC_SCDC_Direct                   (uint32_t)(1 << USB_SC_SCDC_OFFS)
N#define USB_SC_SCDC_Normal                   (uint32_t)(1 << (USB_SC_SCDC_OFFS + 16))
N
N#define USB_SC_SCFSP_Full                    (uint32_t)(1 << USB_SC_SCFSP_OFFS)
N#define USB_SC_SCFSP_Low                     (uint32_t)(1 << (USB_SC_SCFSP_OFFS + 16))
N
N#define USB_SC_SCFSR_12Mb                    (uint32_t)(1 << USB_SC_SCFSR_OFFS)
N#define USB_SC_SCFSR_1_5Mb                   (uint32_t)(1 << (USB_SC_SCFSR_OFFS + 16))
N
N#define USB_SC_SET_MASK                      (USB_SC_SCGEN_Set     | \
N                                              USB_SC_SCTXLS_DM_Set | \
N                                              USB_SC_SCTXLS_DP_Set | \
N                                              USB_SC_SCDC_Direct   | \
N                                              USB_SC_SCFSP_Full    | \
N                                              USB_SC_SCFSR_12Mb)
X#define USB_SC_SET_MASK                      (USB_SC_SCGEN_Set     |                                               USB_SC_SCTXLS_DM_Set |                                               USB_SC_SCTXLS_DP_Set |                                               USB_SC_SCDC_Direct   |                                               USB_SC_SCFSP_Full    |                                               USB_SC_SCFSR_12Mb)
N
N#define USB_SC_RESET_MASK                    (USB_SC_SET_MASK << 16)
N
N#define IS_USB_SC_VALUE(VALUE)               ((((VALUE) & (~(USB_SC_SET_MASK | USB_SC_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SC_VALUE(VALUE)               ((((VALUE) & (~(USB_SC_SET_MASK | USB_SC_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SC_Values */
N
N/** @defgroup USB_SLS_Values USB_SLS Values
N  * @{
N  */
N
N#define USB_SLS_SCRXLS_Reset                 (uint32_t)(0x00000000)
N#define USB_SLS_SCRXLS_LowSpeed              (uint32_t)(0x00000001)
N#define USB_SLS_SCRXLS_FullSpeed             (uint32_t)(0x00000002)
N
N#define IS_USB_SLS_VALUE(VALUE)              (((VALUE) == USB_SLS_SCRXLS_Reset)     || \
N                                              ((VALUE) == USB_SLS_SCRXLS_LowSpeed)  || \
N                                              ((VALUE) == USB_SLS_SCRXLS_FullSpeed))
X#define IS_USB_SLS_VALUE(VALUE)              (((VALUE) == USB_SLS_SCRXLS_Reset)     ||                                               ((VALUE) == USB_SLS_SCRXLS_LowSpeed)  ||                                               ((VALUE) == USB_SLS_SCRXLS_FullSpeed))
N
N/** @} */ /* End of group USB_SLS_Values */
N
N/** @defgroup USB_SIS_Values USB_SIS Values
N  * @{
N  */
N
N#define USB_SIS_SCTDONE_Set                  USB_SIS_SCTDONE
N#define USB_SIS_SCRESUME_Set                 USB_SIS_SCRESUME
N#define USB_SIS_SCRESETEV_Set                USB_SIS_SCRESETEV
N#define USB_SIS_SCSOFREC_Set                 USB_SIS_SCSOFREC
N#define USB_SIS_SCNAKSENT_Set                USB_SIS_SCNAKSENT
N
N#define USB_SIS_Msk                          USB_SIS_SCTDONE_Set   | \
N                                             USB_SIS_SCRESUME_Set  | \
N                                             USB_SIS_SCRESETEV_Set | \
N                                             USB_SIS_SCSOFREC_Set  | \
N                                             USB_SIS_SCNAKSENT_Set
X#define USB_SIS_Msk                          USB_SIS_SCTDONE_Set   |                                              USB_SIS_SCRESUME_Set  |                                              USB_SIS_SCRESETEV_Set |                                              USB_SIS_SCSOFREC_Set  |                                              USB_SIS_SCNAKSENT_Set
N
N#define IS_USB_SIS_VALUE(VALUE)              (((VALUE) == USB_SIS_SCTDONE_Set)   || \
N                                              ((VALUE) == USB_SIS_SCRESUME_Set)  || \
N                                              ((VALUE) == USB_SIS_SCRESETEV_Set) || \
N                                              ((VALUE) == USB_SIS_SCSOFREC_Set)  || \
N                                              ((VALUE) == USB_SIS_SCNAKSENT_Set))
X#define IS_USB_SIS_VALUE(VALUE)              (((VALUE) == USB_SIS_SCTDONE_Set)   ||                                               ((VALUE) == USB_SIS_SCRESUME_Set)  ||                                               ((VALUE) == USB_SIS_SCRESETEV_Set) ||                                               ((VALUE) == USB_SIS_SCSOFREC_Set)  ||                                               ((VALUE) == USB_SIS_SCNAKSENT_Set))
N
N/** @} */ /* End of group USB_SIS_Values */
N
N/** @defgroup USB_SIM_Values USB_SIM Values
N  * @{
N  */
N
N#define USB_SIM_SCTDONEIE_Set                (uint32_t)(1 << USB_SIM_SCTDONEIE_OFFS)
N#define USB_SIM_SCTDONEIE_Reset              (uint32_t)(1 << (USB_SIM_SCTDONEIE_OFFS + 16))
N
N#define USB_SIM_SCRESUMEIE_Set               (uint32_t)(1 << USB_SIM_SCRESUMEIE_OFFS)
N#define USB_SIM_SCRESUMEIE_Reset             (uint32_t)(1 << (USB_SIM_SCRESUMEIE_OFFS + 16))
N
N#define USB_SIM_SCRESETEVIE_Set              (uint32_t)(1 << USB_SIM_SCRESETEVIE_OFFS)
N#define USB_SIM_SCRESETEVIE_Reset            (uint32_t)(1 << (USB_SIM_SCRESETEVIE_OFFS + 16))
N
N#define USB_SIM_SCSOFRECIE_Set               (uint32_t)(1 << USB_SIM_SCSOFRECIE_OFFS)
N#define USB_SIM_SCSOFRECIE_Reset             (uint32_t)(1 << (USB_SIM_SCSOFRECIE_OFFS + 16))
N
N#define USB_SIM_SCNAKSENTIE_Set              (uint32_t)(1 << USB_SIM_SCNAKSENTIE_OFFS)
N#define USB_SIM_SCNAKSENTIE_Reset            (uint32_t)(1 << (USB_SIM_SCNAKSENTIE_OFFS + 16))
N
N#define USB_SIM_SET_MASK                     (USB_SIM_SCTDONEIE_Set   | \
N                                              USB_SIM_SCRESUMEIE_Set  | \
N                                              USB_SIM_SCRESETEVIE_Set | \
N                                              USB_SIM_SCSOFRECIE_Set  | \
N                                              USB_SIM_SCNAKSENTIE_Set)
X#define USB_SIM_SET_MASK                     (USB_SIM_SCTDONEIE_Set   |                                               USB_SIM_SCRESUMEIE_Set  |                                               USB_SIM_SCRESETEVIE_Set |                                               USB_SIM_SCSOFRECIE_Set  |                                               USB_SIM_SCNAKSENTIE_Set)
N
N#define USB_SIM_RESET_MASK                   (USB_SIM_SET_MASK << 16)
N
N#define IS_USB_SIM_VALUE(VALUE)              ((((VALUE) & (~(USB_SIM_SET_MASK | USB_SIM_RESET_MASK))) == 0) && \
N                                              ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
X#define IS_USB_SIM_VALUE(VALUE)              ((((VALUE) & (~(USB_SIM_SET_MASK | USB_SIM_RESET_MASK))) == 0) &&                                               ((((VALUE) & ((uint32_t)(VALUE)) >> 16)) == 0))
N
N/** @} */ /* End of group USB_SIM_Values */
N
N#define IS_USB_SA_VALUE(VALUE)               ((VALUE)  < 0x00000080)
N#define IS_USB_SFN_VALUE(VALUE)              ((VALUE)  < 0x00000800)
N#define IS_USB_SEPx_RXFD_VALUE(VALUE)        ((VALUE)  < 0x00000100)
N#define IS_USB_SEPx_RXFDC_VALUE(VALUE)       ((VALUE)  < 0x00010000)
N#define IS_USB_SEPx_RXFC_VALUE(VALUE)        ((VALUE) == 0x00000001)
N#define IS_USB_SEPx_TXFD_VALUE(VALUE)        ((VALUE)  < 0x00000100)
N#define IS_USB_SEPx_TXFDC_VALUE(VALUE)       ((VALUE) == 0x00000001)
N
N/** @} */ /* End of group USB_DEVICE_REGS_Values */
N
N
N/** @defgroup USB_Exported_Functions USB Exported Functions
N  * @{
N  */
N
Nvoid USB_BRGInit(const USB_Clock_TypeDef* USB_Clock_InitStruct);
Nvoid USB_Reset(void);
N
N/**
N  * @brief  Common register functions
N  */
N
Nuint32_t USB_GetHSCR(void);
Nvoid     USB_SetHSCR(uint32_t RegValue);
N
NUSB_Version_TypeDef USB_GetHSVR(void);
N
N/**
N  * @brief  Host register functions
N  */
N
Nuint32_t USB_GetHTXC(void);
Nvoid     USB_SetHTXC(uint32_t RegValue);
Nuint32_t USB_GetHTXT(void);
Nvoid     USB_SetHTXT(uint32_t RegValue);
Nuint32_t USB_GetHTXLC(void);
Nvoid     USB_SetHTXLC(uint32_t RegValue);
Nuint32_t USB_GetHTXSE(void);
Nvoid     USB_SetHTXSE(uint32_t RegValue);
Nuint32_t USB_GetHTXA(void);
Nvoid     USB_SetHTXA(uint32_t RegValue);
Nuint32_t USB_GetHTXE(void);
Nvoid     USB_SetHTXE(uint32_t RegValue);
Nuint32_t USB_GetHFN(void);
Nuint32_t USB_GetHIS(void);
Nvoid     USB_SetHIS(uint32_t RegValue);
Nuint32_t USB_GetHIM(void);
Nvoid     USB_SetHIM(uint32_t RegValue);
Nuint32_t USB_GetHRXS(void);
Nuint32_t USB_GetHRXP(void);
Nuint32_t USB_GetHRXA(void);
Nuint32_t USB_GetHRXE(void);
Nuint32_t USB_GetHRXCS(void);
Nuint32_t USB_GetHSTM(void);
Nuint32_t USB_GetHRXFD(void);
Nuint32_t USB_GetHRXFDC(void);
Nuint32_t USB_GetHRXFC(void);
Nvoid     USB_SetHRXFC(uint32_t RegValue);
Nuint32_t USB_GetHTXFD(void);
Nvoid     USB_SetHTXFD(uint32_t RegValue);
Nuint32_t USB_GetHTXFC(void);
Nvoid     USB_SetHTXFC(uint32_t RegValue);
N
N/**
N  * @brief  Slave register functions
N  */
N
Nuint32_t USB_GetSEPxCTRL(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxCTRL(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxSTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxNTS(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSC(void);
Nvoid     USB_SetSC(uint32_t RegValue);
Nuint32_t USB_GetSLS(void);
Nuint32_t USB_GetSIS(void);
Nvoid     USB_SetSIS(uint32_t RegValue);
Nuint32_t USB_GetSIM(void);
Nvoid     USB_SetSIM(uint32_t RegValue);
Nuint32_t USB_GetSA(void);
Nvoid     USB_SetSA(uint32_t RegValue);
Nuint32_t USB_GetSFN(void);
Nuint32_t USB_GetSEPxRXFD(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxRXFDC(USB_EP_TypeDef EndPointNumber);
Nuint32_t USB_GetSEPxRXFC(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxRXFC(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxTXFD(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxTXFD(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nuint32_t USB_GetSEPxTXFDC(USB_EP_TypeDef EndPointNumber);
Nvoid     USB_SetSEPxTXFDC(USB_EP_TypeDef EndPointNumber, uint32_t RegValue);
Nvoid     USB_SEPxToggleEPDATASEQ(USB_EP_TypeDef EndPointNumber);
N
N/** @} */ /* End of group USB_Exported_Functions */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group 1986BE9x_StdPeriph_Driver */
N
N#endif /* __OPORA_USB_H */
N
N/*
N* END OF FILE opora_usb.h */
N
L 33 ".\inc\1986BE9x_usb_device.h" 2
N#include "1986BE9x_config.h"
L 1 ".\inc\1986BE9x_config.h" 1
N/**
N  ******************************************************************************
N  * @file    1986be9x_config.h
N  * @author  Phyton Application Team
N  * @version V1.0.0
N  * @date    10/07/2010
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __1986BE9x_CONFIG_H
N#define __1986BE9x_CONFIG_H
N
N#include "1986BE9x_lib.h"
N#include "stdint.h"
N
N/* Uncomment the line(s) below to define used JTAG port(s). Leave all commented
N * if there is no JTAG ports */
N/* #define USE_JTAG_A */
N/* #define USE_JTAG_B */
N
N/* Target system parameters */
N/* RST_CLK generators frequencies in HZ */
N#define HSI_Value       ((uint32_t)8000000)
N#define HSE_Value       ((uint32_t)8000000)
N#define LSI_Value       ((uint32_t)40000)
N#define LSE_Value       ((uint32_t)32768)
N
N/* RST_CLK frequencies startup timeouts settings */
N#define HSEonTimeOut    ((uint16_t)0x0600)
N#define LSEonTimeOut    ((uint16_t)0x0600)
N#define HSIonTimeOut    ((uint16_t)0x0600)
N#define LSIonTimeOut    ((uint16_t)0x0600)
N#define PLLCPUonTimeOut ((uint16_t)0x0600)
N#define PLLUSBonTimeOut ((uint16_t)0x0600)
N
N#define FLASH_PROG_FREQ_MHZ                     (8.0)
N
N/* DMA configuration parameters */
N/* Number of DMA channels to use */
N//#define DMA_Channels_Number   32          /* This parameter is in range 1..32 */
N
N/* Alternate Control Data Structure Usage */
N/* This parameter can be a value of:
N    0 = DMA_ALternateDataDisabled;
N    1 = DMA_ALternateDataEnabled; */
N#define DMA_AlternateData   0           /* DMA_AlternateDataDisabled */
N/*#define DMA_AlternateData   1*/             /* DMA_AlternateDataEnabled */
N
N/* USB configuration parameters ----------------------------------------------*/
N/* Uncomment one of the lines below to select the Device Class. Leave all commented
N * if the desired device class is not currently supported by USB library */
N#define USB_DEVICE_CLASS  USB_DEVICE_CLASS_CDC
N
N/* USB Device management */
N/* Uncomment the line below to enable appropriate functionality. */
N/* #define USB_REMOTE_WAKEUP_SUPPORTED */
N #define USB_SELF_POWERED_SUPPORTED 
N
N/* Uncomment the line below to let the library provide USB interrupt handler.
N * Leave this line commented if you are willing to implement the handler yourself. */
N#define USB_INT_HANDLE_REQUIRED
N
N/* USB CDC management */
N/* Uncomment the lines below to enable appropriate functionality. */
N/* #define USB_CDC_STATE_REPORTING_SUPPORTED */
N/* #define USB_CDC_ENCAPSULATION_SUPPORTED */
N/* #define USB_CDC_COMM_FEATURE_SUPPORTED */
N#define USB_CDC_LINE_CODING_SUPPORTED
N/* #define USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N/* #define USB_CDC_LINE_BREAK_SUPPORTED */
N
N/* VCOM Echo example flags */
N
N/* Uncomment USB_VCOM_SYNC to enable "reliable delivery" mode: no new data
N * would be received (EP3 will reply NAK) until all previous data is sent
N * to host. */
N/* #define USB_VCOM_SYNC */
N
N/* Uncomment USB_DEBUG_PROTO to utilize the ring buffer for received setup
N * packets and send/receive byte counters (for debug purposes). */
N/* #define USB_DEBUG_PROTO */
N
N/* Parameter run-time check support ------------------------------------------*/
N
N/* Select one of the following values of USE_ASSERT_INFO macro to control
N   parameter checking in the Standard Peripheral Library drivers:
N     0 - no parameter checks ("assert_param" macro is disabled);
N     1 - check enabled, source file ID and line number are available;
N     2 - check enabled, source file ID, line number and checking expression
N         (as string) are available (increased code size).
N*/
N#define USE_ASSERT_INFO    0
N/* #define USE_ASSERT_INFO    1 */
N/* #define USE_ASSERT_INFO    2 */
N
N/**
N  * @brief  The assert_param macro is used for function's parameters check.
N  * @param  expr: If expr is false, it calls assert_failed user's function
N  *   which gets the source file ID (see 1986be9x_lib.h), line number and
N  *   expression text (if USE_ASSERT_INFO == 2) of the call that failed. That
N  *   function should not return. If expr is true, nothing is done.
N  * @retval None
N  */
N#if (USE_ASSERT_INFO == 0)
X#if (0 == 0)
N  #define assert_param(expr) ((void)0)
N#elif (USE_ASSERT_INFO == 1)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__))
S  void assert_failed(uint32_t file_id, uint32_t line);
S#elif (USE_ASSERT_INFO == 2)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__, #expr))
S  void assert_failed(uint32_t file_id, uint32_t line, const uint8_t* expr);
S#else
S  #error "Unsupported USE_ASSERT_INFO level"
N#endif /* USE_ASSERT_INFO */
N
N#endif /* __1986BE9x_CONFIG_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE 1986BE9x_config.h */
N
L 34 ".\inc\1986BE9x_usb_device.h" 2
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_Device_Framework_Exported_Types USB Device Framework Exported Types
N  * @{
N  */
N
N/**
N  * @brief Request Type Data Transfer Direction enumeration
N  */
N
Ntypedef enum
N{
N  USB_HOST_TO_DEVICE  = 0x0,
N  USB_DEVICE_TO_HOST  = 0x80
N}USB_RequestTypeDT_TypeDef;
N
N/**
N  * @brief Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_TYPE_STANDARD  = 0x0,
N  USB_TYPE_CLASS     = 0x20,
N  USB_TYPE_VENDOR    = 0x40
N}USB_RequestType_TypeDef;
N
N#define USB_REQUEST_DT_Msk                    0x80
N#define USB_REQUEST_TYPE_Msk                  0x60
N
N/**
N  * @brief Standard Setup Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_GET_STATUS = 0,
N  USB_CLEAR_FEATURE,
N  USB_Reserved0,
N  USB_SET_FEATURE,
N  USB_Reserved1,
N  USB_SET_ADDRESS,
N  USB_GET_DESCRIPTOR,
N  USB_SET_DESCRIPTOR,
N  USB_GET_CONFIGURATION,
N  USB_SET_CONFIGURATION,
N  USB_GET_INTERFACE,
N  USB_SET_INTERFACE,
N  USB_SYNCH_FRAME
N} USB_Standard_Setup_TypeDef;
N
N/**
N  * @brief Standard Descriptor Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEVICE = 1,
N  USB_CONFIGURATION,
N  USB_STRING,
N  USB_INTERFACE,
N  USB_ENDPOINT,
N  USB_DEVICE_QUALIFIER,
N  USB_OTHER_SPEED_CONFIGURATION,
N  USB_INTERFACE_POWER
N} USB_Standard_Descriptor_TypeDef;
N
N/**
N  * @brief Standard Feature Selector Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_ENDPOINT_HALT = 0,
N  USB_DEVICE_REMOTE_WAKEUP,
N  USB_TEST_MODE
N} USB_Standard_Festure_Selector_TypeDef;
N
N/**
N  * @brief Request Recipient enumeration
N  */
N
Ntypedef enum
N{
N  USB_RECIPIENT_DEVICE    = 0x0,
N  USB_RECIPIENT_INTERFACE = 0x1,
N  USB_RECIPIENT_ENDPOINT  = 0x2,
N  USB_RECIPIENT_OTHER     = 0x3
N}USB_RequestRecipient_TypeDef;
N
N#define USB_RECIPIENT_TYPE_Msk                0x1F
N#define IS_VALID_USB_RECIPIENT(RECIPIENT)     ((RECIPIENT) <= USB_RECIPIENT_OTHER)
N
N/**
N  * @brief Setup Packet Structure (9.3) definition
N  */
N
Ntypedef struct
N{
N  uint8_t  mRequestTypeData;             /*!< Characteristics of request:
N                                              D7:    Data transfer direction (USB_RequestTypeDT_TypeDef),
N                                              D6..5: Type (USB_RequestType_TypeDef),
N                                              D4..0: Recipient (USB_RequestRecipient_TypeDef). */
N  uint8_t  bRequest;                     /*!< Specific request. */
N  uint16_t wValue;                       /*!< Request value 1st word (wValue). */
N  uint16_t wIndex;                       /*!< Request value 2nd word (wIndex). */
N  uint16_t wLength;                      /*!< Data stage bytes number. */
N}USB_SetupPacket_TypeDef;
N
N/** @} */ /* End of group USB_Device_Framework_Exported_Types */
N
N/** @defgroup USB_EndPoint USB EndPoint
N  * @{
N  */
N
N/** @defgroup USB_EndPoint_Exported_Types USB EndPoint Exported Types
N  * @{
N  */
N
N/**
N  * @brief Function Return Code enumeration
N  */
N
Ntypedef enum
N{
N  USB_SUCCESS     = 0x0,             /*!< Success. */
N  USB_ERROR       = 0x1,             /*!< General USB driver failure. */
N  USB_ERR_INV_REQ = 0x2,             /*!< Incorrect data in USB device request. */
N  USB_ERR_BUSY    = 0x200,           /*!< Action cannot be proceeded at this time. */
N}USB_Result;
N
N/**
N  * @brief Stall Type enumeration
N  */
N
Ntypedef enum {USB_STALL_PROTO = 0x0, USB_STALL_HALT = 0x1} USB_StallType;
N
N/** @defgroup USB_EndPoint_Transaction_Handlers USB EndPoint End of Transaction Handlers
N  * @{
N  */
N
Ntypedef USB_Result (*USB_EP_IO_Handler)(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
Ntypedef USB_Result (*USB_EP_Setup_Handler)(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
Ntypedef USB_Result (*USB_EP_Error_Handler)(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL);
N
N/** @} */ /* End of group USB_EndPoint_Transaction_Handlers */
N
N/** @} */ /* End of group USB_EndPoint_Exported_Types */
N
N/** @defgroup USB_EndPoint_Exported_Constants USB EndPoint Exported Constants
N  * @{
N  */
N
N#define MAX_PACKET_SIZE                      32
N
N/** @} */ /* End of group USB_EndPoint_Exported_Constants */
N
N/** @defgroup USB_EndPoint_Exported_Macros USB EndPoint Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_EndPoint_Exported_Macros */
N
N/** @defgroup USB_EndPoint_Exported_Functions USB EndPoint Exported Functions
N  * @{
N  */
N
NUSB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError);
NUSB_Result USB_EP_Reset(USB_EP_TypeDef EPx);
NUSB_Result USB_EP_Idle(USB_EP_TypeDef EPx);
NUSB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt);
N
NUSB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone);
NUSB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone);
N
NUSB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket);
N
NUSB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT);
N
N/** @} */ /* End of group USB_EndPoint_Exported_Functions */
N
N/** @} */ /* End of group USB_EndPoint */
N
N/** @defgroup USB_Device USB Device
N  * @{
N  */
N
N/** @defgroup USB_Device_Exported_Types USB Device Exported Types
N  * @{
N  */
N
N/**
N  * @brief Device State (9.1) enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_STATE_UNKNOWN = 0,
N  USB_DEV_STATE_ATTACHED,
N  USB_DEV_STATE_POWERED,
N  USB_DEV_STATE_DEFAULT,
N  USB_DEV_STATE_ADDRESS,
N  USB_DEV_STATE_CONFIGURED,
N  Num_USB_DEV_STATE
N}USB_DeviceState_TypeDef;
N
N/**
N  * @brief Device Self Powered State enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_SELF_POWERED_OFF = 0,
N  USB_DEV_SELF_POWERED_ON  = 1
N} USB_DeviceSelfPoweredState_TypeDef;
N
N/**
N  * @brief Device Remote Wakeup Ability enumeration
N  */
N
Ntypedef enum
N{
N  USB_DEV_REMOTE_WAKEUP_DISABLED = 0,
N  USB_DEV_REMOTE_WAKEUP_ENABLED = 1
N}USB_DeviceRemoteWakeup_TypeDef;
N
N/**
N  * @brief Device Status Structure definition
N  */
N
Ntypedef struct
N{
N#ifdef USB_SELF_POWERED_SUPPORTED
N  USB_DeviceSelfPoweredState_TypeDef SelfPowered;
N#endif /* USB_SELF_POWERED_SUPPORTED */
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S  USB_DeviceRemoteWakeup_TypeDef     RemoteWakeupEnabled;
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N#if !defined (USB_SELF_POWERED_SUPPORTED) && !defined (USB_REMOTE_WAKEUP_SUPPORTED)
X#if !1L && !0L
S  uint32_t                           Reserved;
N#endif
N}Usb_DeviceStatus_TypeDef;
N
N/**
N  * @brief Device State Machine Context Structure definition
N  */
N
Ntypedef struct {
N  USB_DeviceState_TypeDef  USB_DeviceState;
N  Usb_DeviceStatus_TypeDef USB_DeviceStatus;
N  uint32_t Address;
N}USB_DeviceContext_TypeDef;
N
N/**
N  * @brief USB BUS parameters Structure definition
N  */
N
Ntypedef struct {
N  uint32_t PULL;                           /*!< This member configures the D+  D- line pulling
N                                                This member can be combination of the following values:
N                                                USB_HSCR_DM_PULLDOWN_Set: D- line pull down
N                                                USB_HSCR_DM_PULLUP_Set:   D- line pull up
N                                                USB_HSCR_DP_PULLDOWN_Set: D+ line pull down
N                                                USB_HSCR_DP_PULLUP_Set:   D+ line pull up */
N  uint32_t SPEED;                          /*!< This member configures the USB speed
N                                                This member can be one of the following values:
N                                                USB_SC_SCFSR_12Mb:  12 Mbit/sec
N                                                USB_SC_SCFSR_1_5Mb: 1.5 Mbit/sec */
N  uint32_t MODE;                           /*!< This member configures the USB polarity
N                                                This member can be one of the following values:
N                                                USB_SC_SCFSP_Full: FULL_SPEED
N                                                USB_SC_SCFSP_Low:  LOW_SPEED */
N}USB_DeviceBUSParam_TypeDef;
N
N#define IS_USB_PULL(PULL)                    (((PULL) == USB_HSCR_DM_PULLDOWN_Set) || \
N                                              ((PULL) == USB_HSCR_DM_PULLUP_Set)   || \
N                                              ((PULL) == USB_HSCR_DP_PULLDOWN_Set) || \
N                                              ((PULL) == USB_HSCR_DP_PULLUP_Set))
X#define IS_USB_PULL(PULL)                    (((PULL) == USB_HSCR_DM_PULLDOWN_Set) ||                                               ((PULL) == USB_HSCR_DM_PULLUP_Set)   ||                                               ((PULL) == USB_HSCR_DP_PULLDOWN_Set) ||                                               ((PULL) == USB_HSCR_DP_PULLUP_Set))
N
N#define IS_USB_SPEED(SPEED)                  (((SPEED) == USB_SC_SCFSR_12Mb) || \
N                                              ((SPEED) == USB_SC_SCFSR_1_5Mb))
X#define IS_USB_SPEED(SPEED)                  (((SPEED) == USB_SC_SCFSR_12Mb) ||                                               ((SPEED) == USB_SC_SCFSR_1_5Mb))
N
N#define IS_USB_MODE(MODE)                    (((MODE) == USB_SC_SCFSP_Full) || \
N                                              ((MODE) == USB_SC_SCFSP_Low))
X#define IS_USB_MODE(MODE)                    (((MODE) == USB_SC_SCFSP_Full) ||                                               ((MODE) == USB_SC_SCFSP_Low))
N
N/** @} */ /* End of group USB_Device_Exported_Types */
N
N/** @defgroup USB_Device_Exported_Constants USB Device Exported Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Exported_Constants */
N
N/** @defgroup USB_Device_Exported_Variables USB Device Exported Variables
N  * @{
N  */
N
N/**
N  * @brief Last processed Controlling Setup Packet (or currently in processing)
N  */
N
Nextern USB_SetupPacket_TypeDef USB_CurrentSetupPacket;
N
N/**
N  * @brief Device State Machine Context
N  */
N
Nextern USB_DeviceContext_TypeDef USB_DeviceContext;
N
N/** @} */ /* End of group USB_Device_Exported_Variables */
N
N/** @defgroup USB_Device_Exported_Macros USB Device Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Exported_Macros */
N
N/** @defgroup USB_Device_Exported_Functions USB Device Exported Functions
N  * @{
N  */
N
NUSB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam);
NUSB_Result USB_DevicePowerOn(void);
NUSB_Result USB_DevicePowerOff(void);
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
SUSB_Result USB_DeviceRemoteWakeUp(void);
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N
NUSB_Result USB_DeviceReset(void);
NUSB_Result USB_DeviceSuspend(void);
NUSB_Result USB_DeviceResume(void);
N
NUSB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
N
NUSB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX);
NUSB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX);
N
NUSB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
NUSB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
N
NUSB_Result USB_DeviceDispatchEvent(void);
N
N#ifdef USB_INT_HANDLE_REQUIRED
Nvoid USB_IRQHandler(void);
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N/** @defgroup USB_Device_Exported_Dummy_Functions USB Device Handler Samples
N  * @{
N  */
N
NUSB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX);
NUSB_Result USB_DeviceDummySetAddress(uint16_t wVALUE);
NUSB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
NUSB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
Nuint8_t    USB_DeviceDummyGetConfiguration(void);
NUSB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE);
Nuint8_t    USB_DeviceDummyGetInterface(uint16_t wINDEX);
NUSB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX);
NUSB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA);
NUSB_Result USB_DeviceDummyClassRequest(void);
NUSB_Result USB_DeviceDummyVendorRequest(void);
NUSB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL);
N
N/** @} */ /* End of group USB_Device_Exported_Dummy_Functions */
N
N/** @} */ /* End of group USB_Device_Exported_Functions */
N
N/** @} */ /* End of group USB_Device */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group 1986BE9x_StdPeriph_Driver */
N
N#endif /* __1986BE9x_USB_DEVICE_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE 1986BE9x_usb_device.h */
N
L 36 ".\inc\1986BE9x_usb_cdc.h" 2
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_CDC USB Communication Device Class
N  * @{
N  */
N
N/** @defgroup USB_CDC_Exported_Types USB CDC Exported Types
N  * @{
N  */
N
N/**
N  * @brief CDC Class-Specific Setup Request Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_SEND_ENCAPSULATED_COMMAND = 0x00,
N  USB_CDC_GET_ENCAPSULATED_RESPONSE,
N  USB_CDC_SET_COMM_FEATURE,
N  USB_CDC_GET_COMM_FEATURE,
N  USB_CDC_CLEAR_COMM_FEATURE,
N  USB_CDC_SET_AUX_LINE_STATE        = 0x10,
N  USB_CDC_SET_HOOK_STATE,
N  USB_CDC_PULSE_SETUP,
N  USB_CDC_SEND_PULSE,
N  USB_CDC_SET_PULSE_TIME,
N  USB_CDC_RING_AUX_JACK,
N  USB_CDC_SET_LINE_CODING           = 0x20,
N  USB_CDC_GET_LINE_CODING,
N  USB_CDC_SET_CONTROL_LINE_STATE,
N  USB_CDC_SEND_BREAK,
N  USB_CDC_SET_RINGER_PARAMS         = 0x30,
N  USB_CDC_GET_RINGER_PARAMS,
N  USB_CDC_SET_OPERATION_PARAMS,
N  USB_CDC_GET_OPERATION_PARAMS,
N  USB_CDC_SET_LINE_PARAMS,
N  USB_CDC_GET_LINE_PARAMS,
N  USB_CDC_DIAL_DIGITS
N} USB_CDC_Class_Setup_TypeDef;
N
N
N/**
N  * @brief USB_CDC Serial State enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_bRxCarrier  = 0x1,
N  USB_CDC_bTxCarrier  = 0x2,
N  USB_CDC_bBreak      = 0x3,
N  USB_CDC_bRingSignal = 0x4,
N  USB_CDC_bFraming    = 0x5,
N  USB_CDC_bParity     = 0x6,
N  USB_CDC_bOverRun    = 0x7
N}USB_CDCSerialState_TypeDef;
N
N/**
N  * @brief USB_CDC Char Format enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_STOP_BITS1   = 0x0,
N  USB_CDC_STOP_BITS1_5 = 0x1,
N  USB_CDC_STOP_BITS2   = 0x2,
N}USB_CDC_CharFormat_TypeDef;
N
N/**
N  * @brief USB_CDC Parity Type enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_PARITY_NONE  = 0x0,
N  USB_CDC_PARITY_ODD   = 0x1,
N  USB_CDC_PARITY_EVEN  = 0x2,
N  USB_CDC_PARITY_MARK  = 0x3,
N  USB_CDC_PARITY_SPACE = 0x4
N}USB_CDC_ParityType_TypeDef;
N
N/**
N  * @brief USB_CDC Date Bits enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_DATE_BITS5  = 0x5,
N  USB_CDC_DATE_BITS6  = 0x6,
N  USB_CDC_DATE_BITS7  = 0x7,
N  USB_CDC_DATE_BITS8  = 0x8,
N  USB_CDC_DATE_BITS16 = 0xA
N}USB_CDC_DateBits_TypeDef;
N
N/**
N  * @brief USB_CDC Line Coding Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t dwDTERate;
N  uint8_t  bCharFormat;
N  uint8_t  bParityType;
N  uint8_t  bDataBits;
N}USB_CDC_LineCoding_TypeDef;
N
N/**
N  * @brief USB_CDC Control Line State enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_DTR_PRESENT          = 0x1,
N  USB_CDC_RTS_ACTIVATE_CARRIER = 0x2
N}USB_CDC_ControlLineState_TypeDef;
N
N
N/**
N  * @brief USB_CDC Line State Report Notifications enumeration
N  */
N
Ntypedef enum
N{
N  USB_CDC_RING_DETECT             = 0x09,
N  USB_CDC_SERIAL_STATE            = 0x20,
N  USB_CDC_CALL_STATE_CHANGE       = 0x28,
N  USB_CDC_LINE_STATE_CHANGE       = 0x29,
N  USB_CDC_CONNECTION_SPEED_CHANGE = 0x2A
N}USB_CDC_LineStateReport_TypeDef;
N
N/** @} */ /* End of group USB_CDC_Exported_Types */
N
N/** @defgroup USB_CDC_Exported_Constants USB CDC Exported Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_CDC_Exported_Constants */
N
N/** @defgroup USB_CDC_Exported_Variables USB CDC Exported Variables
N  * @{
N  */
N
N
N/** @} */ /* End of group USB_CDC_Exported_Variables */
N
N/** @defgroup USB_CDC_Exported_Macros USB CDC Exported Macros
N  * @{
N  */
N
N/** @defgroup USB_CDC_End_Point_Aliases USB CDC End Point Aliases
N  * @{
N  */
N
N#define USB_CDC_EP_SEND             USB_EP1
N#define USB_CDC_EP_RECEIVE          USB_EP3
N#define USB_CDC_EP_STATE            USB_EP2
N
N/** @} */ /* End of group USB_CDC_End_Point_Aliases */
N
N/** @} */ /* End of group USB_CDC_Exported_Macros */
N
N/** @defgroup USB_CDC_Exported_Functions USB CDC Exported Functions
N  * @{
N  */
N
NUSB_Result USB_CDC_Init(uint8_t* ReceiveBuffer, uint32_t DataPortionLength, FlagStatus StartReceiving);
N
NUSB_Result USB_CDC_SetReceiveBuffer(uint8_t* ReceiveBuffer, uint32_t DataPortionLength);
NUSB_Result USB_CDC_ReceiveStart(void);
NUSB_Result USB_CDC_ReceiveStop(void);
N
NUSB_Result USB_CDC_SendData(uint8_t* Buffer, uint32_t Length);
N
N#ifdef USB_CDC_STATE_REPORTING_SUPPORTED
SUSB_Result USB_CDC_ReportState(uint16_t LineState);
N#endif
N
N/** @defgroup USB_CDC_Exported_Overwritten_Device_Handlers USB CDC Overwritten Device Handlers
N  * @{
N  */
N
NUSB_Result USB_CDC_Reset(void);
NUSB_Result USB_CDC_GetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH);
NUSB_Result USB_CDC_ClassRequest(void);
N
N/** @} */ /* End of group USB_CDC_Exported_Overwritten_Device_Handlers */
N
N/** @defgroup USB_CDC_Exported_Dummy_Functions USB CDC Handler Samples
N  * @{
N  */
N
NUSB_Result USB_CDC_DummyDataReceive(uint8_t* Buffer, uint32_t Length);
NUSB_Result USB_CDC_DummyDataSent(void);
N
N#ifdef USB_CDC_ENCAPSULATION_SUPPORTED
SUSB_Result USB_CDC_DummySendEncapsulatedCMD(uint16_t wINDEX, uint16_t wLENGTH);
SUSB_Result USB_CDC_DummyGetEncapsulatedResp(uint16_t wINDEX, uint16_t wLENGTH);
N#endif
N
N#ifdef USB_CDC_COMM_FEATURE_SUPPORTED
SUSB_Result USB_CDC_DummyGetCommFeature(uint16_t wVALUE, uint16_t wINDEX, uint16_t* DATA);
SUSB_Result USB_CDC_DummySetCommFeature(uint16_t wVALUE, uint16_t wINDEX, uint16_t DATA);
SUSB_Result USB_CDC_DummyClearCommFeature(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
NUSB_Result USB_CDC_DummyGetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA);
NUSB_Result USB_CDC_DummySetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA);
N#endif
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
SUSB_Result USB_CDC_DummyControlLineState(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N#ifdef USB_CDC_LINE_BREAK_SUPPORTED
SUSB_Result USB_CDC_DummySendBreak(uint16_t wVALUE, uint16_t wINDEX);
N#endif
N
N/** @} */ /* End of group USB_CDC_Exported_Dummy_Functions */
N
N/** @} */ /* End of group USB_CDC_Exported_Functions */
N
N/** @} */ /* End of group USB_CDC */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group 1986BE9x_StdPeriph_Driver */
N
N#endif /* __1986BE9x_USB_CDC_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE 1986BE9x_usb_CDC.h */
N
L 28 ".\inc\1986BE9x_usb_default_handlers.h" 2
N
N/* Configuration file 1986be9x_config.h should be included before */
N#ifndef __1986BE9x_CONFIG_H
S#error "Configuration file 1986be9x_config.h should be included before"
N#endif
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_Configuring USB Configuring
N  * @{
N  */
N
N/** @defgroup USB_Device_Configuring USB Device Configuring
N  * @{
N  */
N
N/**
N  * @brief Bus reset handler
N  */
N
N#define USB_DEVICE_HANDLE_RESET  USB_DeviceReset()
N
N/**
N  * @brief Device enter suspended mode handler
N  */
N
N#define USB_DEVICE_HANDLE_SUSPEND  USB_DeviceSuspend()
N
N/**
N  * @brief Device exit from suspended mode handler
N  */
N
N#define USB_DEVICE_HANDLE_RESUME  USB_DeviceResume()
N
N/**
N  * @brief Control Setup Packet general processing handle
N  */
N
N#define USB_DEVICE_HANDLE_SETUP   USB_DeviceSetupPacket
N
N/**
N  * @brief GET_STATUS standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_STATUS(Recipient, wINDEX)    USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetStatus as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_STATUS(Recipient, wINDEX)    USB_DeviceDummyGetStatus(Recipient, wINDEX)
N */
N
N/**
N  * @brief CLEAR_FEATURE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_CLEAR_FEATURE(Recipient, wVALUE, wINDEX) \
N        USB_DeviceClearFeature(Recipient, wVALUE, wINDEX)
X#define USB_DEVICE_HANDLE_CLEAR_FEATURE(Recipient, wVALUE, wINDEX)         USB_DeviceClearFeature(Recipient, wVALUE, wINDEX)
N
N/**
N  * @brief SET_FEATURE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_FEATURE(Recipient, wVALUE, wINDEX)  \
N        USB_DeviceSetFeature(Recipient, wVALUE, wINDEX)
X#define USB_DEVICE_HANDLE_SET_FEATURE(Recipient, wVALUE, wINDEX)          USB_DeviceSetFeature(Recipient, wVALUE, wINDEX)
N
N/**
N  * @brief SET_ADDRESS standard request handler (preparation phase)
N  */
N
N#define USB_DEVICE_HANDLE_SET_ADDRESS(wVALUE)  USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetAddress as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_ADDRESS(wVALUE)  USB_DeviceDummySetAddress(wVALUE)
N */
N
N/**
N  * @brief GET_DESCRIPTOR standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetDescriptor as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_DeviceDummyGetDescriptor(wVALUE, wINDEX, wLENGTH)
N */
N
N/**
N  * @brief SET_DESCRIPTOR standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetDescriptor as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)  USB_DeviceDummySetDescriptor(wVALUE, wINDEX, wLENGTH)
N */
N
N/**
N  * @brief GET_CONFIGURATION standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_CONFIGURATION  1
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetConfiguration as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_CONFIGURATION  USB_DeviceDummyGetConfiguration()
N */
N
N/**
N  * @brief SET_CONFIGURATION standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)  \
N        ((wVALUE) == 1 ? USB_SUCCESS : USB_ERROR)
X#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)          ((wVALUE) == 1 ? USB_SUCCESS : USB_ERROR)
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetConfiguration as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_CONFIGURATION(wVALUE)  USB_DeviceDummySetConfiguration(wVALUE)
N */
N
N/**
N  * @brief GET_INTERFACE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_GET_INTERFACE(wINDEX)  0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyGetInterface as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_GET_INTERFACE(wINDEX)  USB_DeviceDummyGetInterface(wINDEX)
N */
N
N/**
N  * @brief SET_INTERFACE standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX) \
N        ((wINDEX) == 0 && (wVALUE) == 0 ? USB_SUCCESS : USB_ERROR)
X#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX)         ((wINDEX) == 0 && (wVALUE) == 0 ? USB_SUCCESS : USB_ERROR)
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySetInterface as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SET_INTERFACE(wVALUE, wINDEX)  USB_DeviceDummySetInterface(wVALUE, wINDEX)
N */
N
N/**
N  * @brief SYNC_FRAME standard request handler
N  */
N
N#define USB_DEVICE_HANDLE_SYNC_FRAME(wINDEX, DATA)  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummySyncFrame as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_SYNC_FRAME(wINDEX, DATA)  USB_DeviceDummySyncFrame(wINDEX, DATA)
N */
N
N/**
N  * @brief Class-type request handler
N  */
N
N#define USB_DEVICE_HANDLE_CLASS_REQUEST  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyClassRequest as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_CLASS_REQUEST  USB_DeviceDummyClassRequest()
N */
N
N/**
N  * @brief Vendor-type request handler
N  */
N
N#define USB_DEVICE_HANDLE_VENDOR_REQUEST  USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyVendorRequest as an example and replacing it with your own function
N#define USB_DEVICE_HANDLE_VENDOR_REQUEST  USB_DeviceDummyVendorRequest()
N */
N
N/** @} */ /* End of group USB_Device_Configuring */
N
N/** @defgroup USB_CDC_Configuring USB CDC Configuring
N  * @{
N  */
N
N#if (USB_DEVICE_CLASS == USB_DEVICE_CLASS_CDC)
X#if (2 == 2)
N/** @defgroup USB_CDC_Handlers USB CDC Handlers
N  * @{
N  */
N
N/** @defgroup USB_CDC_Exported_Handlers USB CDC Handler Definitions and defaults
N  * @{
N  */
N
N/**
N  * @brief Data receive request handler
N  */
N
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)             USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyDataReceive as an example and replacing it with your own function
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)    USB_CDC_DummyDataReceive(BUFFER, LENGTH)
N */
N
N/**
N  * @brief Data sent completion handler
N  */
N
N#define USB_CDC_HANDLE_DATA_SENT                                USB_SUCCESS
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyDataSent as an example and replacing it with your own function
N#define USB_CDC_HANDLE_DATA_SENT                  USB_CDC_DummyDataSent()
N */
N
N/**
N  * @brief Data send error handler
N  */
N
N#define USB_CDC_HANDLE_SEND_ERROR                               0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyDataError as an example and replacing it with your own function
N#define USB_CDC_HANDLE_SEND_ERROR                 USB_DeviceDummyDataError
N */
N
N
N#ifdef USB_CDC_ENCAPSULATION_SUPPORTED
S/**
S  * @brief SEND_ENCAPSULATED_COMMAND Class-specific request handler
S  */
S
S#define USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wINDEX, wLENGTH)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySendEncapsulatedCMD as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wINDEX, wLENGTH)    USB_CDC_DummySendEncapsulatedCMD(wINDEX, wLENGTH)
S */
S
S/**
S  * @brief GET_ENCAPSULATED_RESPONSE Class-specific request handler
S  */
S
S#define USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wINDEX, wLENGTH)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyGetEncapsulatedResp as an example and replacing it with your own function
S#define USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wINDEX, wLENGTH)    USB_CDC_DummyGetEncapsulatedResp(wINDEX, wLENGTH)
S */
S
N#endif /* USB_CDC_ENCAPSULATION_SUPPORTED */
N
N#ifdef USB_CDC_COMM_FEATURE_SUPPORTED
S
S/**
S  * @brief GET_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_GET_COMM_FEATURE(wVALUE, wINDEX, DATA)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyGetCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_GET_COMM_FEATURE(wVALUE, wINDEX, DATA)    USB_CDC_DummyGetCommFeature(wVALUE, wINDEX, DATA)
S */
S
S/**
S  * @brief  SET_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_SET_COMM_FEATURE(wVALUE, wINDEX, DATA)   USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySetCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SET_COMM_FEATURE(wVALUE, wINDEX, DATA)    USB_CDC_DummySetCommFeature(wVALUE, wINDEX, DATA)
S */
S
S/**
S  * @brief  CLEAR_COMM_FEATURE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wVALUE, wINDEX)       USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyClearCommFeature as an example and replacing it with your own function
S#define USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wVALUE, wINDEX)    USB_CDC_DummyClearCommFeature(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
N/**
N  * @brief  GET_LINE_CODING Class-specific request handle
N  */
N
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)            USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummyGetLineCoding as an example and replacing it with your own function
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)    USB_CDC_DummyGetLineCoding(wINDEX, DATA)
N */
N
N/**
N  * @brief  SET_LINE_CODING Class-specific request handle
N  */
N
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)            USB_ERROR
N/* To redefine handler for your own function choose the variant below using
N * USB_CDC_DummySetLineCoding as an example and replacing it with your own function
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)    USB_CDC_DummySetLineCoding(wINDEX, DATA)
N */
N
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
S/**
S  * @brief SET_CONTROL_LINE_STATE Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_CONTROL_LINE_STATE(wVALUE, wINDEX)       USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummyControlLineState as an example and replacing it with your own function
S#define USB_CDC_HANDLE_SET_CONTROL_LINE_STATE(wVALUE, wINDEX)    USB_CDC_DummyControlLineState(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N
N#ifdef USB_CDC_LINE_BREAK_SUPPORTED
S/**
S  * @brief  SEND_BREAK Class-specific request handle
S  */
S
S#define USB_CDC_HANDLE_BREAK(wVALUE, wINDEX)                    USB_ERROR
S/* To redefine handler for your own function choose the variant below using
S * USB_CDC_DummySendBreak as an example and replacing it with your own function
S#define USB_CDC_HANDLE_BREAK(wVALUE, wINDEX)    USB_CDC_DummySendBreak(wVALUE, wINDEX)
S */
S
N#endif /* USB_CDC_LINE_BREAK_SUPPORTED */
N
N/**
N  * @brief Line state report send error handler
N  */
N
N#define USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR             0
N/* To redefine handler for your own function choose the variant below using
N * USB_DeviceDummyDataError as an example and replacing it with your own function
N#define USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR   USB_DeviceDummyDataError
N */
N
N/** @} */ /* End of group USB_CDC_Exported_Handlers */
N
N/** @} */ /* End of group USB_CDC_Handlers */
N
N/** @defgroup USB_CDC_Used_Device_Handlers USB CDC Used Device Handlers
N  * @{
N  */
N
N#undef  USB_DEVICE_HANDLE_RESET
N#define USB_DEVICE_HANDLE_RESET                                   USB_CDC_Reset()
N
N#undef  USB_DEVICE_HANDLE_CLASS_REQUEST
N#define USB_DEVICE_HANDLE_CLASS_REQUEST                           USB_CDC_ClassRequest()
N
N#undef  USB_DEVICE_HANDLE_GET_DESCRIPTOR
N#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH) \
N                   USB_CDC_GetDescriptor(wVALUE, wINDEX, wLENGTH)
X#define USB_DEVICE_HANDLE_GET_DESCRIPTOR(wVALUE, wINDEX, wLENGTH)                    USB_CDC_GetDescriptor(wVALUE, wINDEX, wLENGTH)
N
N/** @} */ /* End of group USB_CDC_Used_Device_Handlers */
N
N#endif /* USB_DEVICE_CLASS == USB_DEVICE_CLASS_CDC */
N
N/** @} */ /* End of group USB_CDC_Configuring */
N
N/** @} */ /* End of group USB_Configuring */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group 1986BE9x_StdPeriph_Driver */
N
N#endif /* __1986BE9x_USB_DEFAULT_HANDLERS_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE 1986be9x_usb_default_handlers.h */
N
L 27 ".\inc\1986BE9x_usb_handlers.h" 2
N
N/* Configuration file 1986be9x_config.h should be included before */
N#ifndef __1986BE9x_CONFIG_H
S#error "Configuration file 1986be9x_config.h should be included before"
N#endif
N
N
N/** @addtogroup __1986BE9x_StdPeriph_Examples 1986BE9x StdPeriph Examples
N  * @{
N  */
N
N/** @addtogroup __1986BE91_EVAL 1986BE91 Evaluation Board
N  * @{
N  */
N
N/** @addtogroup  USB_Virtual_COM_Port_Echo USB Virtual COM Port Echo
N  * @{
N  */
N
N/** @defgroup USB_Virtual_COM_Port_Echo_Handlers USB Virtual COM Port Echo Handlers
N  * @{
N  */
N
N#undef USB_CDC_HANDLE_DATA_RECEIVE
N#define USB_CDC_HANDLE_DATA_RECEIVE(BUFFER, LENGTH)   USB_CDC_RecieveData(BUFFER, LENGTH)
N
N#ifdef USB_VCOM_SYNC
S#undef USB_CDC_HANDLE_DATA_SENT
S#define USB_CDC_HANDLE_DATA_SENT                                USB_CDC_DataSent();
N#endif /* USB_VCOM_SYNC */
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
N#undef USB_CDC_HANDLE_GET_LINE_CODING
N#define USB_CDC_HANDLE_GET_LINE_CODING(wINDEX, DATA)  USB_CDC_GetLineCoding(wINDEX, DATA)
N#undef USB_CDC_HANDLE_SET_LINE_CODING
N#define USB_CDC_HANDLE_SET_LINE_CODING(wINDEX, DATA)  USB_CDC_SetLineCoding(wINDEX, DATA)
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
S#undef USB_CDC_HANDLE_CONTROL_LINE_STATE
S#define USB_CDC_HANDLE_CONTROL_LINE_STATE(wVALUE, wINDEX)       USB_SUCCESS
N#endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N
N
N#ifdef USB_DEBUG_PROTO
S#undef USB_DEVICE_HANDLE_SETUP
S#define USB_DEVICE_HANDLE_SETUP   USB_DeviceSetupPacket_Debug
N#endif /* USB_DEBUG_PROTO */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo_Handlers */
N
N
N/** @defgroup USB_Virtual_COM_Port_Echo_Handler_Functions USB Virtual COM Port Echo Handler Functions
N  * @{
N  */
N
NUSB_Result USB_CDC_RecieveData(uint8_t* Buffer, uint32_t Length);
N
N#ifdef USB_CDC_LINE_CODING_SUPPORTED
NUSB_Result USB_CDC_GetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA);
NUSB_Result USB_CDC_SetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA);
N#endif /* USB_CDC_LINE_CODING_SUPPORTED */
N
N#ifdef USB_VCOM_SYNC
SUSB_Result USB_CDC_DataSent(void);
N#endif /* USB_VCOM_SYNC */
N
N#ifdef USB_DEBUG_PROTO
SUSB_Result USB_DeviceSetupPacket_Debug(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket);
N#endif /* USB_DEBUG_PROTO */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo_Handler_Functions */
N
N/** @} */ /* End of group USB_Virtual_COM_Port_Echo */
N
N/** @} */ /* End of group __1986BE91_EVAL */
N
N/** @} */ /* End of group __1986BE9x_StdPeriph_Examples */
N
N
N#endif /* __1986BE9x_USB_HANDLERS_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********************************
N*
N* END OF FILE 1986be9x_usb_handlers.h */
N
L 28 "src\1986BE9x_usb_device.c" 2
N
N#define ASSERT_INFO_FILE_ID FILEID__1986BE9X_USB_DEVICE_C
N
N/** @addtogroup __1986BE9x_StdPeriph_Driver 1986BE9x Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup USB USB
N  * @{
N  */
N
N/** @defgroup USB_Device_Framework_Private_Types USB Device Framework Private Types
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Framework_Private_Types */
N
N/** @defgroup USB_EndPoint_Private USB EndPoint
N  * @{
N  */
N
N/** @defgroup USB_EndPoint_Private_Types USB EndPoint Private Types
N  * @{
N  */
N
N/**
N  * @brief EndPoint States
N  */
N
Ntypedef enum
N{
N  USB_EP_NAK,
N  USB_EP_IDLE,
N  USB_EP_IN,
N  USB_EP_OUT,
N  USB_EP_SETUP,
N  USB_EP_STALL
N}USB_EPState_TypeDef;
N
N/**
N  * @brief EndPoint State Machine Context type
N  */
N
Ntypedef struct
N{
N  USB_EPState_TypeDef EP_State;
N  USB_StallType EP_Halt;
N  struct
N  {
N    struct
N    {
N      /* IN-OUT transactions buffer */
N      uint8_t *pBuffer;
N      uint32_t length, offset;
N      uint32_t bytesToAck;        /* number of bytes sent to host in
N                                     IN transaction but not acknowledged yet */
N    }IO_Buffer;
N    /* SETUP-transaction */
N    USB_SetupPacket_TypeDef *pSetupPacket;
N  }Buffer;
N  FlagStatus EP_WasScdone;
N  FlagStatus EP_WaitOut, EP_WaitSetup;
N  USB_EP_IO_Handler InHandler;
N  USB_EP_IO_Handler OutHandler;
N  USB_EP_Setup_Handler SetupHandler;
N  USB_EP_Error_Handler ErrorHandler;
N}USB_EPContext_TypeDef;
N
N/**
N  * @brief DATA bit change control
N  */
N
Ntypedef enum
N{
N  USB_DATA_BIT_KEEP,
N  USB_DATA_BIT_TOGGLE,
N  USB_DATA_BIT_DATA1,
N}USB_EPData_Bit_TypeDef;
N
N/** @} */ /* End of group USB_EndPoint_Private_Types */
N
N/** @defgroup USB_EndPoint_Private_Values USB EndPoint Private Values
N  * @{
N  */
N
N/**
N  * @brief EndPoint State Machine Context
N  */
N
NUSB_EPContext_TypeDef USB_EPContext[Num_USB_EndPoints];
N
N/** @} */ /* End of group USB_EndPoint_Private_Values */
N
N/** @defgroup USB_EndPoint_Private_Constants USB EndPoint Private Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_EndPoint_Private_Constants */
N
N/** @defgroup USB_EndPoint_Private_Macros USB EndPoint Private Macros
N  * @{
N  */
N
N#define TX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxTXFDC(EndPoint, 1)
N#define RX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxRXFC(EndPoint, 1)
N#define EPx_RX_FIFO_DATA(EndPoint)           USB_GetSEPxRXFD(EndPoint)
N
N/** @} */ /* End of group USB_EndPoint_Private_Macros */
N
N/** @defgroup USB_EndPoint_Private_FunctionPrototypes USB EndPoint Private Function Prototypes
N  * @{
N  */
N
Nstatic void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange);
Nstatic void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val);
N
N/** @} */ /* End of group USB_EndPoint_Private_FunctionPrototypes */
N
N/** @defgroup USB_EndPoint_Private_Functions USB EndPoint Private Functions
N  * @{
N  */
N
N/**
N  * @brief  Initial EndPoint setup
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  * @param  USB_EP_Ctrl: Value, controlling EPISOEN, EPDATASEQ bits
N  *         of corresponding USB_SEPx.CTRL register.
N  * @param  onError: User's handler to be called on any error with data transmitting
N  *                   via this End Point (may be 0).
N  *
N  * @retval USB_Result status (USB_SUCCESS or USB_ERROR).
N  */
N
NUSB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* EndPoint context preparation */
N  ep->Buffer.IO_Buffer.pBuffer    = 0;
N  ep->Buffer.IO_Buffer.length     = 0;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->Buffer.pSetupPacket         = 0;
N  ep->InHandler                   = 0;
N  ep->OutHandler                  = 0;
N  ep->SetupHandler                = 0;
N  ep->ErrorHandler                = onError;
N  ep->EP_Halt                     = USB_STALL_PROTO;
N  ep->EP_State                    = USB_EP_NAK;
N  ep->EP_WasScdone                = RESET;
N
N  USB_SetSEPxCTRL(EPx, USB_EP_Ctrl);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Resets the EndPoint to NAK state
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_Reset(USB_EP_TypeDef EPx)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  ep->EP_State = USB_EP_NAK;
N  ep->EP_WasScdone = RESET;
N
N  USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPISOEN_Reset  |                           /* Reset Isohronic */
X  USB_SetSEPxCTRL(EPx, (uint32_t)(1 << (4 + 16))  |                            
N                       USB_SEPx_CTRL_EPRDY_NotReady |                           /* Reset READY */
X                       (uint32_t)(1 << (1 + 16)) |                            
N                       USB_SEPx_CTRL_EPEN_Enable);                              /* Set ENABLE */
X                       (uint32_t)(1 << 0));                               
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Switches the EndPoint to IDLE (wait for transaction) or NAK state
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @retval USB_Result.
N  *
N  * @note   IDLE state and EPRDY bit are set if OUT/SETUP transaction is expected.
N  *         Otherwise, this function switches to NAK state.
N  */
N
NUSB_Result USB_EP_Idle(USB_EP_TypeDef EPx)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t val = USB_SEPx_CTRL_EPSSTALL_NotReply;                               /* Reset STALL reply */
X  uint32_t val = (uint32_t)(1 << (3 + 16));                                
N
N  if (ep->EP_WaitOut || ep->EP_WaitSetup)
N  {
N    ep->EP_State = USB_EP_IDLE;
N    val |= USB_SEPx_CTRL_EPRDY_Ready;                                           /* Set READY */
X    val |= (uint32_t)(1 << 1);                                            
N  }
N  else
N  {
N    ep->EP_State = USB_EP_NAK;
N  }
N  ep->EP_Halt = USB_STALL_PROTO;
N
N  USB_EP_SetReady(EPx, val);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Switches the EndPoint to STALL state (protocol stall
N  *         or halt) or NAK state, if STALL is prohibited.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  bHalt: Specifies whether the STALL state is a HALT
N  *         This parameter can be: USB_STALL_PROTO or USB_STALL_HALT.
N  *
N  * @retval USB_Result.
N  *
N  * @note   If protocol stall is ordered, but the EndPoint doesn't accept
N  *         SETUP transactions, EndPoint is switched to NAK state.
N  */
N
NUSB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t val = 0;
N
N  if (bHalt == USB_STALL_HALT && EPx == USB_EP0)
N  {
N    /* No functional stall for Default Control Pipe */
N    return USB_ERROR;
N  }
N
N  if (bHalt == USB_STALL_HALT || ep->EP_WaitSetup)
N  {
N    ep->EP_Halt  = bHalt;
N    ep->EP_State = USB_EP_STALL;
N    val = USB_SEPx_CTRL_EPSSTALL_Reply |                                          /* Set STALL reply */
X    val = (uint32_t)(1 << 3) |                                           
N          USB_SEPx_CTRL_EPRDY_Ready;                                              /* Set READY */
X          (uint32_t)(1 << 1);                                               
N  }
N
N  USB_EP_SetReady(EPx, val);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that there is data to be sent to the host by this
N  *         EndPoint with one or several IN-transactions.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with data to be sent.
N  *
N  * @param  Length: Length of data.
N  *
N  * @param  onInDone: User's handler to be called when data transfer is
N  *                   successfully complete (may be 0).
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  /* Setup IN Data stage starts with DATA1 */
N  USB_EPData_Bit_TypeDef StartInStage = (ep->EP_WaitSetup ? USB_DATA_BIT_DATA1 : USB_DATA_BIT_TOGGLE);
N
N  /* Set EndPoint context */
N  ep->Buffer.IO_Buffer.pBuffer    = Buffer;
N  ep->Buffer.IO_Buffer.length     = Length;
N  ep->Buffer.IO_Buffer.bytesToAck = MAX_PACKET_SIZE;
X  ep->Buffer.IO_Buffer.bytesToAck = 32;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->InHandler                   = onInDone;
N  ep->EP_State                    = USB_EP_IN;
N
N  /* Send first data portion */
N  USB_EP_sendInDataPortion(EPx, StartInStage);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that we are willing to receive Length or more bytes of data
N  *         from the host to this EndPoint with OUT transaction(s).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer to place received data to.
N  *                 The total buffer size should be equal or greater then
N  *                 ((Length / MAX_PACKET_LENGTH) + 1) * MAX_PACKET_LENGTH)
N  *
N  * @param  Length: The minimal data length to receive before the transfer is
N  *                 treated as complete.
N  *
N  * @param  onOutDone: User's handler to be called after Length or more bytes of
N  *                    data is successfully received (may be 0).
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Set EndPoint context */
N  ep->Buffer.IO_Buffer.pBuffer    = Buffer;
N  ep->Buffer.IO_Buffer.length     = Length;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->OutHandler                  = onOutDone;
N  ep->EP_WaitOut                  = SET;
N
N  /* Start awaiting for OUT transaction */
N  USB_EP_Idle(EPx);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Indicates that we are willing to receive (repeatedly) Setup Control
N  *         Transactions with this EndPoint.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  USB_SetupPacket: Pointer to the user's buffer to place
N  *         received setup packet.
N  *
N  * @param  onSetupPacket: User's handler to be called when setup packet
N  *         is received.
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Set EndPoint context */
N  ep->Buffer.pSetupPacket         = USB_SetupPacket;
N  ep->Buffer.IO_Buffer.length     = 0;
N  ep->Buffer.IO_Buffer.bytesToAck = 0;
N  ep->Buffer.IO_Buffer.offset     = 0;
N  ep->SetupHandler                = onSetupPacket;
N  ep->EP_WaitSetup                = onSetupPacket ? SET : RESET;
N
N  /* Start awaiting for SETUP transaction */
N  USB_EP_Idle(EPx);
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  EndPoint state machine implementation.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  USB_IT: SLAVE controller interrupt flags (USB_SIS register value).
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function should be called at appropriate rate to handle possible
N  *         EndPoint events.
N  */
N
NUSB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT)
N{
N  FlagStatus nextIteration = RESET;
N  USB_Result result = USB_SUCCESS;
N  uint32_t tmpSTS, tmpTS, tmpCTRL;
N  uint32_t i, count;
N  USB_EPContext_TypeDef *ep;
N
N  tmpSTS = USB_GetSEPxSTS(EPx);
N  tmpTS  = (USB_GetSEPxTS(EPx) & USB_SEPx_TS_SCTTYPE_Msk);
X  tmpTS  = (USB_GetSEPxTS(EPx) & (uint32_t)(0x00000003));
N  tmpCTRL = USB_GetSEPxCTRL(EPx);
N
N  ep = USB_EPContext + EPx;
N
N  /* Remember SCDONE event in the EndPoint context */
N  if (USB_IT & USB_SIS_SCTDONE)
X  if (USB_IT & ((uint32_t)0x00000001))
N  {
N    ep->EP_WasScdone = SET;
N  }
N
N  do
N  {
N    switch (ep->EP_State)
N    {
N      /* USB_EP_NAK */
N      case USB_EP_NAK:
N      {
N        /* Fast return if EndPoint in the NAK state */
N        return USB_SUCCESS;
N      }
N
N      /* USB_EP_IDLE */
N      case USB_EP_IDLE:
N      {
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
X        if (!(tmpCTRL & ((uint32_t)0x00000002)) && ep->EP_WasScdone)
N        {
N          /* EPRDY dropped - event for this End Point */
N          if ((tmpTS == USB_SEPx_TS_SCTTYPE_Outdata) && ep->EP_WaitOut)
X          if ((tmpTS == (uint32_t)(0x00000002)) && ep->EP_WaitOut)
N          {
N            /* OUT transaction started: switch into the OUT state and continue processing there */
N            ep->EP_State = USB_EP_OUT;
N            ep->EP_WaitOut = RESET;
N            nextIteration = SET;
N          }
N          else if ((tmpTS == USB_SEPx_TS_SCTTYPE_Setup) && ep->EP_WaitSetup)
X          else if ((tmpTS == (uint32_t)(0x00000000)) && ep->EP_WaitSetup)
N          {
N            /* SETUP transaction started: switch into the SETUP state and continue processing there */
N            ep->EP_State = USB_EP_SETUP;
N            nextIteration = SET;
N          }
N          else
N          {
N            /* Unexpected transaction: switch into STALL/NAK state and return error */
N            result = USB_ERROR;
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_IN */
N      case USB_EP_IN:
N      {
N        /* Analyze event type */
N        if ((!(tmpCTRL & USB_SEP_CTRL_EPRDY)) && ep->EP_WasScdone &&
X        if ((!(tmpCTRL & ((uint32_t)0x00000002))) && ep->EP_WasScdone &&
N            (tmpTS == USB_SEPx_TS_SCTTYPE_In) && (tmpSTS & USB_SEP_STS_SCACKRXED))
X            (tmpTS == (uint32_t)(0x00000001)) && (tmpSTS & ((uint32_t)0x00000040)))
N        {
N          /* 1. ACK event */
N          ep->Buffer.IO_Buffer.offset += ep->Buffer.IO_Buffer.bytesToAck;
N          if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
N          {
N            /* If offset >= length (transfer is over), indicate it with NAK state
N             * and call handler (if present) */
N            ep->EP_State = USB_EP_NAK;
N            if (ep->InHandler != 0)
N            {
N              result = ep->InHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.length);
N            }
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_NAK)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else
N          {
N            /* If there is any data to send remaining, send next portion */
N            USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_TOGGLE);
N          }
N        }
N        else if (tmpSTS & (USB_SEP_STS_SCRXOF
X        else if (tmpSTS & (((uint32_t)0x00000004)
N                         | USB_SEP_STS_SCCRCERR
X                         | ((uint32_t)0x00000001)
N                         | USB_SEP_STS_SCBSERR
X                         | ((uint32_t)0x00000002)
N                         | USB_SEP_STS_SCRXTO))
X                         | ((uint32_t)0x00000008)))
N        {
N          /* 2. Error events - call error handler (if present). Switch temporarily to NAK
N           * to check if user orders another transaction */
N          ep->EP_State = USB_EP_NAK;
N          if (ep->ErrorHandler != 0)
N          {
N            result = ep->ErrorHandler(EPx, tmpSTS, tmpTS, tmpCTRL);
N          }
N          if (result == USB_SUCCESS)
N          {
N            if (ep->EP_State == USB_EP_NAK)
N            {
N              /* If there is no user's handler or USB_SUCCESS returned and no other transaction
N               * is started, retry with current data portion */
N              ep->EP_State = USB_EP_IN;
N              USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_KEEP);
N            }
N          }
N          else
N          {
N            /* If user's handler indicated error, go to STALL/NAK state */
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_OUT */
N      case USB_EP_OUT:
N      {
N        /* Check for event */
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
X        if (!(tmpCTRL & ((uint32_t)0x00000002)) && ep->EP_WasScdone)
N        {
N          nextIteration = RESET;
N
N          /* Read data packet */
N          count = USB_GetSEPxRXFDC(EPx);
N          for (i = 0; i < count; i++)
N          {
N            ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = EPx_RX_FIFO_DATA(EPx);
X            ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = USB_GetSEPxRXFD(EPx);
N          }
N          RX_FIFO_FORCE_EMPTY(EPx);
X          USB_SetSEPxRXFC(EPx, 1);
N          ep->Buffer.IO_Buffer.offset += count;
N
N          /* If offset >= length (transfer is over), indicate it with NAK state
N           * and call handler (if present) */
N          if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
N          {
N            ep->EP_State = USB_EP_NAK;
N            if (ep->OutHandler != 0)
N            {
N              result = ep->OutHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.offset);
N            }
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_NAK)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else
N          {
N            /* If offset < length, wait for another portion */
N            USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
X            USB_EP_SetReady(EPx, (uint32_t)(1 << 1));
N          }
N        }
N        break;
N      }
N
N      /* USB_EP_SETUP */
N      case USB_EP_SETUP:
N      {
N        /* Check for event */
N        if (ep->EP_WasScdone)
N        {
N          assert_param(ep->SetupHandler);
X          ((void)0);
N
N          /* Read setup packet and check for correct size (8 bytes) */
N          count = USB_GetSEPxRXFDC(EPx);
N          if (count == 8)
N          {
N            for (i = 0; i < count; i++)
N            {
N              ((uint8_t*)ep->Buffer.pSetupPacket)[i] = EPx_RX_FIFO_DATA(EPx);
X              ((uint8_t*)ep->Buffer.pSetupPacket)[i] = USB_GetSEPxRXFD(EPx);
N            }
N            RX_FIFO_FORCE_EMPTY(EPx);
X            USB_SetSEPxRXFC(EPx, 1);
N
N            /* Call the handler */
N            result = ep->SetupHandler(EPx, ep->Buffer.pSetupPacket);
N
N            if (result == USB_SUCCESS)
N            {
N              /* If no other transaction is ordered by user or no data stage of SETUP
N               * packet (state isn't changed), go to NAK/IDLE state */
N              if (ep->EP_State == USB_EP_SETUP)
N              {
N                USB_EP_Idle(EPx);
N              }
N            }
N            else
N            {
N              /* If user's handler indicated error, go to STALL/NAK state */
N              USB_EP_Stall(EPx, USB_STALL_PROTO);
N            }
N          }
N          else /* Incorrect packet size */
N          {
N            RX_FIFO_FORCE_EMPTY(EPx);
X            USB_SetSEPxRXFC(EPx, 1);
N            result = USB_ERROR;
N            /* Switch into STALL state */
N            USB_EP_Stall(EPx, USB_STALL_PROTO);
N          }
N        }
N        nextIteration = RESET;
N        break;
N      }
N
N      /* USB_EP_STALL */
N      case USB_EP_STALL:
N      {
N        if (!(tmpCTRL & USB_SEP_CTRL_EPRDY))
X        if (!(tmpCTRL & ((uint32_t)0x00000002)))
N        {
N          /* EPRDY dropped - event for this End Point */
N          if (ep->EP_Halt == USB_STALL_HALT)
N          {
N            USB_EP_Stall(EPx, USB_STALL_HALT);
N          }
N          else
N          {
N            USB_EP_Idle(EPx);
N          }
N        }
N        break;
N      }
N    }
N  } while (nextIteration);
N
N  return result;
N}
N
N/**
N  * @brief  Prepares EndPoint for IN transaction accepting (service function).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  DataBitChange: DATA bit handling.
N  *         This parameter can be one of the following values:
N  *           @arg USB_DATA_BIT_KEEP: Don't change DATA bit.
N  *           @arg USB_DATA_BIT_TOGGLE: Toggle DATA0/DATA1.
N  *           @arg USB_DATA_BIT_DATA1: Set DATA1.
N  *
N  * @retval USB_Result.
N  */
N
Nstatic void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N  uint32_t i, total;
N
N  assert_param(ep->EP_State == USB_EP_IN);
X  ((void)0);
N
N  /* Clean TX FIFO buffer */
N  TX_FIFO_FORCE_EMPTY(EPx);
X  USB_SetSEPxTXFDC(EPx, 1);
N
N  /* Adjust DATA bit */
N  switch (DataBitChange)
N  {
N    case USB_DATA_BIT_KEEP:
N      break;
N    case USB_DATA_BIT_TOGGLE:
N      USB_SEPxToggleEPDATASEQ(EPx);
N      break;
N    case USB_DATA_BIT_DATA1:
N      USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPDATASEQ_Data1);
X      USB_SetSEPxCTRL(EPx, (uint32_t)(1 << 2));
N      break;
N  }
N
N  /* Copy data portion into TX FIFO buffer */
N  total = (ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck < ep->Buffer.IO_Buffer.length ?
N            ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck : ep->Buffer.IO_Buffer.length);
N  for (i = ep->Buffer.IO_Buffer.offset; i < total; i++)
N  {
N    USB_SetSEPxTXFD(EPx, ep->Buffer.IO_Buffer.pBuffer[i]);
N  };
N
N  /* Set EPRDY bit */
N  USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
X  USB_EP_SetReady(EPx, (uint32_t)(1 << 1));
N}
N
N
N/**
N  * @brief  Sets EPRDY and STALL bits (service function).
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  val: Value for SEPxCTRL register.
N  *
N  * @retval USB_Result.
N  *
N  * @note   Before setting EPRDY, the function clears pending
N  *         bits (especially SCTDONE), to indicate that previous
N  *         transaction is complete.
N  */
N
Nstatic void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val)
N{
N  USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
N
N  /* Clear pending bits */
N  if (val & USB_SEPx_CTRL_EPRDY_Ready)
X  if (val & (uint32_t)(1 << 1))
N  {
N    USB_SetSIS(USB_SIS_Msk);
X    USB_SetSIS(((uint32_t)0x00000001) | ((uint32_t)0x00000002) | ((uint32_t)0x00000004) | ((uint32_t)0x00000008) | ((uint32_t)0x00000010));
N  }
N  ep->EP_WasScdone = RESET;
N
N  /* Set CTRL bits */
N  USB_SetSEPxCTRL(EPx, val);
N}
N
N/** @} */ /* End of group USB_EndPoint_Private_Functions */
N
N/** @} */ /* End of group USB_EndPoint_Private */
N
N/** @defgroup USB_Device_Private USB Device
N  * @{
N  */
N
N/** @defgroup USB_Device_Private_Types USB Device Private Types
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Types */
N
N/** @defgroup USB_Device_Private_Constants USB Device Private Constants
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Constants */
N
N/** @defgroup USB_Device_Private_Variables USB Device Private Variables
N  * @{
N  */
N
NUSB_SetupPacket_TypeDef USB_CurrentSetupPacket;
NUSB_DeviceContext_TypeDef USB_DeviceContext;
Nstatic uint8_t SetupPacketData[2];
N
N/** @} */ /* End of group USB_Device_Private_Variables */
N
N/** @defgroup USB_Device_Private_Macros USB Device Private Macros
N  * @{
N  */
N
N/** @} */ /* End of group USB_Device_Private_Macros */
N
N/** @defgroup USB_Device_Private_FunctionPrototypes USB Device Private Function Prototypes
N  * @{
N  */
N
Nstatic USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
N
N/** @} */ /* End of group USB_Device_Private_FunctionPrototypes */
N
N/** @defgroup USB_Device_Private_Functions USB Device Private Functions
N  * @{
N  */
N
N/**
N  * @brief  Initializes the USB peripheral according to the specified
N  *         parameters in the USB_Clock_InitStruct.
N  * @param  USB_Clock_InitStruct: pointer to a USB_Clock_TypeDef structure
N  *         that contains the configuration information for the USB Clock.
N  *
N  * @param  USB_DeviceBUSParam: pointer to a USB_DeviceBUSParam_TypeDef structure
N  *         that contains the configuration information for the USB BUS
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam)
N{
N  /* Check the parameters */
N  assert_param(IS_USB_PULL(USB_DeviceBUSParam.PULL));
X  ((void)0);
N  assert_param(IS_USB_SPEED(USB_DeviceBUSParam.SPEED));
X  ((void)0);
N  assert_param(IS_USB_MODE(USB_DeviceBUSParam.MODE));
X  ((void)0);
N
N  /* Set USB clocks perform controller reset */
N  USB_BRGInit(USB_Clock_InitStruct);
N  USB_Reset();
N  /* Set pulls and Device mode */
N  USB_SetHSCR(USB_HSCR_HOST_MODE_Device);
X  USB_SetHSCR((uint32_t)(1 << (0 + 16)));
N  USB_SetHSCR(USB_DeviceBUSParam->PULL);
N  /* Set speed, polarity and enable end points */
N  USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | USB_SC_SCGEN_Set);
X  USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | (uint32_t)(1 << 0));
N  /* Setup EP0 */
N  USB_EP_Init(USB_EP0, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1, 0);
X  USB_EP_Init(USB_EP0, (uint32_t)(1 << 0) | (uint32_t)(1 << 2), 0);
N  USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DEVICE_HANDLE_SETUP);
X  USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DeviceSetupPacket);
N
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
N  USB_DeviceContext.Address = 0;
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Enables the USB peripheral.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DevicePowerOn(void)
N{
N  USB_SetHSCR(USB_HSCR_EN_RX_Set | USB_HSCR_EN_TX_Set);
X  USB_SetHSCR((uint32_t)(1 << 3) | (uint32_t)(1 << 2));
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_POWERED;
N
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Disables the USB peripheral.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DevicePowerOff(void)
N{
N  USB_SetHSCR(USB_HSCR_EN_RX_Reset);
X  USB_SetHSCR((uint32_t)(1 << (3 + 16)));
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
N
N  return USB_SUCCESS;
N}
N
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S/**
S  * @brief  Initiates host remote wakeup
S  *
S  * @param  None
S  *
S  * @retval USB_Result.
S  */
S
SUSB_Result USB_DeviceRemoteWakeUp(void)
S{
S  return USB_SUCCESS;
S}
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N
N/** @defgroup USB_Device_Private_Handlers USB Device Handlers implementation
N  * @{
N  */
N
N/**
N  * @brief  Reset bus handler
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceReset(void)
N{
N  USB->SA=0;
X  ((USB_TypeDef *)0x40010000 )->SA=0;
N  USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_DEFAULT;
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Performs all necessary actions on entering to SUSPENDED state
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceSuspend(void)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Performs all necessary actions on exit from SUSPENDED state
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  */
N
NUSB_Result USB_DeviceResume(void)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  Control Setup Packet processing dispatcher (set as EP0 setup
N  *         packet handler).
N  *
N  * @param  EPx: USB Control EndPoint (EP0) number.
N  *
N  * @param  USB_SetupPacket: Pointer to a USB_SetupPacket_TypeDef structure
N  *         that contains received setup packet contents (on success)
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint setup packet handler
N  *         requirements. Request setup packet data is placed into
N  *         USB_CurrentSetupPacket variable to be accessible from the
N  *         specific request type handlers.
N  */
N
NUSB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket)
N{
N  USB_RequestType_TypeDef requestType;
N  USB_RequestTypeDT_TypeDef requestDirection;
N
N  USB_Result result = USB_SUCCESS;
N  uint16_t wValue, wIndex, wLength;
N
N  /* Check the parameters */
N  assert_param(IS_USB_ENDPOINT(EPx));
X  ((void)0);
N
N  /* Determine request type */
N  requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_TYPE_Msk);
X  requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x60);
N  requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_DT_Msk);
X  requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x80);
N
N  /* Process request */
N  switch (requestType)
N  {
N    /* Standard request */
N    case USB_TYPE_STANDARD: {
N      USB_RequestRecipient_TypeDef recipient;
N      USB_EP_IO_Handler statusAckHandler = 0;
N
N      wValue = USB_SetupPacket->wValue;
N      wIndex = USB_SetupPacket->wIndex;
N      wLength = USB_SetupPacket->wLength;
N
N      /* Recipient check */
N      recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_RECIPIENT_TYPE_Msk);
X      recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & 0x1F);
N      if (!IS_VALID_USB_RECIPIENT(recipient)) {
X      if (!((recipient) <= USB_RECIPIENT_OTHER)) {
N        result = USB_ERR_INV_REQ;
N        break;
N      }
N      /* Specific requests */
N      switch (USB_SetupPacket->bRequest)
N      {
N        /* GET_STATUS */
N        case USB_GET_STATUS:
N          if (requestDirection != USB_DEVICE_TO_HOST ||
N             (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            /* Give user a chance to set flags in the device context */
N            result = USB_DEVICE_HANDLE_GET_STATUS(recipient, wIndex);
X            result = USB_SUCCESS;
N            if (result == USB_SUCCESS)
N            {
N              switch (recipient)
N              {
N                /* Device - return Self Powered and Remote Wakeup status */
N                case USB_RECIPIENT_DEVICE:
N                  SetupPacketData[0] = 0
N#ifdef USB_SELF_POWERED_SUPPORTED
N                    | USB_DeviceContext.USB_DeviceStatus.SelfPowered
N#endif /* USB_SELF_POWERED_SUPPORTED */
N#ifdef USB_REMOTE_WAKEUP_SUPPORTED
S                    | (USB_DeviceContext.USB_DeviceStatus.RemoteWakeupEnabled << 1)
N#endif /* USB_REMOTE_WAKEUP_SUPPORTED */
N                    ;
N                  break;
N                /* Interface - return 0 */
N                case USB_RECIPIENT_INTERFACE:
N                  SetupPacketData[0] = 0;
N                  break;
N                /* Endpoint - return Halt status */
N                case USB_RECIPIENT_ENDPOINT:
N                  SetupPacketData[0] = USB_EPContext[wIndex].EP_Halt;
N                  break;
N              }
N              SetupPacketData[1] = 0;
N              result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
N            }
N          }
N          break;
N        /* CLEAR_FEATURE */
N        case USB_CLEAR_FEATURE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_CLEAR_FEATURE(recipient, wValue, wIndex);
X            result = USB_DeviceClearFeature(recipient, wValue, wIndex);
N          }
N          break;
N        /* SET_FEATURE */
N        case USB_SET_FEATURE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
N              (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_FEATURE(recipient, wValue, wIndex);
X            result = USB_DeviceSetFeature(recipient, wValue, wIndex);
N          }
N          break;
N        /* SET_ADDRESS */
N        case USB_SET_ADDRESS:
N          result = USB_DEVICE_HANDLE_SET_ADDRESS(wValue);
X          result = USB_SUCCESS;
N          /* Set special Status Stage handler that will actually change the address */
N          USB_DeviceContext.Address = wValue;
N          statusAckHandler = USB_Device_setAddressWork;
N          break;
N        /* GET_DESCRIPTOR */
N        case USB_GET_DESCRIPTOR:
N          result = USB_DEVICE_HANDLE_GET_DESCRIPTOR(wValue, wIndex, wLength);
X          result = USB_CDC_GetDescriptor(wValue, wIndex, wLength);
N          break;
N        /* SET_DESCRIPTOR */
N        case USB_SET_DESCRIPTOR:
N          result = USB_DEVICE_HANDLE_SET_DESCRIPTOR(wValue, wIndex, wLength);
X          result = USB_ERROR;
N          break;
N        /* GET_CONFIGURATION */
N        case USB_GET_CONFIGURATION:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            SetupPacketData[0] = 0;
N          }
N          else
N          {
N            SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_CONFIGURATION;
X            SetupPacketData[0] = (uint8_t)1;
N          }
N          result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
N          break;
N        /* SET_CONFIGURATION */
N        case USB_SET_CONFIGURATION:
N          if (wValue == 0)
N          {
N            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_ADDRESS;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_CONFIGURATION(wValue);
X            result = ((wValue) == 1 ? USB_SUCCESS : USB_ERROR);
N            if (result == USB_SUCCESS)
N            {
N              USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_CONFIGURED;
N            }
N          }
N          break;
N        /* GET_INTERFACE */
N        case USB_GET_INTERFACE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_INTERFACE(wIndex);
X            SetupPacketData[0] = (uint8_t)0;
N            result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
N          }
N          break;
N        /* SET_INTERFACE */
N        case USB_SET_INTERFACE:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SET_INTERFACE(wValue, wIndex);
X            result = ((wIndex) == 0 && (wValue) == 0 ? USB_SUCCESS : USB_ERROR);
N          }
N          break;
N        /* SYNCH_FRAME */
N        case USB_SYNCH_FRAME:
N          if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
N          {
N            result = USB_ERROR;
N          }
N          else
N          {
N            result = USB_DEVICE_HANDLE_SYNC_FRAME(wIndex, SetupPacketData);
X            result = USB_ERROR;
N            if (result == USB_SUCCESS)
N            {
N              result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
N            }
N          }
N          break;
N        default:
N          result = USB_ERR_INV_REQ;
N      }
N      /* If there were no DATA stage, initiate Status Stage (IN ACK) */
N      if (result == USB_SUCCESS && wLength == 0)
N      {
N        result = (USB_SetupPacket->mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
N                        USB_EP_doDataOut(EPx, 0, 0, statusAckHandler) :
N                        USB_EP_doDataIn(EPx, 0, 0, statusAckHandler);
N      }
N      break;
N    }
N    /* Class-specific request */
N    case USB_TYPE_CLASS:
N      result = USB_DEVICE_HANDLE_CLASS_REQUEST;
X      result = USB_CDC_ClassRequest();
N      break;
N    /* Vendor-specific request */
N    case USB_TYPE_VENDOR:
N      result = USB_DEVICE_HANDLE_VENDOR_REQUEST;
X      result = USB_ERROR;
N      break;
N    default:
N      result = USB_ERR_INV_REQ;
N  }
N  return result;
N}
N
N/** @} */ /* End of group USB_Device_Private_Handlers */
N
N/** @defgroup USB_Device_deviceSetupPacket_Handlers USB Device Standard Request specific handlers
N  * @{
N  */
N
N/**
N  * @brief  Called on CLEAR_FEATURE request (9.4.1).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wVALUE: Feature selector.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. This implementation
N  *         process ENDPOINT_HALT (calling USB_EP_Ready) and DEVICE_REMOTE_WAKEUP
N  *         (clearing RemoteWakeupEnabled context flag) standard features only.
N  */
N
NUSB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
N{
N  if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
N  {
N    return USB_EP_Idle((USB_EP_TypeDef)wINDEX);
N  }
N  else
N  {
N    return USB_ERROR;
N  }
N}
N
N/**
N  * @brief  Called on SET_FEATURE request (9.4.9).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wVALUE: Feature selector.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. This implementation
N  *         process ENDPOINT_HALT (calling USB_EP_Stall) and DEVICE_REMOTE_WAKEUP
N  *         (setting RemoteWakeupEnabled context flag) standard features only.
N  */
N
NUSB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
N{
N  if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
N  {
N    return USB_EP_Stall((USB_EP_TypeDef)wINDEX, USB_STALL_HALT);
N  }
N  else
N  {
N    return USB_ERROR;
N  }
N}
N
N/** @} */ /* End of group USB_Device_deviceSetupPacket_Handlers */
N
N/** @defgroup USB_Device_Status_Stage_Handlers USB Device Service Functions
N  * @{
N  */
N
N/**
N  * @brief Implements Status stage of Setup transaction with OUT data stage
N  *        or without data stage. To be used as EndPoint transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with portion of data
N  *                 to be sent
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
NUSB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief Implements Status stage of Setup transaction with IN data stage.
N  *        To be used as EndPoint transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer for next portion of data
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
NUSB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  return USB_EP_doDataOut(EPx, 0, 0, 0);
N}
N
N/**
N  * @brief Implements Status stage of Setup SET_ADDRESS transaction.
N  *        Actually changes the device address. To be used as EndPoint
N  *        transaction handler.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  Buffer: Pointer to the user's buffer with portion of data
N  *                 to be sent
N  *
N  * @param  Length: Length of data portion
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint data transmitting handler
N  *         requirements.
N  */
N
Nstatic USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
N{
N  /* Set address */
N  USB_SetSA(USB_DeviceContext.Address);
N  /* Adjust device state */
N  USB_DeviceContext.USB_DeviceState = (USB_DeviceContext.Address ? USB_DEV_STATE_ADDRESS : USB_DEV_STATE_DEFAULT);
N
N  return USB_SUCCESS;
N}
N
N/** @} */ /* End of group USB_Device_Status stage _Handlers */
N
N/**
N  * @brief  USB interrupt dispatcher, called from interrupt handler
N  *
N  * @param  USB_IT: SLAVE controller interrupt flags (USB_SIS register value).
N  *
N  * @retval USB_Result.
N  *
N  * @note   Handles common events (such as Reset) and calls USB_EP_setSetupHandler
N  *         for each EndPoint in use.
N  */
N
NUSB_Result USB_DeviceDispatchEvent(void)
N{
N  uint32_t i;
N  uint32_t USB_IT;
N  USB_Result result = USB_SUCCESS;
N  static volatile uint32_t bHandling = RESET;
N
N  /* Disable USB interrupts */
N#ifdef USB_INT_HANDLE_REQUIRED
N  NVIC_DisableIRQ(USB_IRQn);
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N  if (!bHandling) {
N    bHandling = SET;
N
N    /* Get masked interrupt flags */
N    USB_IT = USB_GetSIS();
N    /* Handle reset */
N    if (USB_IT & USB_SIS_SCRESETEV)
X    if (USB_IT & ((uint32_t)0x00000004))
N    {
N      result = USB_DeviceReset();
N    }
N
N    /* Invoke End Point dispatchers */
N    for (i = USB_EP0; i < Num_USB_EndPoints; i++)
N    {
N      USB_EP_dispatchEvent((USB_EP_TypeDef)i, USB_IT);
N    }
N
N    /* Clear pending bits, except for SCTDONE */
N    USB_SetSIS(USB_IT & (~USB_SIS_SCTDONE_Set));
X    USB_SetSIS(USB_IT & (~((uint32_t)0x00000001)));
N
N    bHandling = RESET;
N
N    /* Enable USB interrupts (only after the actual work is done) */
N#ifdef USB_INT_HANDLE_REQUIRED
N    NVIC_EnableIRQ(USB_IRQn);
N#endif /* USB_INT_HANDLE_REQUIRED */
N  }
N  return result;
N}
N
N#ifdef USB_INT_HANDLE_REQUIRED
N/**
N  * @brief  Default implementation of USB interrupt handler
N  *
N  * @param  None
N  *
N  * @retval None
N  *
N  * @note   To be overwritten, USB_INT_HANDLE_REQUIRED definition should be
N  *         undefined.
N  *
N  */
N
Nvoid USB_IRQHandler(void)
N{
N  USB_DeviceDispatchEvent();
N}
N#endif /* USB_INT_HANDLE_REQUIRED */
N
N
N/** @defgroup USB_Device_Private_Dummy_Functions USB Device Private Handler Samples
N  * @{
N  */
N
N/**
N  * @brief  GET_STATUS standard request handler sample (9.4.5).
N  *
N  * @param  Recipient: Recipient type (from setup packet header).
N  *         This parameter can be one of the following values:
N  *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
N  *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
N  *
N  * @param  wINDEX: Interface or EndPoint number, if Recipient has
N  *         appropriate value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   Intended to update USB_DeviceStatus field of the device context
N  *         before the status to be sent to host. Data stage begins if USB_SUCCESS
N  *         is returned.
N  */
N
NUSB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  SET_ADDRESS standard request handler (preparation) sample (9.4.6).
N  *
N  * @param  wVALUE: New device address
N  *
N  * @retval USB_Result.
N  *
N  * @note   Intended to do perform actions while still in setup transaction
N  *         (actual address change to be performed after status stage completes).
N  *         If value returned is not USB_SUCCESS, transaction is aborted.
N  */
N
NUSB_Result USB_DeviceDummySetAddress(uint16_t wVALUE)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  GET_DESCRIPTOR standard request handler sample (9.4.3).
N  *
N  * @param  wVALUE: Descriptor Type and Descriptor Index
N  *
N  * @param  wINDEX: Zero or Language ID (see 9.6.7)
N  *
N  * @param  wLENGTH: Amount of data host is willing to receive.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         in any device class. It is expected to either perform data transfer
N  *         and status stages on its own (calling USB_EP_doDataIn), or return
N  *         value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  SET_DESCRIPTOR standard request handler sample (9.4.8).
N  *
N  * @param  wVALUE: Descriptor Type and Descriptor Index
N  *
N  * @param  wINDEX: Zero or Language ID (see 9.6.7)
N  *
N  * @param  wLENGTH: Amount of data to be sent by host.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         only if the device supports descriptor update by host. It is expected
N  *         to either perform data transfer and status stages on its own (calling
N  *         USB_EP_doDataOut), or return value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  GET_CONFIGURATION standard request handler sample (9.4.2).
N  *
N  * @param  None
N  *
N  * @retval Currently selected configuration number or 0 on error.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports more than one configuration.
N  */
N
Nuint8_t USB_DeviceDummyGetConfiguration(void)
N{
N  return 1;
N}
N
N/**
N  * @brief  SET_CONFIGURATION standard request handler sample (9.4.7).
N  *
N  * @param  wVALUE: Configuration number
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports more than one configuration.
N  */
N
NUSB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  GET_INTERFACE standard request handler sample (9.4.4).
N  *
N  * @param  wINDEX: Interface number.
N  *
N  * @retval Currently selected alternate setting for the specified interface
N  *         or 0 in case of error.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports interfaces with alternate settings.
N  */
N
Nuint8_t USB_DeviceDummyGetInterface(uint16_t wINDEX)
N{
N  return 0;
N}
N
N/**
N  * @brief  SET_INTERFACE standard request handler sample (9.4.10).
N  *
N  * @param  wVALUE: Alternate setting to be set.
N  *
N  * @param  wINDEX: Interface number.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if the device supports interfaces with alternate settings.
N  */
N
NUSB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX)
N{
N  return USB_SUCCESS;
N}
N
N/**
N  * @brief  SYNC_FRAME standard request handler sample (9.4.11).
N  *
N  * @param  wINDEX: EndPoint number.
N  *
N  * @param  DATA: Pointer for frame number.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         if some of the device EndPoints support isochronous transfers. It is
N  *         expected to place EndPoint synchronization frame number into DATA pointed
N  *         location or return value that is not USB_SUCCESS.
N  */
N
NUSB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  Class-type setup request handler sample.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         the device supports any class-type requests. Request setup packet data
N  *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
N  *         should implement both data (if present) and status transfer stages.
N  */
N
NUSB_Result USB_DeviceDummyClassRequest(void)
N{
N  return USB_ERROR;
N}
N
N/**
N  * @brief  Vendor-type setup request handler sample.
N  *
N  * @param  None
N  *
N  * @retval USB_Result.
N  *
N  * @note   This handler is called in correct state only. It's to be implemented
N  *         the device supports any vendor-type requests. Request setup packet data
N  *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
N  *         should implement both data (if present) and status transfer stages.
N  */
N
N
NUSB_Result USB_DeviceDummyVendorRequest(void)
N{
N  return USB_ERROR;
N}
N
N
N/**
N  * @brief  EndPoint error handler sample.
N  *
N  * @param  EPx: USB EndPoint number.
N  *         This parameter can be one of the following values:
N  *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
N  *
N  * @param  STS: USB_SEPx.STS register value.
N  *
N  * @param  TS: USB_SEPx.TS register value.
N  *
N  * @param  CTRL: USB_SEPx.CTRL register value.
N  *
N  * @retval USB_Result.
N  *
N  * @note   This function interface reflects EndPoint error handler
N  *         requirements. When called on IN transaction error:
N  *          - if it hasn't start another transaction and returns USB_SUCCESS,
N  *            then retry of data transmission would occur;
N  *          - if it returns error code, EndPoint would be switched to
N  *            NAK/STALL state.
N  */
N
NUSB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL)
N{
N  return USB_ERROR;
N}
N
N/** @} */ /* End of group USB_Device_Private_Dummy_Functions */
N
N
N/** @} */ /* End of group USB_Device_Private_Functions */
N
N/** @} */ /* End of group USB_Device_Private */
N
N/** @} */ /* End of group USB */
N
N/** @} */ /* End of group 1986BE9x_StdPeriph_Driver */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE 1986BE9x_usb_device.c */
N

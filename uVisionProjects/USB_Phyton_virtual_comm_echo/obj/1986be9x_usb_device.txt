; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\1986be9x_usb_device.o --depend=.\obj\1986be9x_usb_device.d --cpu=Cortex-M1 --apcs=interwork -O0 -I.\inc -IC:\Keil4\ARM\INC -IC:\Keil4\ARM\INC\ARM --omf_browse=.\obj\1986be9x_usb_device.crf src\1986BE9x_usb_device.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USB_EP_Init PROC
;;;163    
;;;164    USB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError)
000000  b5f8              PUSH     {r3-r7,lr}
;;;165    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;166      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
000008  202c              MOVS     r0,#0x2c
00000a  4368              MULS     r0,r5,r0
00000c  49f9              LDR      r1,|L1.1012|
00000e  1844              ADDS     r4,r0,r1
;;;167    
;;;168      /* EndPoint context preparation */
;;;169      ep->Buffer.IO_Buffer.pBuffer    = 0;
000010  2000              MOVS     r0,#0
000012  6060              STR      r0,[r4,#4]
;;;170      ep->Buffer.IO_Buffer.length     = 0;
000014  2100              MOVS     r1,#0
000016  60a1              STR      r1,[r4,#8]
;;;171      ep->Buffer.IO_Buffer.bytesToAck = 0;
000018  6121              STR      r1,[r4,#0x10]
;;;172      ep->Buffer.IO_Buffer.offset     = 0;
00001a  60e1              STR      r1,[r4,#0xc]
;;;173      ep->Buffer.pSetupPacket         = 0;
00001c  6161              STR      r1,[r4,#0x14]
;;;174      ep->InHandler                   = 0;
00001e  61e0              STR      r0,[r4,#0x1c]
;;;175      ep->OutHandler                  = 0;
000020  6220              STR      r0,[r4,#0x20]
;;;176      ep->SetupHandler                = 0;
000022  6260              STR      r0,[r4,#0x24]
;;;177      ep->ErrorHandler                = onError;
000024  62a6              STR      r6,[r4,#0x28]
;;;178      ep->EP_Halt                     = USB_STALL_PROTO;
000026  7060              STRB     r0,[r4,#1]
;;;179      ep->EP_State                    = USB_EP_NAK;
000028  7020              STRB     r0,[r4,#0]
;;;180      ep->EP_WasScdone                = RESET;
00002a  7620              STRB     r0,[r4,#0x18]
;;;181    
;;;182      USB_SetSEPxCTRL(EPx, USB_EP_Ctrl);
00002c  4639              MOV      r1,r7
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       USB_SetSEPxCTRL
;;;183    
;;;184      return USB_SUCCESS;
000034  2000              MOVS     r0,#0
;;;185    }
000036  bdf8              POP      {r3-r7,pc}
;;;186    
                          ENDP

                  USB_EP_Reset PROC
;;;196    
;;;197    USB_Result USB_EP_Reset(USB_EP_TypeDef EPx)
000038  b570              PUSH     {r4-r6,lr}
;;;198    {
00003a  4604              MOV      r4,r0
;;;199      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00003c  202c              MOVS     r0,#0x2c
00003e  4360              MULS     r0,r4,r0
000040  49ec              LDR      r1,|L1.1012|
000042  1845              ADDS     r5,r0,r1
;;;200    
;;;201      ep->EP_State = USB_EP_NAK;
000044  2000              MOVS     r0,#0
000046  7028              STRB     r0,[r5,#0]
;;;202      ep->EP_WasScdone = RESET;
000048  7628              STRB     r0,[r5,#0x18]
;;;203    
;;;204      USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPISOEN_Reset  |                           /* Reset Isohronic */
00004a  49eb              LDR      r1,|L1.1016|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       USB_SetSEPxCTRL
;;;205                           USB_SEPx_CTRL_EPRDY_NotReady |                           /* Reset READY */
;;;206                           USB_SEPx_CTRL_EPEN_Enable);                              /* Set ENABLE */
;;;207    
;;;208      return USB_SUCCESS;
000052  2000              MOVS     r0,#0
;;;209    }
000054  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP

                  USB_EP_SetReady PROC
;;;733    
;;;734    static void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val)
000056  b570              PUSH     {r4-r6,lr}
;;;735    {
000058  4604              MOV      r4,r0
00005a  460d              MOV      r5,r1
;;;736      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00005c  202c              MOVS     r0,#0x2c
00005e  4360              MULS     r0,r4,r0
000060  49e4              LDR      r1,|L1.1012|
000062  1846              ADDS     r6,r0,r1
;;;737    
;;;738      /* Clear pending bits */
;;;739      if (val & USB_SEPx_CTRL_EPRDY_Ready)
000064  2002              MOVS     r0,#2
000066  4205              TST      r5,r0
000068  d002              BEQ      |L1.112|
;;;740      {
;;;741        USB_SetSIS(USB_SIS_Msk);
00006a  201f              MOVS     r0,#0x1f
00006c  f7fffffe          BL       USB_SetSIS
                  |L1.112|
;;;742      }
;;;743      ep->EP_WasScdone = RESET;
000070  2000              MOVS     r0,#0
000072  7630              STRB     r0,[r6,#0x18]
;;;744    
;;;745      /* Set CTRL bits */
;;;746      USB_SetSEPxCTRL(EPx, val);
000074  4629              MOV      r1,r5
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       USB_SetSEPxCTRL
;;;747    }
00007c  bd70              POP      {r4-r6,pc}
;;;748    
                          ENDP

                  USB_EP_Idle PROC
;;;223    
;;;224    USB_Result USB_EP_Idle(USB_EP_TypeDef EPx)
00007e  b570              PUSH     {r4-r6,lr}
;;;225    {
000080  4605              MOV      r5,r0
;;;226      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
000082  202c              MOVS     r0,#0x2c
000084  4368              MULS     r0,r5,r0
000086  49db              LDR      r1,|L1.1012|
000088  1844              ADDS     r4,r0,r1
;;;227      uint32_t val = USB_SEPx_CTRL_EPSSTALL_NotReply;                               /* Reset STALL reply */
00008a  2601              MOVS     r6,#1
00008c  04f6              LSLS     r6,r6,#19
;;;228    
;;;229      if (ep->EP_WaitOut || ep->EP_WaitSetup)
00008e  7e60              LDRB     r0,[r4,#0x19]
000090  2800              CMP      r0,#0
000092  d102              BNE      |L1.154|
000094  7ea0              LDRB     r0,[r4,#0x1a]
000096  2800              CMP      r0,#0
000098  d004              BEQ      |L1.164|
                  |L1.154|
;;;230      {
;;;231        ep->EP_State = USB_EP_IDLE;
00009a  2001              MOVS     r0,#1
00009c  7020              STRB     r0,[r4,#0]
;;;232        val |= USB_SEPx_CTRL_EPRDY_Ready;                                           /* Set READY */
00009e  2002              MOVS     r0,#2
0000a0  4306              ORRS     r6,r6,r0
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;233      }
;;;234      else
;;;235      {
;;;236        ep->EP_State = USB_EP_NAK;
0000a4  2000              MOVS     r0,#0
0000a6  7020              STRB     r0,[r4,#0]
                  |L1.168|
;;;237      }
;;;238      ep->EP_Halt = USB_STALL_PROTO;
0000a8  2000              MOVS     r0,#0
0000aa  7060              STRB     r0,[r4,#1]
;;;239    
;;;240      USB_EP_SetReady(EPx, val);
0000ac  4631              MOV      r1,r6
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       USB_EP_SetReady
;;;241    
;;;242      return USB_SUCCESS;
0000b4  2000              MOVS     r0,#0
;;;243    }
0000b6  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  USB_EP_Stall PROC
;;;261    
;;;262    USB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt)
0000b8  b5f8              PUSH     {r3-r7,lr}
;;;263    {
0000ba  4605              MOV      r5,r0
0000bc  460c              MOV      r4,r1
;;;264      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0000be  202c              MOVS     r0,#0x2c
0000c0  4368              MULS     r0,r5,r0
0000c2  49cc              LDR      r1,|L1.1012|
0000c4  1846              ADDS     r6,r0,r1
;;;265      uint32_t val = 0;
0000c6  2700              MOVS     r7,#0
;;;266    
;;;267      if (bHalt == USB_STALL_HALT && EPx == USB_EP0)
0000c8  2c01              CMP      r4,#1
0000ca  d103              BNE      |L1.212|
0000cc  2d00              CMP      r5,#0
0000ce  d101              BNE      |L1.212|
;;;268      {
;;;269        /* No functional stall for Default Control Pipe */
;;;270        return USB_ERROR;
0000d0  2001              MOVS     r0,#1
                  |L1.210|
;;;271      }
;;;272    
;;;273      if (bHalt == USB_STALL_HALT || ep->EP_WaitSetup)
;;;274      {
;;;275        ep->EP_Halt  = bHalt;
;;;276        ep->EP_State = USB_EP_STALL;
;;;277        val = USB_SEPx_CTRL_EPSSTALL_Reply |                                          /* Set STALL reply */
;;;278              USB_SEPx_CTRL_EPRDY_Ready;                                              /* Set READY */
;;;279      }
;;;280    
;;;281      USB_EP_SetReady(EPx, val);
;;;282    
;;;283      return USB_SUCCESS;
;;;284    }
0000d2  bdf8              POP      {r3-r7,pc}
                  |L1.212|
0000d4  2c01              CMP      r4,#1                 ;273
0000d6  d002              BEQ      |L1.222|
0000d8  7eb0              LDRB     r0,[r6,#0x1a]         ;273
0000da  2800              CMP      r0,#0                 ;273
0000dc  d003              BEQ      |L1.230|
                  |L1.222|
0000de  7074              STRB     r4,[r6,#1]            ;275
0000e0  2005              MOVS     r0,#5                 ;276
0000e2  7030              STRB     r0,[r6,#0]            ;276
0000e4  270a              MOVS     r7,#0xa               ;277
                  |L1.230|
0000e6  4639              MOV      r1,r7                 ;281
0000e8  4628              MOV      r0,r5                 ;281
0000ea  f7fffffe          BL       USB_EP_SetReady
0000ee  2000              MOVS     r0,#0                 ;283
0000f0  e7ef              B        |L1.210|
;;;285    
                          ENDP

                  USB_EP_sendInDataPortion PROC
;;;681    
;;;682    static void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange)
0000f2  b5f8              PUSH     {r3-r7,lr}
;;;683    {
0000f4  4606              MOV      r6,r0
0000f6  460f              MOV      r7,r1
;;;684      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0000f8  202c              MOVS     r0,#0x2c
0000fa  4370              MULS     r0,r6,r0
0000fc  49bd              LDR      r1,|L1.1012|
0000fe  1844              ADDS     r4,r0,r1
;;;685      uint32_t i, total;
;;;686    
;;;687      assert_param(ep->EP_State == USB_EP_IN);
;;;688    
;;;689      /* Clean TX FIFO buffer */
;;;690      TX_FIFO_FORCE_EMPTY(EPx);
000100  2101              MOVS     r1,#1
000102  4630              MOV      r0,r6
000104  f7fffffe          BL       USB_SetSEPxTXFDC
;;;691    
;;;692      /* Adjust DATA bit */
;;;693      switch (DataBitChange)
000108  2f00              CMP      r7,#0
00010a  d004              BEQ      |L1.278|
00010c  2f01              CMP      r7,#1
00010e  d003              BEQ      |L1.280|
000110  2f02              CMP      r7,#2
000112  d10a              BNE      |L1.298|
000114  e004              B        |L1.288|
                  |L1.278|
;;;694      {
;;;695        case USB_DATA_BIT_KEEP:
;;;696          break;
000116  e008              B        |L1.298|
                  |L1.280|
;;;697        case USB_DATA_BIT_TOGGLE:
;;;698          USB_SEPxToggleEPDATASEQ(EPx);
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       USB_SEPxToggleEPDATASEQ
;;;699          break;
00011e  e004              B        |L1.298|
                  |L1.288|
;;;700        case USB_DATA_BIT_DATA1:
;;;701          USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPDATASEQ_Data1);
000120  2104              MOVS     r1,#4
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       USB_SetSEPxCTRL
;;;702          break;
000128  bf00              NOP      
                  |L1.298|
00012a  bf00              NOP                            ;696
;;;703      }
;;;704    
;;;705      /* Copy data portion into TX FIFO buffer */
;;;706      total = (ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck < ep->Buffer.IO_Buffer.length ?
00012c  68e1              LDR      r1,[r4,#0xc]
00012e  6920              LDR      r0,[r4,#0x10]
000130  1809              ADDS     r1,r1,r0
000132  68a0              LDR      r0,[r4,#8]
000134  4281              CMP      r1,r0
000136  d203              BCS      |L1.320|
;;;707                ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck : ep->Buffer.IO_Buffer.length);
000138  68e1              LDR      r1,[r4,#0xc]
00013a  6920              LDR      r0,[r4,#0x10]
00013c  1808              ADDS     r0,r1,r0
00013e  e000              B        |L1.322|
                  |L1.320|
000140  68a0              LDR      r0,[r4,#8]
                  |L1.322|
000142  9000              STR      r0,[sp,#0]
;;;708      for (i = ep->Buffer.IO_Buffer.offset; i < total; i++)
000144  68e5              LDR      r5,[r4,#0xc]
000146  e005              B        |L1.340|
                  |L1.328|
;;;709      {
;;;710        USB_SetSEPxTXFD(EPx, ep->Buffer.IO_Buffer.pBuffer[i]);
000148  6860              LDR      r0,[r4,#4]
00014a  5d41              LDRB     r1,[r0,r5]
00014c  4630              MOV      r0,r6
00014e  f7fffffe          BL       USB_SetSEPxTXFD
000152  1c6d              ADDS     r5,r5,#1              ;708
                  |L1.340|
000154  9800              LDR      r0,[sp,#0]            ;708
000156  4285              CMP      r5,r0                 ;708
000158  d3f6              BCC      |L1.328|
;;;711      };
;;;712    
;;;713      /* Set EPRDY bit */
;;;714      USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
00015a  2102              MOVS     r1,#2
00015c  4630              MOV      r0,r6
00015e  f7fffffe          BL       USB_EP_SetReady
;;;715    }
000162  bdf8              POP      {r3-r7,pc}
;;;716    
                          ENDP

                  USB_EP_doDataIn PROC
;;;303    
;;;304    USB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone)
000164  b5ff              PUSH     {r0-r7,lr}
;;;305    {
000166  b081              SUB      sp,sp,#4
000168  4605              MOV      r5,r0
00016a  460e              MOV      r6,r1
00016c  4617              MOV      r7,r2
;;;306      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00016e  202c              MOVS     r0,#0x2c
000170  4368              MULS     r0,r5,r0
000172  49a0              LDR      r1,|L1.1012|
000174  1844              ADDS     r4,r0,r1
;;;307      /* Setup IN Data stage starts with DATA1 */
;;;308      USB_EPData_Bit_TypeDef StartInStage = (ep->EP_WaitSetup ? USB_DATA_BIT_DATA1 : USB_DATA_BIT_TOGGLE);
000176  7ea0              LDRB     r0,[r4,#0x1a]
000178  2800              CMP      r0,#0
00017a  d001              BEQ      |L1.384|
00017c  2002              MOVS     r0,#2
00017e  e000              B        |L1.386|
                  |L1.384|
000180  2001              MOVS     r0,#1
                  |L1.386|
000182  b2c0              UXTB     r0,r0
000184  9000              STR      r0,[sp,#0]
;;;309    
;;;310      /* Set EndPoint context */
;;;311      ep->Buffer.IO_Buffer.pBuffer    = Buffer;
000186  6066              STR      r6,[r4,#4]
;;;312      ep->Buffer.IO_Buffer.length     = Length;
000188  60a7              STR      r7,[r4,#8]
;;;313      ep->Buffer.IO_Buffer.bytesToAck = MAX_PACKET_SIZE;
00018a  2120              MOVS     r1,#0x20
00018c  6121              STR      r1,[r4,#0x10]
;;;314      ep->Buffer.IO_Buffer.offset     = 0;
00018e  2100              MOVS     r1,#0
000190  60e1              STR      r1,[r4,#0xc]
;;;315      ep->InHandler                   = onInDone;
000192  9804              LDR      r0,[sp,#0x10]
000194  61e0              STR      r0,[r4,#0x1c]
;;;316      ep->EP_State                    = USB_EP_IN;
000196  2002              MOVS     r0,#2
000198  7020              STRB     r0,[r4,#0]
;;;317    
;;;318      /* Send first data portion */
;;;319      USB_EP_sendInDataPortion(EPx, StartInStage);
00019a  4628              MOV      r0,r5
00019c  9900              LDR      r1,[sp,#0]
00019e  f7fffffe          BL       USB_EP_sendInDataPortion
;;;320    
;;;321      return USB_SUCCESS;
0001a2  2000              MOVS     r0,#0
;;;322    }
0001a4  b005              ADD      sp,sp,#0x14
0001a6  bdf0              POP      {r4-r7,pc}
;;;323    
                          ENDP

                  USB_EP_doDataOut PROC
;;;344    
;;;345    USB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone)
0001a8  b5ff              PUSH     {r0-r7,lr}
;;;346    {
0001aa  b081              SUB      sp,sp,#4
0001ac  4605              MOV      r5,r0
0001ae  460e              MOV      r6,r1
0001b0  4617              MOV      r7,r2
;;;347      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0001b2  202c              MOVS     r0,#0x2c
0001b4  4368              MULS     r0,r5,r0
0001b6  498f              LDR      r1,|L1.1012|
0001b8  1844              ADDS     r4,r0,r1
;;;348    
;;;349      /* Set EndPoint context */
;;;350      ep->Buffer.IO_Buffer.pBuffer    = Buffer;
0001ba  6066              STR      r6,[r4,#4]
;;;351      ep->Buffer.IO_Buffer.length     = Length;
0001bc  60a7              STR      r7,[r4,#8]
;;;352      ep->Buffer.IO_Buffer.bytesToAck = 0;
0001be  2100              MOVS     r1,#0
0001c0  6121              STR      r1,[r4,#0x10]
;;;353      ep->Buffer.IO_Buffer.offset     = 0;
0001c2  60e1              STR      r1,[r4,#0xc]
;;;354      ep->OutHandler                  = onOutDone;
0001c4  9804              LDR      r0,[sp,#0x10]
0001c6  6220              STR      r0,[r4,#0x20]
;;;355      ep->EP_WaitOut                  = SET;
0001c8  2001              MOVS     r0,#1
0001ca  7660              STRB     r0,[r4,#0x19]
;;;356    
;;;357      /* Start awaiting for OUT transaction */
;;;358      USB_EP_Idle(EPx);
0001cc  4628              MOV      r0,r5
0001ce  f7fffffe          BL       USB_EP_Idle
;;;359    
;;;360      return USB_SUCCESS;
0001d2  2000              MOVS     r0,#0
;;;361    }
0001d4  b005              ADD      sp,sp,#0x14
0001d6  bdf0              POP      {r4-r7,pc}
;;;362    
                          ENDP

                  USB_EP_setSetupHandler PROC
;;;379    
;;;380    USB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket)
0001d8  b5f8              PUSH     {r3-r7,lr}
;;;381    {
0001da  4606              MOV      r6,r0
0001dc  460f              MOV      r7,r1
0001de  4615              MOV      r5,r2
;;;382      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0001e0  202c              MOVS     r0,#0x2c
0001e2  4370              MULS     r0,r6,r0
0001e4  4983              LDR      r1,|L1.1012|
0001e6  1844              ADDS     r4,r0,r1
;;;383    
;;;384      /* Set EndPoint context */
;;;385      ep->Buffer.pSetupPacket         = USB_SetupPacket;
0001e8  6167              STR      r7,[r4,#0x14]
;;;386      ep->Buffer.IO_Buffer.length     = 0;
0001ea  2100              MOVS     r1,#0
0001ec  60a1              STR      r1,[r4,#8]
;;;387      ep->Buffer.IO_Buffer.bytesToAck = 0;
0001ee  6121              STR      r1,[r4,#0x10]
;;;388      ep->Buffer.IO_Buffer.offset     = 0;
0001f0  60e1              STR      r1,[r4,#0xc]
;;;389      ep->SetupHandler                = onSetupPacket;
0001f2  6265              STR      r5,[r4,#0x24]
;;;390      ep->EP_WaitSetup                = onSetupPacket ? SET : RESET;
0001f4  2d00              CMP      r5,#0
0001f6  d001              BEQ      |L1.508|
0001f8  2001              MOVS     r0,#1
0001fa  e000              B        |L1.510|
                  |L1.508|
0001fc  2000              MOVS     r0,#0
                  |L1.510|
0001fe  76a0              STRB     r0,[r4,#0x1a]
;;;391    
;;;392      /* Start awaiting for SETUP transaction */
;;;393      USB_EP_Idle(EPx);
000200  4630              MOV      r0,r6
000202  f7fffffe          BL       USB_EP_Idle
;;;394    
;;;395      return USB_SUCCESS;
000206  2000              MOVS     r0,#0
;;;396    }
000208  bdf8              POP      {r3-r7,pc}
;;;397    
                          ENDP

                  USB_EP_dispatchEvent PROC
;;;412    
;;;413    USB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT)
00020a  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;414    {
00020c  b085              SUB      sp,sp,#0x14
;;;415      FlagStatus nextIteration = RESET;
00020e  2000              MOVS     r0,#0
000210  9004              STR      r0,[sp,#0x10]
;;;416      USB_Result result = USB_SUCCESS;
000212  2700              MOVS     r7,#0
;;;417      uint32_t tmpSTS, tmpTS, tmpCTRL;
;;;418      uint32_t i, count;
;;;419      USB_EPContext_TypeDef *ep;
;;;420    
;;;421      tmpSTS = USB_GetSEPxSTS(EPx);
000214  9805              LDR      r0,[sp,#0x14]
000216  f7fffffe          BL       USB_GetSEPxSTS
00021a  9003              STR      r0,[sp,#0xc]
;;;422      tmpTS  = (USB_GetSEPxTS(EPx) & USB_SEPx_TS_SCTTYPE_Msk);
00021c  9805              LDR      r0,[sp,#0x14]
00021e  f7fffffe          BL       USB_GetSEPxTS
000222  0780              LSLS     r0,r0,#30
000224  0f80              LSRS     r0,r0,#30
000226  9002              STR      r0,[sp,#8]
;;;423      tmpCTRL = USB_GetSEPxCTRL(EPx);
000228  9805              LDR      r0,[sp,#0x14]
00022a  f7fffffe          BL       USB_GetSEPxCTRL
00022e  9001              STR      r0,[sp,#4]
;;;424    
;;;425      ep = USB_EPContext + EPx;
000230  212c              MOVS     r1,#0x2c
000232  9805              LDR      r0,[sp,#0x14]
000234  4348              MULS     r0,r1,r0
000236  496f              LDR      r1,|L1.1012|
000238  1844              ADDS     r4,r0,r1
;;;426    
;;;427      /* Remember SCDONE event in the EndPoint context */
;;;428      if (USB_IT & USB_SIS_SCTDONE)
00023a  9806              LDR      r0,[sp,#0x18]
00023c  07c0              LSLS     r0,r0,#31
00023e  0fc0              LSRS     r0,r0,#31
000240  d001              BEQ      |L1.582|
;;;429      {
;;;430        ep->EP_WasScdone = SET;
000242  2001              MOVS     r0,#1
000244  7620              STRB     r0,[r4,#0x18]
                  |L1.582|
;;;431      }
;;;432    
;;;433      do
000246  bf00              NOP      
                  |L1.584|
;;;434      {
;;;435        switch (ep->EP_State)
000248  7823              LDRB     r3,[r4,#0]
00024a  f7fffffe          BL       __ARM_common_switch8
00024e  0604              DCB      0x06,0x04
000250  072c81c6          DCB      0x07,0x2c,0x81,0xc6
000254  f32b              DCB      0xf3,0x2b
;;;436        {
;;;437          /* USB_EP_NAK */
;;;438          case USB_EP_NAK:
;;;439          {
;;;440            /* Fast return if EndPoint in the NAK state */
;;;441            return USB_SUCCESS;
000256  2000              MOVS     r0,#0
                  |L1.600|
;;;442          }
;;;443    
;;;444          /* USB_EP_IDLE */
;;;445          case USB_EP_IDLE:
;;;446          {
;;;447            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
;;;448            {
;;;449              /* EPRDY dropped - event for this End Point */
;;;450              if ((tmpTS == USB_SEPx_TS_SCTTYPE_Outdata) && ep->EP_WaitOut)
;;;451              {
;;;452                /* OUT transaction started: switch into the OUT state and continue processing there */
;;;453                ep->EP_State = USB_EP_OUT;
;;;454                ep->EP_WaitOut = RESET;
;;;455                nextIteration = SET;
;;;456              }
;;;457              else if ((tmpTS == USB_SEPx_TS_SCTTYPE_Setup) && ep->EP_WaitSetup)
;;;458              {
;;;459                /* SETUP transaction started: switch into the SETUP state and continue processing there */
;;;460                ep->EP_State = USB_EP_SETUP;
;;;461                nextIteration = SET;
;;;462              }
;;;463              else
;;;464              {
;;;465                /* Unexpected transaction: switch into STALL/NAK state and return error */
;;;466                result = USB_ERROR;
;;;467                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;468              }
;;;469            }
;;;470            break;
;;;471          }
;;;472    
;;;473          /* USB_EP_IN */
;;;474          case USB_EP_IN:
;;;475          {
;;;476            /* Analyze event type */
;;;477            if ((!(tmpCTRL & USB_SEP_CTRL_EPRDY)) && ep->EP_WasScdone &&
;;;478                (tmpTS == USB_SEPx_TS_SCTTYPE_In) && (tmpSTS & USB_SEP_STS_SCACKRXED))
;;;479            {
;;;480              /* 1. ACK event */
;;;481              ep->Buffer.IO_Buffer.offset += ep->Buffer.IO_Buffer.bytesToAck;
;;;482              if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
;;;483              {
;;;484                /* If offset >= length (transfer is over), indicate it with NAK state
;;;485                 * and call handler (if present) */
;;;486                ep->EP_State = USB_EP_NAK;
;;;487                if (ep->InHandler != 0)
;;;488                {
;;;489                  result = ep->InHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.length);
;;;490                }
;;;491    
;;;492                if (result == USB_SUCCESS)
;;;493                {
;;;494                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;495                   * packet (state isn't changed), go to NAK/IDLE state */
;;;496                  if (ep->EP_State == USB_EP_NAK)
;;;497                  {
;;;498                    USB_EP_Idle(EPx);
;;;499                  }
;;;500                }
;;;501                else
;;;502                {
;;;503                  /* If user's handler indicated error, go to STALL/NAK state */
;;;504                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;505                }
;;;506              }
;;;507              else
;;;508              {
;;;509                /* If there is any data to send remaining, send next portion */
;;;510                USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_TOGGLE);
;;;511              }
;;;512            }
;;;513            else if (tmpSTS & (USB_SEP_STS_SCRXOF
;;;514                             | USB_SEP_STS_SCCRCERR
;;;515                             | USB_SEP_STS_SCBSERR
;;;516                             | USB_SEP_STS_SCRXTO))
;;;517            {
;;;518              /* 2. Error events - call error handler (if present). Switch temporarily to NAK
;;;519               * to check if user orders another transaction */
;;;520              ep->EP_State = USB_EP_NAK;
;;;521              if (ep->ErrorHandler != 0)
;;;522              {
;;;523                result = ep->ErrorHandler(EPx, tmpSTS, tmpTS, tmpCTRL);
;;;524              }
;;;525              if (result == USB_SUCCESS)
;;;526              {
;;;527                if (ep->EP_State == USB_EP_NAK)
;;;528                {
;;;529                  /* If there is no user's handler or USB_SUCCESS returned and no other transaction
;;;530                   * is started, retry with current data portion */
;;;531                  ep->EP_State = USB_EP_IN;
;;;532                  USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_KEEP);
;;;533                }
;;;534              }
;;;535              else
;;;536              {
;;;537                /* If user's handler indicated error, go to STALL/NAK state */
;;;538                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;539              }
;;;540            }
;;;541            break;
;;;542          }
;;;543    
;;;544          /* USB_EP_OUT */
;;;545          case USB_EP_OUT:
;;;546          {
;;;547            /* Check for event */
;;;548            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
;;;549            {
;;;550              nextIteration = RESET;
;;;551    
;;;552              /* Read data packet */
;;;553              count = USB_GetSEPxRXFDC(EPx);
;;;554              for (i = 0; i < count; i++)
;;;555              {
;;;556                ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = EPx_RX_FIFO_DATA(EPx);
;;;557              }
;;;558              RX_FIFO_FORCE_EMPTY(EPx);
;;;559              ep->Buffer.IO_Buffer.offset += count;
;;;560    
;;;561              /* If offset >= length (transfer is over), indicate it with NAK state
;;;562               * and call handler (if present) */
;;;563              if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
;;;564              {
;;;565                ep->EP_State = USB_EP_NAK;
;;;566                if (ep->OutHandler != 0)
;;;567                {
;;;568                  result = ep->OutHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.offset);
;;;569                }
;;;570    
;;;571                if (result == USB_SUCCESS)
;;;572                {
;;;573                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;574                   * packet (state isn't changed), go to NAK/IDLE state */
;;;575                  if (ep->EP_State == USB_EP_NAK)
;;;576                  {
;;;577                    USB_EP_Idle(EPx);
;;;578                  }
;;;579                }
;;;580                else
;;;581                {
;;;582                  /* If user's handler indicated error, go to STALL/NAK state */
;;;583                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;584                }
;;;585              }
;;;586              else
;;;587              {
;;;588                /* If offset < length, wait for another portion */
;;;589                USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
;;;590              }
;;;591            }
;;;592            break;
;;;593          }
;;;594    
;;;595          /* USB_EP_SETUP */
;;;596          case USB_EP_SETUP:
;;;597          {
;;;598            /* Check for event */
;;;599            if (ep->EP_WasScdone)
;;;600            {
;;;601              assert_param(ep->SetupHandler);
;;;602    
;;;603              /* Read setup packet and check for correct size (8 bytes) */
;;;604              count = USB_GetSEPxRXFDC(EPx);
;;;605              if (count == 8)
;;;606              {
;;;607                for (i = 0; i < count; i++)
;;;608                {
;;;609                  ((uint8_t*)ep->Buffer.pSetupPacket)[i] = EPx_RX_FIFO_DATA(EPx);
;;;610                }
;;;611                RX_FIFO_FORCE_EMPTY(EPx);
;;;612    
;;;613                /* Call the handler */
;;;614                result = ep->SetupHandler(EPx, ep->Buffer.pSetupPacket);
;;;615    
;;;616                if (result == USB_SUCCESS)
;;;617                {
;;;618                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;619                   * packet (state isn't changed), go to NAK/IDLE state */
;;;620                  if (ep->EP_State == USB_EP_SETUP)
;;;621                  {
;;;622                    USB_EP_Idle(EPx);
;;;623                  }
;;;624                }
;;;625                else
;;;626                {
;;;627                  /* If user's handler indicated error, go to STALL/NAK state */
;;;628                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;629                }
;;;630              }
;;;631              else /* Incorrect packet size */
;;;632              {
;;;633                RX_FIFO_FORCE_EMPTY(EPx);
;;;634                result = USB_ERROR;
;;;635                /* Switch into STALL state */
;;;636                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;637              }
;;;638            }
;;;639            nextIteration = RESET;
;;;640            break;
;;;641          }
;;;642    
;;;643          /* USB_EP_STALL */
;;;644          case USB_EP_STALL:
;;;645          {
;;;646            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY))
;;;647            {
;;;648              /* EPRDY dropped - event for this End Point */
;;;649              if (ep->EP_Halt == USB_STALL_HALT)
;;;650              {
;;;651                USB_EP_Stall(EPx, USB_STALL_HALT);
;;;652              }
;;;653              else
;;;654              {
;;;655                USB_EP_Idle(EPx);
;;;656              }
;;;657            }
;;;658            break;
;;;659          }
;;;660        }
;;;661      } while (nextIteration);
;;;662    
;;;663      return result;
;;;664    }
000258  b007              ADD      sp,sp,#0x1c
00025a  bdf0              POP      {r4-r7,pc}
00025c  2102              MOVS     r1,#2                 ;447
00025e  9801              LDR      r0,[sp,#4]            ;447
000260  4208              TST      r0,r1                 ;447
000262  d11f              BNE      |L1.676|
000264  7e20              LDRB     r0,[r4,#0x18]         ;447
000266  2800              CMP      r0,#0                 ;447
000268  d01c              BEQ      |L1.676|
00026a  9802              LDR      r0,[sp,#8]            ;450
00026c  2802              CMP      r0,#2                 ;450
00026e  d109              BNE      |L1.644|
000270  7e60              LDRB     r0,[r4,#0x19]         ;450
000272  2800              CMP      r0,#0                 ;450
000274  d006              BEQ      |L1.644|
000276  2003              MOVS     r0,#3                 ;453
000278  7020              STRB     r0,[r4,#0]            ;453
00027a  2000              MOVS     r0,#0                 ;454
00027c  7660              STRB     r0,[r4,#0x19]         ;454
00027e  2001              MOVS     r0,#1                 ;455
000280  9004              STR      r0,[sp,#0x10]         ;455
000282  e00f              B        |L1.676|
                  |L1.644|
000284  9802              LDR      r0,[sp,#8]            ;457
000286  2800              CMP      r0,#0                 ;457
000288  d107              BNE      |L1.666|
00028a  7ea0              LDRB     r0,[r4,#0x1a]         ;457
00028c  2800              CMP      r0,#0                 ;457
00028e  d004              BEQ      |L1.666|
000290  2004              MOVS     r0,#4                 ;460
000292  7020              STRB     r0,[r4,#0]            ;460
000294  2001              MOVS     r0,#1                 ;461
000296  9004              STR      r0,[sp,#0x10]         ;461
000298  e004              B        |L1.676|
                  |L1.666|
00029a  2701              MOVS     r7,#1                 ;466
00029c  2100              MOVS     r1,#0                 ;467
00029e  9805              LDR      r0,[sp,#0x14]         ;467
0002a0  f7fffffe          BL       USB_EP_Stall
                  |L1.676|
0002a4  e0e8              B        |L1.1144|
0002a6  2102              MOVS     r1,#2                 ;477
0002a8  9801              LDR      r0,[sp,#4]            ;477
0002aa  4208              TST      r0,r1                 ;477
0002ac  d12f              BNE      |L1.782|
0002ae  7e20              LDRB     r0,[r4,#0x18]         ;477
0002b0  2800              CMP      r0,#0                 ;477
0002b2  d02c              BEQ      |L1.782|
0002b4  9802              LDR      r0,[sp,#8]            ;478
0002b6  2801              CMP      r0,#1                 ;478
0002b8  d129              BNE      |L1.782|
0002ba  2140              MOVS     r1,#0x40              ;478
0002bc  9803              LDR      r0,[sp,#0xc]          ;478
0002be  4208              TST      r0,r1                 ;478
0002c0  d025              BEQ      |L1.782|
0002c2  68e1              LDR      r1,[r4,#0xc]          ;481
0002c4  6920              LDR      r0,[r4,#0x10]         ;481
0002c6  1809              ADDS     r1,r1,r0              ;481
0002c8  60e1              STR      r1,[r4,#0xc]          ;481
0002ca  68e1              LDR      r1,[r4,#0xc]          ;482
0002cc  68a0              LDR      r0,[r4,#8]            ;482
0002ce  4281              CMP      r1,r0                 ;482
0002d0  d318              BCC      |L1.772|
0002d2  2000              MOVS     r0,#0                 ;486
0002d4  7020              STRB     r0,[r4,#0]            ;486
0002d6  69e0              LDR      r0,[r4,#0x1c]         ;487
0002d8  2800              CMP      r0,#0                 ;487
0002da  d005              BEQ      |L1.744|
0002dc  69e3              LDR      r3,[r4,#0x1c]         ;489
0002de  68a2              LDR      r2,[r4,#8]            ;489
0002e0  6861              LDR      r1,[r4,#4]            ;489
0002e2  9805              LDR      r0,[sp,#0x14]         ;489
0002e4  4798              BLX      r3                    ;489
0002e6  4607              MOV      r7,r0                 ;489
                  |L1.744|
0002e8  2f00              CMP      r7,#0                 ;492
0002ea  d106              BNE      |L1.762|
0002ec  7820              LDRB     r0,[r4,#0]            ;496
0002ee  2800              CMP      r0,#0                 ;496
0002f0  d12d              BNE      |L1.846|
0002f2  9805              LDR      r0,[sp,#0x14]         ;498
0002f4  f7fffffe          BL       USB_EP_Idle
0002f8  e029              B        |L1.846|
                  |L1.762|
0002fa  2100              MOVS     r1,#0                 ;504
0002fc  9805              LDR      r0,[sp,#0x14]         ;504
0002fe  f7fffffe          BL       USB_EP_Stall
000302  e024              B        |L1.846|
                  |L1.772|
000304  2101              MOVS     r1,#1                 ;510
000306  9805              LDR      r0,[sp,#0x14]         ;510
000308  f7fffffe          BL       USB_EP_sendInDataPortion
00030c  e01f              B        |L1.846|
                  |L1.782|
00030e  9803              LDR      r0,[sp,#0xc]          ;513
000310  0700              LSLS     r0,r0,#28             ;513
000312  0f00              LSRS     r0,r0,#28             ;513
000314  d01b              BEQ      |L1.846|
000316  2000              MOVS     r0,#0                 ;520
000318  7020              STRB     r0,[r4,#0]            ;520
00031a  6aa0              LDR      r0,[r4,#0x28]         ;521
00031c  2800              CMP      r0,#0                 ;521
00031e  d006              BEQ      |L1.814|
000320  6aa6              LDR      r6,[r4,#0x28]         ;523
000322  9b01              LDR      r3,[sp,#4]            ;523
000324  9a02              LDR      r2,[sp,#8]            ;523
000326  9903              LDR      r1,[sp,#0xc]          ;523
000328  9805              LDR      r0,[sp,#0x14]         ;523
00032a  47b0              BLX      r6                    ;523
00032c  4607              MOV      r7,r0                 ;523
                  |L1.814|
00032e  2f00              CMP      r7,#0                 ;525
000330  d109              BNE      |L1.838|
000332  7820              LDRB     r0,[r4,#0]            ;527
000334  2800              CMP      r0,#0                 ;527
000336  d10a              BNE      |L1.846|
000338  2002              MOVS     r0,#2                 ;531
00033a  7020              STRB     r0,[r4,#0]            ;531
00033c  2100              MOVS     r1,#0                 ;532
00033e  9805              LDR      r0,[sp,#0x14]         ;532
000340  f7fffffe          BL       USB_EP_sendInDataPortion
000344  e003              B        |L1.846|
                  |L1.838|
000346  2100              MOVS     r1,#0                 ;538
000348  9805              LDR      r0,[sp,#0x14]         ;538
00034a  f7fffffe          BL       USB_EP_Stall
                  |L1.846|
00034e  e093              B        |L1.1144|
000350  2102              MOVS     r1,#2                 ;548
000352  9801              LDR      r0,[sp,#4]            ;548
000354  4208              TST      r0,r1                 ;548
000356  d13f              BNE      |L1.984|
000358  7e20              LDRB     r0,[r4,#0x18]         ;548
00035a  2800              CMP      r0,#0                 ;548
00035c  d03c              BEQ      |L1.984|
00035e  2000              MOVS     r0,#0                 ;550
000360  9004              STR      r0,[sp,#0x10]         ;550
000362  9805              LDR      r0,[sp,#0x14]         ;553
000364  f7fffffe          BL       USB_GetSEPxRXFDC
000368  9000              STR      r0,[sp,#0]            ;553
00036a  2500              MOVS     r5,#0                 ;554
00036c  e008              B        |L1.896|
                  |L1.878|
00036e  9805              LDR      r0,[sp,#0x14]         ;556
000370  f7fffffe          BL       USB_GetSEPxRXFD
000374  b2c1              UXTB     r1,r0                 ;556
000376  68e0              LDR      r0,[r4,#0xc]          ;556
000378  1940              ADDS     r0,r0,r5              ;556
00037a  6862              LDR      r2,[r4,#4]            ;556
00037c  5411              STRB     r1,[r2,r0]            ;556
00037e  1c6d              ADDS     r5,r5,#1              ;554
                  |L1.896|
000380  9800              LDR      r0,[sp,#0]            ;554
000382  4285              CMP      r5,r0                 ;554
000384  d3f3              BCC      |L1.878|
000386  2101              MOVS     r1,#1                 ;558
000388  9805              LDR      r0,[sp,#0x14]         ;558
00038a  f7fffffe          BL       USB_SetSEPxRXFC
00038e  68e1              LDR      r1,[r4,#0xc]          ;559
000390  9800              LDR      r0,[sp,#0]            ;559
000392  1809              ADDS     r1,r1,r0              ;559
000394  60e1              STR      r1,[r4,#0xc]          ;559
000396  68e1              LDR      r1,[r4,#0xc]          ;563
000398  68a0              LDR      r0,[r4,#8]            ;563
00039a  4281              CMP      r1,r0                 ;563
00039c  d318              BCC      |L1.976|
00039e  2000              MOVS     r0,#0                 ;565
0003a0  7020              STRB     r0,[r4,#0]            ;565
0003a2  6a20              LDR      r0,[r4,#0x20]         ;566
0003a4  2800              CMP      r0,#0                 ;566
0003a6  d005              BEQ      |L1.948|
0003a8  6a23              LDR      r3,[r4,#0x20]         ;568
0003aa  68e2              LDR      r2,[r4,#0xc]          ;568
0003ac  6861              LDR      r1,[r4,#4]            ;568
0003ae  9805              LDR      r0,[sp,#0x14]         ;568
0003b0  4798              BLX      r3                    ;568
0003b2  4607              MOV      r7,r0                 ;568
                  |L1.948|
0003b4  2f00              CMP      r7,#0                 ;571
0003b6  d106              BNE      |L1.966|
0003b8  7820              LDRB     r0,[r4,#0]            ;575
0003ba  2800              CMP      r0,#0                 ;575
0003bc  d10c              BNE      |L1.984|
0003be  9805              LDR      r0,[sp,#0x14]         ;577
0003c0  f7fffffe          BL       USB_EP_Idle
0003c4  e008              B        |L1.984|
                  |L1.966|
0003c6  2100              MOVS     r1,#0                 ;583
0003c8  9805              LDR      r0,[sp,#0x14]         ;583
0003ca  f7fffffe          BL       USB_EP_Stall
0003ce  e003              B        |L1.984|
                  |L1.976|
0003d0  2102              MOVS     r1,#2                 ;589
0003d2  9805              LDR      r0,[sp,#0x14]         ;589
0003d4  f7fffffe          BL       USB_EP_SetReady
                  |L1.984|
0003d8  e04e              B        |L1.1144|
0003da  7e20              LDRB     r0,[r4,#0x18]         ;599
0003dc  2800              CMP      r0,#0                 ;599
0003de  d038              BEQ      |L1.1106|
0003e0  9805              LDR      r0,[sp,#0x14]         ;604
0003e2  f7fffffe          BL       USB_GetSEPxRXFDC
0003e6  9000              STR      r0,[sp,#0]            ;604
0003e8  9800              LDR      r0,[sp,#0]            ;605
0003ea  2808              CMP      r0,#8                 ;605
0003ec  d128              BNE      |L1.1088|
0003ee  2500              MOVS     r5,#0                 ;607
0003f0  e00b              B        |L1.1034|
0003f2  0000              DCW      0x0000
                  |L1.1012|
                          DCD      USB_EPContext
                  |L1.1016|
                          DCD      0x00120001
                  |L1.1020|
0003fc  9805              LDR      r0,[sp,#0x14]         ;609
0003fe  f7fffffe          BL       USB_GetSEPxRXFD
000402  b2c1              UXTB     r1,r0                 ;609
000404  6960              LDR      r0,[r4,#0x14]         ;609
000406  5541              STRB     r1,[r0,r5]            ;609
000408  1c6d              ADDS     r5,r5,#1              ;607
                  |L1.1034|
00040a  9800              LDR      r0,[sp,#0]            ;607
00040c  4285              CMP      r5,r0                 ;607
00040e  d3f5              BCC      |L1.1020|
000410  2101              MOVS     r1,#1                 ;611
000412  9805              LDR      r0,[sp,#0x14]         ;611
000414  f7fffffe          BL       USB_SetSEPxRXFC
000418  6a62              LDR      r2,[r4,#0x24]         ;614
00041a  6961              LDR      r1,[r4,#0x14]         ;614
00041c  9805              LDR      r0,[sp,#0x14]         ;614
00041e  4790              BLX      r2                    ;614
000420  4607              MOV      r7,r0                 ;614
000422  2f00              CMP      r7,#0                 ;616
000424  d107              BNE      |L1.1078|
000426  7820              LDRB     r0,[r4,#0]            ;620
000428  2804              CMP      r0,#4                 ;620
00042a  d112              BNE      |L1.1106|
00042c  9805              LDR      r0,[sp,#0x14]         ;622
00042e  f7fffffe          BL       USB_EP_Idle
000432  e00e              B        |L1.1106|
000434  e010              B        |L1.1112|
                  |L1.1078|
000436  2100              MOVS     r1,#0                 ;628
000438  9805              LDR      r0,[sp,#0x14]         ;628
00043a  f7fffffe          BL       USB_EP_Stall
00043e  e008              B        |L1.1106|
                  |L1.1088|
000440  2101              MOVS     r1,#1                 ;633
000442  9805              LDR      r0,[sp,#0x14]         ;633
000444  f7fffffe          BL       USB_SetSEPxRXFC
000448  2701              MOVS     r7,#1                 ;634
00044a  2100              MOVS     r1,#0                 ;636
00044c  9805              LDR      r0,[sp,#0x14]         ;636
00044e  f7fffffe          BL       USB_EP_Stall
                  |L1.1106|
000452  2000              MOVS     r0,#0                 ;639
000454  9004              STR      r0,[sp,#0x10]         ;639
000456  e00f              B        |L1.1144|
                  |L1.1112|
000458  2102              MOVS     r1,#2                 ;646
00045a  9801              LDR      r0,[sp,#4]            ;646
00045c  4208              TST      r0,r1                 ;646
00045e  d10a              BNE      |L1.1142|
000460  7860              LDRB     r0,[r4,#1]            ;649
000462  2801              CMP      r0,#1                 ;649
000464  d104              BNE      |L1.1136|
000466  2101              MOVS     r1,#1                 ;651
000468  9805              LDR      r0,[sp,#0x14]         ;651
00046a  f7fffffe          BL       USB_EP_Stall
00046e  e002              B        |L1.1142|
                  |L1.1136|
000470  9805              LDR      r0,[sp,#0x14]         ;655
000472  f7fffffe          BL       USB_EP_Idle
                  |L1.1142|
000476  bf00              NOP                            ;658
                  |L1.1144|
000478  bf00              NOP                            ;470
00047a  9804              LDR      r0,[sp,#0x10]         ;661
00047c  2800              CMP      r0,#0                 ;661
00047e  d000              BEQ      |L1.1154|
000480  e6e2              B        |L1.584|
                  |L1.1154|
000482  4638              MOV      r0,r7                 ;663
000484  e6e8              B        |L1.600|
;;;665    
                          ENDP

                  USB_Device_setAddressWork PROC
;;;1292   
;;;1293   static USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000486  b570              PUSH     {r4-r6,lr}
;;;1294   {
000488  4604              MOV      r4,r0
00048a  460d              MOV      r5,r1
00048c  4616              MOV      r6,r2
;;;1295     /* Set address */
;;;1296     USB_SetSA(USB_DeviceContext.Address);
00048e  49f8              LDR      r1,|L1.2160|
000490  6848              LDR      r0,[r1,#4]  ; USB_DeviceContext
000492  f7fffffe          BL       USB_SetSA
;;;1297     /* Adjust device state */
;;;1298     USB_DeviceContext.USB_DeviceState = (USB_DeviceContext.Address ? USB_DEV_STATE_ADDRESS : USB_DEV_STATE_DEFAULT);
000496  48f6              LDR      r0,|L1.2160|
000498  6840              LDR      r0,[r0,#4]  ; USB_DeviceContext
00049a  2800              CMP      r0,#0
00049c  d001              BEQ      |L1.1186|
00049e  2004              MOVS     r0,#4
0004a0  e000              B        |L1.1188|
                  |L1.1186|
0004a2  2003              MOVS     r0,#3
                  |L1.1188|
0004a4  49f2              LDR      r1,|L1.2160|
0004a6  7008              STRB     r0,[r1,#0]
;;;1299   
;;;1300     return USB_SUCCESS;
0004a8  2000              MOVS     r0,#0
;;;1301   }
0004aa  bd70              POP      {r4-r6,pc}
;;;1302   
                          ENDP

                  USB_DeviceSetFeature PROC
;;;1207   
;;;1208   USB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
0004ac  b570              PUSH     {r4-r6,lr}
;;;1209   {
0004ae  4604              MOV      r4,r0
0004b0  460d              MOV      r5,r1
0004b2  4616              MOV      r6,r2
;;;1210     if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
0004b4  2c02              CMP      r4,#2
0004b6  d106              BNE      |L1.1222|
0004b8  2d00              CMP      r5,#0
0004ba  d104              BNE      |L1.1222|
;;;1211     {
;;;1212       return USB_EP_Stall((USB_EP_TypeDef)wINDEX, USB_STALL_HALT);
0004bc  b2f0              UXTB     r0,r6
0004be  2101              MOVS     r1,#1
0004c0  f7fffffe          BL       USB_EP_Stall
                  |L1.1220|
;;;1213     }
;;;1214     else
;;;1215     {
;;;1216       return USB_ERROR;
;;;1217     }
;;;1218   }
0004c4  bd70              POP      {r4-r6,pc}
                  |L1.1222|
0004c6  2001              MOVS     r0,#1                 ;1216
0004c8  e7fc              B        |L1.1220|
;;;1219   
                          ENDP

                  USB_DeviceClearFeature PROC
;;;1175   
;;;1176   USB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
0004ca  b570              PUSH     {r4-r6,lr}
;;;1177   {
0004cc  4604              MOV      r4,r0
0004ce  460d              MOV      r5,r1
0004d0  4616              MOV      r6,r2
;;;1178     if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
0004d2  2c02              CMP      r4,#2
0004d4  d105              BNE      |L1.1250|
0004d6  2d00              CMP      r5,#0
0004d8  d103              BNE      |L1.1250|
;;;1179     {
;;;1180       return USB_EP_Idle((USB_EP_TypeDef)wINDEX);
0004da  b2f0              UXTB     r0,r6
0004dc  f7fffffe          BL       USB_EP_Idle
                  |L1.1248|
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       return USB_ERROR;
;;;1185     }
;;;1186   }
0004e0  bd70              POP      {r4-r6,pc}
                  |L1.1250|
0004e2  2001              MOVS     r0,#1                 ;1184
0004e4  e7fc              B        |L1.1248|
;;;1187   
                          ENDP

                  USB_DeviceSetupPacket PROC
;;;942    
;;;943    USB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket)
0004e6  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;944    {
0004e8  b085              SUB      sp,sp,#0x14
0004ea  460c              MOV      r4,r1
;;;945      USB_RequestType_TypeDef requestType;
;;;946      USB_RequestTypeDT_TypeDef requestDirection;
;;;947    
;;;948      USB_Result result = USB_SUCCESS;
0004ec  2000              MOVS     r0,#0
0004ee  9002              STR      r0,[sp,#8]
;;;949      uint16_t wValue, wIndex, wLength;
;;;950    
;;;951      /* Check the parameters */
;;;952      assert_param(IS_USB_ENDPOINT(EPx));
;;;953    
;;;954      /* Determine request type */
;;;955      requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_TYPE_Msk);
0004f0  7820              LDRB     r0,[r4,#0]
0004f2  2160              MOVS     r1,#0x60
0004f4  4008              ANDS     r0,r0,r1
0004f6  9004              STR      r0,[sp,#0x10]
;;;956      requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_DT_Msk);
0004f8  7820              LDRB     r0,[r4,#0]
0004fa  2180              MOVS     r1,#0x80
0004fc  4008              ANDS     r0,r0,r1
0004fe  9003              STR      r0,[sp,#0xc]
;;;957    
;;;958      /* Process request */
;;;959      switch (requestType)
000500  9804              LDR      r0,[sp,#0x10]
000502  2800              CMP      r0,#0
000504  d004              BEQ      |L1.1296|
000506  2820              CMP      r0,#0x20
000508  d074              BEQ      |L1.1524|
00050a  2840              CMP      r0,#0x40
00050c  d173              BNE      |L1.1526|
00050e  e10b              B        |L1.1832|
                  |L1.1296|
;;;960      {
;;;961        /* Standard request */
;;;962        case USB_TYPE_STANDARD: {
;;;963          USB_RequestRecipient_TypeDef recipient;
;;;964          USB_EP_IO_Handler statusAckHandler = 0;
000510  2000              MOVS     r0,#0
000512  9000              STR      r0,[sp,#0]
;;;965    
;;;966          wValue = USB_SetupPacket->wValue;
000514  8867              LDRH     r7,[r4,#2]
;;;967          wIndex = USB_SetupPacket->wIndex;
000516  88a6              LDRH     r6,[r4,#4]
;;;968          wLength = USB_SetupPacket->wLength;
000518  88e0              LDRH     r0,[r4,#6]
00051a  9001              STR      r0,[sp,#4]
;;;969    
;;;970          /* Recipient check */
;;;971          recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_RECIPIENT_TYPE_Msk);
00051c  7820              LDRB     r0,[r4,#0]
00051e  06c5              LSLS     r5,r0,#27
000520  0eed              LSRS     r5,r5,#27
;;;972          if (!IS_VALID_USB_RECIPIENT(recipient)) {
000522  2d03              CMP      r5,#3
000524  dd02              BLE      |L1.1324|
;;;973            result = USB_ERR_INV_REQ;
000526  2002              MOVS     r0,#2
000528  9002              STR      r0,[sp,#8]
;;;974            break;
00052a  e103              B        |L1.1844|
                  |L1.1324|
;;;975          }
;;;976          /* Specific requests */
;;;977          switch (USB_SetupPacket->bRequest)
00052c  7863              LDRB     r3,[r4,#1]
00052e  f7fffffe          BL       __ARM_common_switch8
000532  0d08              DCB      0x0d,0x08
000534  40d854d8          DCB      0x40,0xd8,0x54,0xd8
000538  6a71787b          DCB      0x6a,0x71,0x78,0x7b
00053c  8ea2b3c4          DCB      0x8e,0xa2,0xb3,0xc4
000540  d800              DCB      0xd8,0x00
;;;978          {
;;;979            /* GET_STATUS */
;;;980            case USB_GET_STATUS:
;;;981              if (requestDirection != USB_DEVICE_TO_HOST ||
000542  9803              LDR      r0,[sp,#0xc]
000544  2880              CMP      r0,#0x80
000546  d109              BNE      |L1.1372|
;;;982                 (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
000548  48c9              LDR      r0,|L1.2160|
00054a  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
00054c  2804              CMP      r0,#4
00054e  d108              BNE      |L1.1378|
000550  2d01              CMP      r5,#1
000552  d003              BEQ      |L1.1372|
;;;983                  recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
000554  2d02              CMP      r5,#2
000556  d104              BNE      |L1.1378|
000558  2e04              CMP      r6,#4
00055a  db02              BLT      |L1.1378|
                  |L1.1372|
;;;984              {
;;;985                result = USB_ERROR;
00055c  2001              MOVS     r0,#1
00055e  9002              STR      r0,[sp,#8]
000560  e026              B        |L1.1456|
                  |L1.1378|
;;;986              }
;;;987              else
;;;988              {
;;;989                /* Give user a chance to set flags in the device context */
;;;990                result = USB_DEVICE_HANDLE_GET_STATUS(recipient, wIndex);
000562  2000              MOVS     r0,#0
000564  9002              STR      r0,[sp,#8]
;;;991                if (result == USB_SUCCESS)
000566  9802              LDR      r0,[sp,#8]
000568  2800              CMP      r0,#0
00056a  d121              BNE      |L1.1456|
;;;992                {
;;;993                  switch (recipient)
00056c  2d00              CMP      r5,#0
00056e  d004              BEQ      |L1.1402|
000570  2d01              CMP      r5,#1
000572  d007              BEQ      |L1.1412|
000574  2d02              CMP      r5,#2
000576  d111              BNE      |L1.1436|
000578  e008              B        |L1.1420|
                  |L1.1402|
;;;994                  {
;;;995                    /* Device - return Self Powered and Remote Wakeup status */
;;;996                    case USB_RECIPIENT_DEVICE:
;;;997                      SetupPacketData[0] = 0
00057a  48bd              LDR      r0,|L1.2160|
00057c  7840              LDRB     r0,[r0,#1]  ; USB_DeviceContext
00057e  49bd              LDR      r1,|L1.2164|
000580  7008              STRB     r0,[r1,#0]
;;;998    #ifdef USB_SELF_POWERED_SUPPORTED
;;;999                        | USB_DeviceContext.USB_DeviceStatus.SelfPowered
;;;1000   #endif /* USB_SELF_POWERED_SUPPORTED */
;;;1001   #ifdef USB_REMOTE_WAKEUP_SUPPORTED
;;;1002                       | (USB_DeviceContext.USB_DeviceStatus.RemoteWakeupEnabled << 1)
;;;1003   #endif /* USB_REMOTE_WAKEUP_SUPPORTED */
;;;1004                       ;
;;;1005                     break;
000582  e00b              B        |L1.1436|
                  |L1.1412|
;;;1006                   /* Interface - return 0 */
;;;1007                   case USB_RECIPIENT_INTERFACE:
;;;1008                     SetupPacketData[0] = 0;
000584  2000              MOVS     r0,#0
000586  49bb              LDR      r1,|L1.2164|
000588  7008              STRB     r0,[r1,#0]
;;;1009                     break;
00058a  e007              B        |L1.1436|
                  |L1.1420|
;;;1010                   /* Endpoint - return Halt status */
;;;1011                   case USB_RECIPIENT_ENDPOINT:
;;;1012                     SetupPacketData[0] = USB_EPContext[wIndex].EP_Halt;
00058c  202c              MOVS     r0,#0x2c
00058e  4370              MULS     r0,r6,r0
000590  49b9              LDR      r1,|L1.2168|
000592  1840              ADDS     r0,r0,r1
000594  7840              LDRB     r0,[r0,#1]
000596  49b7              LDR      r1,|L1.2164|
000598  7008              STRB     r0,[r1,#0]
;;;1013                     break;
00059a  bf00              NOP      
                  |L1.1436|
00059c  bf00              NOP                            ;1005
;;;1014                 }
;;;1015                 SetupPacketData[1] = 0;
00059e  2000              MOVS     r0,#0
0005a0  49b4              LDR      r1,|L1.2164|
0005a2  7048              STRB     r0,[r1,#1]
;;;1016                 result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
0005a4  2300              MOVS     r3,#0
0005a6  2202              MOVS     r2,#2
0005a8  9805              LDR      r0,[sp,#0x14]
0005aa  f7fffffe          BL       USB_EP_doDataIn
0005ae  9002              STR      r0,[sp,#8]
                  |L1.1456|
;;;1017               }
;;;1018             }
;;;1019             break;
0005b0  e09a              B        |L1.1768|
;;;1020           /* CLEAR_FEATURE */
;;;1021           case USB_CLEAR_FEATURE:
;;;1022             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
0005b2  48af              LDR      r0,|L1.2160|
0005b4  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0005b6  2804              CMP      r0,#4
0005b8  d108              BNE      |L1.1484|
0005ba  2d01              CMP      r5,#1
0005bc  d003              BEQ      |L1.1478|
;;;1023                 (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
0005be  2d02              CMP      r5,#2
0005c0  d104              BNE      |L1.1484|
0005c2  2e04              CMP      r6,#4
0005c4  db02              BLT      |L1.1484|
                  |L1.1478|
;;;1024             {
;;;1025               result = USB_ERROR;
0005c6  2001              MOVS     r0,#1
0005c8  9002              STR      r0,[sp,#8]
0005ca  e005              B        |L1.1496|
                  |L1.1484|
;;;1026             }
;;;1027             else
;;;1028             {
;;;1029               result = USB_DEVICE_HANDLE_CLEAR_FEATURE(recipient, wValue, wIndex);
0005cc  4632              MOV      r2,r6
0005ce  4639              MOV      r1,r7
0005d0  4628              MOV      r0,r5
0005d2  f7fffffe          BL       USB_DeviceClearFeature
0005d6  9002              STR      r0,[sp,#8]
                  |L1.1496|
;;;1030             }
;;;1031             break;
0005d8  e086              B        |L1.1768|
;;;1032           /* SET_FEATURE */
;;;1033           case USB_SET_FEATURE:
;;;1034             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
0005da  48a5              LDR      r0,|L1.2160|
0005dc  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0005de  2804              CMP      r0,#4
0005e0  d10a              BNE      |L1.1528|
0005e2  2d01              CMP      r5,#1
0005e4  d003              BEQ      |L1.1518|
;;;1035                 (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
0005e6  2d02              CMP      r5,#2
0005e8  d106              BNE      |L1.1528|
0005ea  2e04              CMP      r6,#4
0005ec  db04              BLT      |L1.1528|
                  |L1.1518|
;;;1036             {
;;;1037               result = USB_ERROR;
0005ee  2001              MOVS     r0,#1
0005f0  9002              STR      r0,[sp,#8]
0005f2  e007              B        |L1.1540|
                  |L1.1524|
0005f4  e094              B        |L1.1824|
                  |L1.1526|
0005f6  e09a              B        |L1.1838|
                  |L1.1528|
;;;1038             }
;;;1039             else
;;;1040             {
;;;1041               result = USB_DEVICE_HANDLE_SET_FEATURE(recipient, wValue, wIndex);
0005f8  4632              MOV      r2,r6
0005fa  4639              MOV      r1,r7
0005fc  4628              MOV      r0,r5
0005fe  f7fffffe          BL       USB_DeviceSetFeature
000602  9002              STR      r0,[sp,#8]
                  |L1.1540|
;;;1042             }
;;;1043             break;
000604  e070              B        |L1.1768|
;;;1044           /* SET_ADDRESS */
;;;1045           case USB_SET_ADDRESS:
;;;1046             result = USB_DEVICE_HANDLE_SET_ADDRESS(wValue);
000606  2000              MOVS     r0,#0
000608  9002              STR      r0,[sp,#8]
;;;1047             /* Set special Status Stage handler that will actually change the address */
;;;1048             USB_DeviceContext.Address = wValue;
00060a  4899              LDR      r0,|L1.2160|
00060c  6047              STR      r7,[r0,#4]  ; USB_DeviceContext
;;;1049             statusAckHandler = USB_Device_setAddressWork;
00060e  489b              LDR      r0,|L1.2172|
000610  9000              STR      r0,[sp,#0]
;;;1050             break;
000612  e069              B        |L1.1768|
;;;1051           /* GET_DESCRIPTOR */
;;;1052           case USB_GET_DESCRIPTOR:
;;;1053             result = USB_DEVICE_HANDLE_GET_DESCRIPTOR(wValue, wIndex, wLength);
000614  4631              MOV      r1,r6
000616  4638              MOV      r0,r7
000618  9a01              LDR      r2,[sp,#4]
00061a  f7fffffe          BL       USB_CDC_GetDescriptor
00061e  9002              STR      r0,[sp,#8]
;;;1054             break;
000620  e062              B        |L1.1768|
;;;1055           /* SET_DESCRIPTOR */
;;;1056           case USB_SET_DESCRIPTOR:
;;;1057             result = USB_DEVICE_HANDLE_SET_DESCRIPTOR(wValue, wIndex, wLength);
000622  2001              MOVS     r0,#1
000624  9002              STR      r0,[sp,#8]
;;;1058             break;
000626  e05f              B        |L1.1768|
;;;1059           /* GET_CONFIGURATION */
;;;1060           case USB_GET_CONFIGURATION:
;;;1061             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
000628  4891              LDR      r0,|L1.2160|
00062a  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
00062c  2804              CMP      r0,#4
00062e  d103              BNE      |L1.1592|
;;;1062             {
;;;1063               SetupPacketData[0] = 0;
000630  2000              MOVS     r0,#0
000632  4990              LDR      r1,|L1.2164|
000634  7008              STRB     r0,[r1,#0]
000636  e002              B        |L1.1598|
                  |L1.1592|
;;;1064             }
;;;1065             else
;;;1066             {
;;;1067               SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_CONFIGURATION;
000638  2001              MOVS     r0,#1
00063a  498e              LDR      r1,|L1.2164|
00063c  7008              STRB     r0,[r1,#0]
                  |L1.1598|
;;;1068             }
;;;1069             result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
00063e  2300              MOVS     r3,#0
000640  2201              MOVS     r2,#1
000642  498c              LDR      r1,|L1.2164|
000644  9805              LDR      r0,[sp,#0x14]
000646  f7fffffe          BL       USB_EP_doDataIn
00064a  9002              STR      r0,[sp,#8]
;;;1070             break;
00064c  e04c              B        |L1.1768|
;;;1071           /* SET_CONFIGURATION */
;;;1072           case USB_SET_CONFIGURATION:
;;;1073             if (wValue == 0)
00064e  2f00              CMP      r7,#0
000650  d103              BNE      |L1.1626|
;;;1074             {
;;;1075               USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_ADDRESS;
000652  2004              MOVS     r0,#4
000654  4986              LDR      r1,|L1.2160|
000656  7008              STRB     r0,[r1,#0]
000658  e00c              B        |L1.1652|
                  |L1.1626|
;;;1076             }
;;;1077             else
;;;1078             {
;;;1079               result = USB_DEVICE_HANDLE_SET_CONFIGURATION(wValue);
00065a  2f01              CMP      r7,#1
00065c  d001              BEQ      |L1.1634|
00065e  2001              MOVS     r0,#1
000660  e000              B        |L1.1636|
                  |L1.1634|
000662  2000              MOVS     r0,#0
                  |L1.1636|
000664  b280              UXTH     r0,r0
000666  9002              STR      r0,[sp,#8]
;;;1080               if (result == USB_SUCCESS)
000668  9802              LDR      r0,[sp,#8]
00066a  2800              CMP      r0,#0
00066c  d102              BNE      |L1.1652|
;;;1081               {
;;;1082                 USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_CONFIGURED;
00066e  2005              MOVS     r0,#5
000670  497f              LDR      r1,|L1.2160|
000672  7008              STRB     r0,[r1,#0]
                  |L1.1652|
;;;1083               }
;;;1084             }
;;;1085             break;
000674  e038              B        |L1.1768|
;;;1086           /* GET_INTERFACE */
;;;1087           case USB_GET_INTERFACE:
;;;1088             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
000676  487e              LDR      r0,|L1.2160|
000678  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
00067a  2804              CMP      r0,#4
00067c  d102              BNE      |L1.1668|
;;;1089             {
;;;1090               result = USB_ERROR;
00067e  2001              MOVS     r0,#1
000680  9002              STR      r0,[sp,#8]
000682  e008              B        |L1.1686|
                  |L1.1668|
;;;1091             }
;;;1092             else
;;;1093             {
;;;1094               SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_INTERFACE(wIndex);
000684  2000              MOVS     r0,#0
000686  497b              LDR      r1,|L1.2164|
000688  7008              STRB     r0,[r1,#0]
;;;1095               result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
00068a  2300              MOVS     r3,#0
00068c  2201              MOVS     r2,#1
00068e  9805              LDR      r0,[sp,#0x14]
000690  f7fffffe          BL       USB_EP_doDataIn
000694  9002              STR      r0,[sp,#8]
                  |L1.1686|
;;;1096             }
;;;1097             break;
000696  e027              B        |L1.1768|
;;;1098           /* SET_INTERFACE */
;;;1099           case USB_SET_INTERFACE:
;;;1100             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
000698  4875              LDR      r0,|L1.2160|
00069a  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
00069c  2804              CMP      r0,#4
00069e  d102              BNE      |L1.1702|
;;;1101             {
;;;1102               result = USB_ERROR;
0006a0  2001              MOVS     r0,#1
0006a2  9002              STR      r0,[sp,#8]
0006a4  e008              B        |L1.1720|
                  |L1.1702|
;;;1103             }
;;;1104             else
;;;1105             {
;;;1106               result = USB_DEVICE_HANDLE_SET_INTERFACE(wValue, wIndex);
0006a6  2e00              CMP      r6,#0
0006a8  d101              BNE      |L1.1710|
0006aa  2f00              CMP      r7,#0
0006ac  d001              BEQ      |L1.1714|
                  |L1.1710|
0006ae  2001              MOVS     r0,#1
0006b0  e000              B        |L1.1716|
                  |L1.1714|
0006b2  2000              MOVS     r0,#0
                  |L1.1716|
0006b4  b280              UXTH     r0,r0
0006b6  9002              STR      r0,[sp,#8]
                  |L1.1720|
;;;1107             }
;;;1108             break;
0006b8  e016              B        |L1.1768|
;;;1109           /* SYNCH_FRAME */
;;;1110           case USB_SYNCH_FRAME:
;;;1111             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
0006ba  486d              LDR      r0,|L1.2160|
0006bc  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0006be  2804              CMP      r0,#4
0006c0  d102              BNE      |L1.1736|
;;;1112             {
;;;1113               result = USB_ERROR;
0006c2  2001              MOVS     r0,#1
0006c4  9002              STR      r0,[sp,#8]
0006c6  e00b              B        |L1.1760|
                  |L1.1736|
;;;1114             }
;;;1115             else
;;;1116             {
;;;1117               result = USB_DEVICE_HANDLE_SYNC_FRAME(wIndex, SetupPacketData);
0006c8  2001              MOVS     r0,#1
0006ca  9002              STR      r0,[sp,#8]
;;;1118               if (result == USB_SUCCESS)
0006cc  9802              LDR      r0,[sp,#8]
0006ce  2800              CMP      r0,#0
0006d0  d106              BNE      |L1.1760|
;;;1119               {
;;;1120                 result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
0006d2  2300              MOVS     r3,#0
0006d4  2202              MOVS     r2,#2
0006d6  4967              LDR      r1,|L1.2164|
0006d8  9805              LDR      r0,[sp,#0x14]
0006da  f7fffffe          BL       USB_EP_doDataIn
0006de  9002              STR      r0,[sp,#8]
                  |L1.1760|
;;;1121               }
;;;1122             }
;;;1123             break;
0006e0  e002              B        |L1.1768|
;;;1124           default:
;;;1125             result = USB_ERR_INV_REQ;
0006e2  2002              MOVS     r0,#2
0006e4  9002              STR      r0,[sp,#8]
0006e6  bf00              NOP                            ;977
                  |L1.1768|
0006e8  bf00              NOP                            ;1019
;;;1126         }
;;;1127         /* If there were no DATA stage, initiate Status Stage (IN ACK) */
;;;1128         if (result == USB_SUCCESS && wLength == 0)
0006ea  9802              LDR      r0,[sp,#8]
0006ec  2800              CMP      r0,#0
0006ee  d116              BNE      |L1.1822|
0006f0  9801              LDR      r0,[sp,#4]
0006f2  2800              CMP      r0,#0
0006f4  d113              BNE      |L1.1822|
;;;1129         {
;;;1130           result = (USB_SetupPacket->mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
0006f6  7820              LDRB     r0,[r4,#0]
0006f8  2180              MOVS     r1,#0x80
0006fa  4008              ANDS     r0,r0,r1
0006fc  2880              CMP      r0,#0x80
0006fe  d106              BNE      |L1.1806|
;;;1131                           USB_EP_doDataOut(EPx, 0, 0, statusAckHandler) :
000700  2200              MOVS     r2,#0
000702  4611              MOV      r1,r2
000704  9b00              LDR      r3,[sp,#0]
000706  9805              LDR      r0,[sp,#0x14]
000708  f7fffffe          BL       USB_EP_doDataOut
00070c  e005              B        |L1.1818|
                  |L1.1806|
;;;1132                           USB_EP_doDataIn(EPx, 0, 0, statusAckHandler);
00070e  2200              MOVS     r2,#0
000710  4611              MOV      r1,r2
000712  9b00              LDR      r3,[sp,#0]
000714  9805              LDR      r0,[sp,#0x14]
000716  f7fffffe          BL       USB_EP_doDataIn
                  |L1.1818|
00071a  b280              UXTH     r0,r0
00071c  9002              STR      r0,[sp,#8]
                  |L1.1822|
;;;1133         }
;;;1134         break;
00071e  e009              B        |L1.1844|
                  |L1.1824|
;;;1135       }
;;;1136       /* Class-specific request */
;;;1137       case USB_TYPE_CLASS:
;;;1138         result = USB_DEVICE_HANDLE_CLASS_REQUEST;
000720  f7fffffe          BL       USB_CDC_ClassRequest
000724  9002              STR      r0,[sp,#8]
;;;1139         break;
000726  e005              B        |L1.1844|
                  |L1.1832|
;;;1140       /* Vendor-specific request */
;;;1141       case USB_TYPE_VENDOR:
;;;1142         result = USB_DEVICE_HANDLE_VENDOR_REQUEST;
000728  2001              MOVS     r0,#1
00072a  9002              STR      r0,[sp,#8]
;;;1143         break;
00072c  e002              B        |L1.1844|
                  |L1.1838|
;;;1144       default:
;;;1145         result = USB_ERR_INV_REQ;
00072e  2002              MOVS     r0,#2
000730  9002              STR      r0,[sp,#8]
000732  bf00              NOP                            ;959
                  |L1.1844|
000734  bf00              NOP                            ;974
;;;1146     }
;;;1147     return result;
000736  9802              LDR      r0,[sp,#8]
;;;1148   }
000738  b007              ADD      sp,sp,#0x1c
00073a  bdf0              POP      {r4-r7,pc}
;;;1149   
                          ENDP

                  USB_DeviceInit PROC
;;;808    
;;;809    USB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam)
00073c  b570              PUSH     {r4-r6,lr}
;;;810    {
00073e  4605              MOV      r5,r0
000740  460c              MOV      r4,r1
;;;811      /* Check the parameters */
;;;812      assert_param(IS_USB_PULL(USB_DeviceBUSParam.PULL));
;;;813      assert_param(IS_USB_SPEED(USB_DeviceBUSParam.SPEED));
;;;814      assert_param(IS_USB_MODE(USB_DeviceBUSParam.MODE));
;;;815    
;;;816      /* Set USB clocks perform controller reset */
;;;817      USB_BRGInit(USB_Clock_InitStruct);
000742  4628              MOV      r0,r5
000744  f7fffffe          BL       USB_BRGInit
;;;818      USB_Reset();
000748  f7fffffe          BL       USB_Reset
;;;819      /* Set pulls and Device mode */
;;;820      USB_SetHSCR(USB_HSCR_HOST_MODE_Device);
00074c  2001              MOVS     r0,#1
00074e  0400              LSLS     r0,r0,#16
000750  f7fffffe          BL       USB_SetHSCR
;;;821      USB_SetHSCR(USB_DeviceBUSParam->PULL);
000754  6820              LDR      r0,[r4,#0]
000756  f7fffffe          BL       USB_SetHSCR
;;;822      /* Set speed, polarity and enable end points */
;;;823      USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | USB_SC_SCGEN_Set);
00075a  68a2              LDR      r2,[r4,#8]
00075c  6861              LDR      r1,[r4,#4]
00075e  4311              ORRS     r1,r1,r2
000760  2201              MOVS     r2,#1
000762  4311              ORRS     r1,r1,r2
000764  4608              MOV      r0,r1
000766  f7fffffe          BL       USB_SetSC
;;;824      /* Setup EP0 */
;;;825      USB_EP_Init(USB_EP0, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1, 0);
00076a  2200              MOVS     r2,#0
00076c  2105              MOVS     r1,#5
00076e  4610              MOV      r0,r2
000770  f7fffffe          BL       USB_EP_Init
;;;826      USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DEVICE_HANDLE_SETUP);
000774  4a42              LDR      r2,|L1.2176|
000776  4943              LDR      r1,|L1.2180|
000778  2000              MOVS     r0,#0
00077a  f7fffffe          BL       USB_EP_setSetupHandler
;;;827    
;;;828      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
00077e  2000              MOVS     r0,#0
000780  493b              LDR      r1,|L1.2160|
000782  7008              STRB     r0,[r1,#0]
;;;829      USB_DeviceContext.Address = 0;
000784  6048              STR      r0,[r1,#4]  ; USB_DeviceContext
;;;830    
;;;831      return USB_SUCCESS;
;;;832    }
000786  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

                  USB_DevicePowerOn PROC
;;;841    
;;;842    USB_Result USB_DevicePowerOn(void)
000788  b510              PUSH     {r4,lr}
;;;843    {
;;;844      USB_SetHSCR(USB_HSCR_EN_RX_Set | USB_HSCR_EN_TX_Set);
00078a  200c              MOVS     r0,#0xc
00078c  f7fffffe          BL       USB_SetHSCR
;;;845      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_POWERED;
000790  2002              MOVS     r0,#2
000792  4937              LDR      r1,|L1.2160|
000794  7008              STRB     r0,[r1,#0]
;;;846    
;;;847      return USB_SUCCESS;
000796  2000              MOVS     r0,#0
;;;848    }
000798  bd10              POP      {r4,pc}
;;;849    
                          ENDP

                  USB_DevicePowerOff PROC
;;;857    
;;;858    USB_Result USB_DevicePowerOff(void)
00079a  b510              PUSH     {r4,lr}
;;;859    {
;;;860      USB_SetHSCR(USB_HSCR_EN_RX_Reset);
00079c  2001              MOVS     r0,#1
00079e  04c0              LSLS     r0,r0,#19
0007a0  f7fffffe          BL       USB_SetHSCR
;;;861      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
0007a4  2000              MOVS     r0,#0
0007a6  4932              LDR      r1,|L1.2160|
0007a8  7008              STRB     r0,[r1,#0]
;;;862    
;;;863      return USB_SUCCESS;
;;;864    }
0007aa  bd10              POP      {r4,pc}
;;;865    
                          ENDP

                  USB_DeviceReset PROC
;;;892    
;;;893    USB_Result USB_DeviceReset(void)
0007ac  2000              MOVS     r0,#0
;;;894    {
;;;895      USB->SA=0;
0007ae  4936              LDR      r1,|L1.2184|
0007b0  6108              STR      r0,[r1,#0x10]
;;;896      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_DEFAULT;
0007b2  2003              MOVS     r0,#3
0007b4  492e              LDR      r1,|L1.2160|
0007b6  7008              STRB     r0,[r1,#0]
;;;897      return USB_SUCCESS;
0007b8  2000              MOVS     r0,#0
;;;898    }
0007ba  4770              BX       lr
;;;899    
                          ENDP

                  USB_DeviceSuspend PROC
;;;907    
;;;908    USB_Result USB_DeviceSuspend(void)
0007bc  2000              MOVS     r0,#0
;;;909    {
;;;910      return USB_SUCCESS;
;;;911    }
0007be  4770              BX       lr
;;;912    
                          ENDP

                  USB_DeviceResume PROC
;;;920    
;;;921    USB_Result USB_DeviceResume(void)
0007c0  2000              MOVS     r0,#0
;;;922    {
;;;923      return USB_SUCCESS;
;;;924    }
0007c2  4770              BX       lr
;;;925    
                          ENDP

                  USB_DeviceDoStatusInAck PROC
;;;1244   
;;;1245   USB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
0007c4  4603              MOV      r3,r0
;;;1246   {
;;;1247     return USB_SUCCESS;
0007c6  2000              MOVS     r0,#0
;;;1248   }
0007c8  4770              BX       lr
;;;1249   
                          ENDP

                  USB_DeviceDoStatusOutAck PROC
;;;1267   
;;;1268   USB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
0007ca  b570              PUSH     {r4-r6,lr}
;;;1269   {
0007cc  4604              MOV      r4,r0
0007ce  460d              MOV      r5,r1
0007d0  4616              MOV      r6,r2
;;;1270     return USB_EP_doDataOut(EPx, 0, 0, 0);
0007d2  2300              MOVS     r3,#0
0007d4  461a              MOV      r2,r3
0007d6  4619              MOV      r1,r3
0007d8  4620              MOV      r0,r4
0007da  f7fffffe          BL       USB_EP_doDataOut
;;;1271   }
0007de  bd70              POP      {r4-r6,pc}
;;;1272   
                          ENDP

                  USB_DeviceDispatchEvent PROC
;;;1315   
;;;1316   USB_Result USB_DeviceDispatchEvent(void)
0007e0  b570              PUSH     {r4-r6,lr}
;;;1317   {
;;;1318     uint32_t i;
;;;1319     uint32_t USB_IT;
;;;1320     USB_Result result = USB_SUCCESS;
0007e2  2600              MOVS     r6,#0
;;;1321     static volatile uint32_t bHandling = RESET;
;;;1322   
;;;1323     /* Disable USB interrupts */
;;;1324   #ifdef USB_INT_HANDLE_REQUIRED
;;;1325     NVIC_DisableIRQ(USB_IRQn);
0007e4  bf00              NOP      
0007e6  2102              MOVS     r1,#2
0007e8  2001              MOVS     r0,#1
0007ea  4088              LSLS     r0,r0,r1
0007ec  4927              LDR      r1,|L1.2188|
0007ee  2202              MOVS     r2,#2
0007f0  0952              LSRS     r2,r2,#5
0007f2  0092              LSLS     r2,r2,#2
0007f4  5088              STR      r0,[r1,r2]
0007f6  bf00              NOP      
;;;1326   #endif /* USB_INT_HANDLE_REQUIRED */
;;;1327   
;;;1328     if (!bHandling) {
0007f8  4825              LDR      r0,|L1.2192|
0007fa  6800              LDR      r0,[r0,#0]  ; bHandling
0007fc  2800              CMP      r0,#0
0007fe  d127              BNE      |L1.2128|
;;;1329       bHandling = SET;
000800  2001              MOVS     r0,#1
000802  4923              LDR      r1,|L1.2192|
000804  6008              STR      r0,[r1,#0]  ; bHandling
;;;1330   
;;;1331       /* Get masked interrupt flags */
;;;1332       USB_IT = USB_GetSIS();
000806  f7fffffe          BL       USB_GetSIS
00080a  4604              MOV      r4,r0
;;;1333       /* Handle reset */
;;;1334       if (USB_IT & USB_SIS_SCRESETEV)
00080c  2004              MOVS     r0,#4
00080e  4204              TST      r4,r0
000810  d002              BEQ      |L1.2072|
;;;1335       {
;;;1336         result = USB_DeviceReset();
000812  f7fffffe          BL       USB_DeviceReset
000816  4606              MOV      r6,r0
                  |L1.2072|
;;;1337       }
;;;1338   
;;;1339       /* Invoke End Point dispatchers */
;;;1340       for (i = USB_EP0; i < Num_USB_EndPoints; i++)
000818  2500              MOVS     r5,#0
00081a  e004              B        |L1.2086|
                  |L1.2076|
;;;1341       {
;;;1342         USB_EP_dispatchEvent((USB_EP_TypeDef)i, USB_IT);
00081c  b2e8              UXTB     r0,r5
00081e  4621              MOV      r1,r4
000820  f7fffffe          BL       USB_EP_dispatchEvent
000824  1c6d              ADDS     r5,r5,#1              ;1340
                  |L1.2086|
000826  2d04              CMP      r5,#4                 ;1340
000828  d3f8              BCC      |L1.2076|
;;;1343       }
;;;1344   
;;;1345       /* Clear pending bits, except for SCTDONE */
;;;1346       USB_SetSIS(USB_IT & (~USB_SIS_SCTDONE_Set));
00082a  0860              LSRS     r0,r4,#1
00082c  0040              LSLS     r0,r0,#1
00082e  f7fffffe          BL       USB_SetSIS
;;;1347   
;;;1348       bHandling = RESET;
000832  2000              MOVS     r0,#0
000834  4916              LDR      r1,|L1.2192|
000836  6008              STR      r0,[r1,#0]  ; bHandling
;;;1349   
;;;1350       /* Enable USB interrupts (only after the actual work is done) */
;;;1351   #ifdef USB_INT_HANDLE_REQUIRED
;;;1352       NVIC_EnableIRQ(USB_IRQn);
000838  bf00              NOP      
00083a  2002              MOVS     r0,#2
00083c  2101              MOVS     r1,#1
00083e  4081              LSLS     r1,r1,r0
000840  0940              LSRS     r0,r0,#5
000842  0080              LSLS     r0,r0,#2
000844  4a11              LDR      r2,|L1.2188|
000846  3a80              SUBS     r2,r2,#0x80
000848  1880              ADDS     r0,r0,r2
00084a  6001              STR      r1,[r0,#0]
00084c  bf00              NOP      
00084e  bf00              NOP      
                  |L1.2128|
;;;1353   #endif /* USB_INT_HANDLE_REQUIRED */
;;;1354     }
;;;1355     return result;
000850  4630              MOV      r0,r6
;;;1356   }
000852  bd70              POP      {r4-r6,pc}
;;;1357   
                          ENDP

                  USB_IRQHandler PROC
;;;1370   
;;;1371   void USB_IRQHandler(void)
000854  b510              PUSH     {r4,lr}
;;;1372   {
;;;1373     USB_DeviceDispatchEvent();
000856  f7fffffe          BL       USB_DeviceDispatchEvent
;;;1374   }
00085a  bd10              POP      {r4,pc}
;;;1375   #endif /* USB_INT_HANDLE_REQUIRED */
                          ENDP

                  USB_DeviceDummyGetStatus PROC
;;;1399   
;;;1400   USB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX)
00085c  4602              MOV      r2,r0
;;;1401   {
;;;1402     return USB_SUCCESS;
00085e  2000              MOVS     r0,#0
;;;1403   }
000860  4770              BX       lr
;;;1404   
                          ENDP

                  USB_DeviceDummySetAddress PROC
;;;1416   
;;;1417   USB_Result USB_DeviceDummySetAddress(uint16_t wVALUE)
000862  4601              MOV      r1,r0
;;;1418   {
;;;1419     return USB_SUCCESS;
000864  2000              MOVS     r0,#0
;;;1420   }
000866  4770              BX       lr
;;;1421   
                          ENDP

                  USB_DeviceDummyGetDescriptor PROC
;;;1438   
;;;1439   USB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
000868  4603              MOV      r3,r0
;;;1440   {
;;;1441     return USB_ERROR;
00086a  2001              MOVS     r0,#1
;;;1442   }
00086c  4770              BX       lr
00086e  0000              DCW      0x0000
                  |L1.2160|
                          DCD      USB_DeviceContext
                  |L1.2164|
                          DCD      SetupPacketData
                  |L1.2168|
                          DCD      USB_EPContext
                  |L1.2172|
                          DCD      USB_Device_setAddressWork
                  |L1.2176|
                          DCD      USB_DeviceSetupPacket
                  |L1.2180|
                          DCD      USB_CurrentSetupPacket
                  |L1.2184|
                          DCD      0x40010140
                  |L1.2188|
                          DCD      0xe000e180
                  |L1.2192|
                          DCD      bHandling
                          ENDP

                  USB_DeviceDummySetDescriptor PROC
;;;1460   
;;;1461   USB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
000894  4603              MOV      r3,r0
;;;1462   {
;;;1463     return USB_ERROR;
000896  2001              MOVS     r0,#1
;;;1464   }
000898  4770              BX       lr
;;;1465   
                          ENDP

                  USB_DeviceDummyGetConfiguration PROC
;;;1476   
;;;1477   uint8_t USB_DeviceDummyGetConfiguration(void)
00089a  2001              MOVS     r0,#1
;;;1478   {
;;;1479     return 1;
;;;1480   }
00089c  4770              BX       lr
;;;1481   
                          ENDP

                  USB_DeviceDummySetConfiguration PROC
;;;1492   
;;;1493   USB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE)
00089e  4601              MOV      r1,r0
;;;1494   {
;;;1495     return USB_ERROR;
0008a0  2001              MOVS     r0,#1
;;;1496   }
0008a2  4770              BX       lr
;;;1497   
                          ENDP

                  USB_DeviceDummyGetInterface PROC
;;;1509   
;;;1510   uint8_t USB_DeviceDummyGetInterface(uint16_t wINDEX)
0008a4  4601              MOV      r1,r0
;;;1511   {
;;;1512     return 0;
0008a6  2000              MOVS     r0,#0
;;;1513   }
0008a8  4770              BX       lr
;;;1514   
                          ENDP

                  USB_DeviceDummySetInterface PROC
;;;1527   
;;;1528   USB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX)
0008aa  4602              MOV      r2,r0
;;;1529   {
;;;1530     return USB_SUCCESS;
0008ac  2000              MOVS     r0,#0
;;;1531   }
0008ae  4770              BX       lr
;;;1532   
                          ENDP

                  USB_DeviceDummySyncFrame PROC
;;;1547   
;;;1548   USB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA)
0008b0  4602              MOV      r2,r0
;;;1549   {
;;;1550     return USB_ERROR;
0008b2  2001              MOVS     r0,#1
;;;1551   }
0008b4  4770              BX       lr
;;;1552   
                          ENDP

                  USB_DeviceDummyClassRequest PROC
;;;1565   
;;;1566   USB_Result USB_DeviceDummyClassRequest(void)
0008b6  2001              MOVS     r0,#1
;;;1567   {
;;;1568     return USB_ERROR;
;;;1569   }
0008b8  4770              BX       lr
;;;1570   
                          ENDP

                  USB_DeviceDummyVendorRequest PROC
;;;1584   
;;;1585   USB_Result USB_DeviceDummyVendorRequest(void)
0008ba  2001              MOVS     r0,#1
;;;1586   {
;;;1587     return USB_ERROR;
;;;1588   }
0008bc  4770              BX       lr
;;;1589   
                          ENDP

                  USB_DeviceDummyDataError PROC
;;;1613   
;;;1614   USB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL)
0008be  b510              PUSH     {r4,lr}
;;;1615   {
0008c0  4604              MOV      r4,r0
;;;1616     return USB_ERROR;
0008c2  2001              MOVS     r0,#1
;;;1617   }
0008c4  bd10              POP      {r4,pc}
;;;1618   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_EPContext
                          %        176

                          AREA ||.data||, DATA, ALIGN=2

                  bHandling
                          DCD      0x00000000
                  USB_CurrentSetupPacket
                          %        8
                  USB_DeviceContext
                          %        8
                  SetupPacketData
000014  0000              DCB      0x00,0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L17.24|
                  |L17.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L17.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L17.14|
                          ENDP


; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\1986be9x_usb_cdc.o --depend=.\obj\1986be9x_usb_cdc.d --cpu=Cortex-M1 --apcs=interwork -O0 -I.\inc -IC:\Keil4\ARM\INC -IC:\Keil4\ARM\INC\ARM --omf_browse=.\obj\1986be9x_usb_cdc.crf src\1986BE9x_usb_CDC.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USB_CDC_SetReceiveBuffer PROC
;;;305    
;;;306    USB_Result USB_CDC_SetReceiveBuffer(uint8_t* ReceiveBuffer, uint32_t DataPortionLength)
000000  4602              MOV      r2,r0
;;;307    {
;;;308      /* Check the parameters */
;;;309      assert_param(ReceiveBuffer);
;;;310    
;;;311      USB_CDCContext.CDC_ReceiveBuffer = ReceiveBuffer;
000002  4891              LDR      r0,|L1.584|
000004  6002              STR      r2,[r0,#0]  ; USB_CDCContext
;;;312      USB_CDCContext.CDC_DataPortionLength = DataPortionLength;
000006  6041              STR      r1,[r0,#4]  ; USB_CDCContext
;;;313    
;;;314      return USB_SUCCESS;
000008  2000              MOVS     r0,#0
;;;315    }
00000a  4770              BX       lr
;;;316    
                          ENDP

                  USB_CDC_Init PROC
;;;280    
;;;281    USB_Result USB_CDC_Init(uint8_t* ReceiveBuffer, uint32_t DataPortionLength, FlagStatus StartReceiving)
00000c  b530              PUSH     {r4,r5,lr}
;;;282    {
00000e  4604              MOV      r4,r0
000010  460d              MOV      r5,r1
000012  4613              MOV      r3,r2
;;;283      USB_CDC_SetReceiveBuffer(ReceiveBuffer, DataPortionLength);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_CDC_SetReceiveBuffer
;;;284      USB_CDCContext.CDC_SendDataStatus = USB_SUCCESS;
00001c  2000              MOVS     r0,#0
00001e  498a              LDR      r1,|L1.584|
000020  8108              STRH     r0,[r1,#8]
;;;285      USB_CDCContext.CDC_ReceiveDataStatus = StartReceiving ? USB_SUCCESS : USB_ERR_BUSY;
000022  2b00              CMP      r3,#0
000024  d000              BEQ      |L1.40|
000026  e001              B        |L1.44|
                  |L1.40|
000028  2001              MOVS     r0,#1
00002a  0240              LSLS     r0,r0,#9
                  |L1.44|
00002c  4986              LDR      r1,|L1.584|
00002e  8148              STRH     r0,[r1,#0xa]
;;;286    
;;;287      return USB_SUCCESS;
000030  2000              MOVS     r0,#0
;;;288    }
000032  bd30              POP      {r4,r5,pc}
;;;289    
                          ENDP

                  USB_CDC_OnDataReceive PROC
;;;654    
;;;655    static USB_Result USB_CDC_OnDataReceive(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000034  b5f8              PUSH     {r3-r7,lr}
;;;656    {
000036  4607              MOV      r7,r0
000038  460c              MOV      r4,r1
00003a  4615              MOV      r5,r2
;;;657      /* Call user's handler */
;;;658      USB_Result result = USB_CDC_HANDLE_DATA_RECEIVE(Buffer, Length);
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       USB_CDC_RecieveData
000044  4606              MOV      r6,r0
;;;659    
;;;660      /* If handler returns USB_SUCCESS, wait for another portion. Otherwise, stop to receive
;;;661       * incoming data */
;;;662      if (result != USB_SUCCESS)
000046  2e00              CMP      r6,#0
000048  d003              BEQ      |L1.82|
;;;663      {
;;;664        USB_CDCContext.CDC_ReceiveDataStatus = USB_ERR_BUSY;
00004a  2001              MOVS     r0,#1
00004c  0240              LSLS     r0,r0,#9
00004e  497e              LDR      r1,|L1.584|
000050  8148              STRH     r0,[r1,#0xa]
                  |L1.82|
;;;665      }
;;;666      if (USB_CDCContext.CDC_ReceiveDataStatus == USB_SUCCESS)
000052  487d              LDR      r0,|L1.584|
000054  8940              LDRH     r0,[r0,#0xa]  ; USB_CDCContext
000056  2800              CMP      r0,#0
000058  d107              BNE      |L1.106|
;;;667      {
;;;668        return USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
00005a  487b              LDR      r0,|L1.584|
00005c  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
00005e  4b7b              LDR      r3,|L1.588|
000060  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
000062  2003              MOVS     r0,#3
000064  f7fffffe          BL       USB_EP_doDataOut
                  |L1.104|
;;;669                  USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;670      }
;;;671      else
;;;672      {
;;;673        return USB_SUCCESS;
;;;674      }
;;;675    }
000068  bdf8              POP      {r3-r7,pc}
                  |L1.106|
00006a  2000              MOVS     r0,#0                 ;673
00006c  e7fc              B        |L1.104|
;;;676    
                          ENDP

                  USB_CDC_ReceiveStart PROC
;;;323    
;;;324    USB_Result USB_CDC_ReceiveStart(void)
00006e  b510              PUSH     {r4,lr}
;;;325    {
;;;326      USB_CDCContext.CDC_ReceiveDataStatus = USB_SUCCESS;
000070  2000              MOVS     r0,#0
000072  4975              LDR      r1,|L1.584|
000074  8148              STRH     r0,[r1,#0xa]
;;;327      return USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
000076  4608              MOV      r0,r1
000078  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
00007a  4b74              LDR      r3,|L1.588|
00007c  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
00007e  2003              MOVS     r0,#3
000080  f7fffffe          BL       USB_EP_doDataOut
;;;328                USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;329    }
000084  bd10              POP      {r4,pc}
;;;330    
                          ENDP

                  USB_CDC_ReceiveStop PROC
;;;337    
;;;338    USB_Result USB_CDC_ReceiveStop(void)
000086  b510              PUSH     {r4,lr}
;;;339    {
;;;340      USB_CDCContext.CDC_ReceiveDataStatus = USB_ERR_BUSY;
000088  2001              MOVS     r0,#1
00008a  0240              LSLS     r0,r0,#9
00008c  496e              LDR      r1,|L1.584|
00008e  8148              STRH     r0,[r1,#0xa]
;;;341      return USB_EP_Stall(USB_CDC_EP_RECEIVE, USB_STALL_PROTO);
000090  2100              MOVS     r1,#0
000092  2003              MOVS     r0,#3
000094  f7fffffe          BL       USB_EP_Stall
;;;342    }
000098  bd10              POP      {r4,pc}
;;;343    
                          ENDP

                  USB_CDC_OnDataSent PROC
;;;629    
;;;630    static USB_Result USB_CDC_OnDataSent(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
00009a  b510              PUSH     {r4,lr}
;;;631    {
00009c  4603              MOV      r3,r0
;;;632      /* Release "busy" flag and call user's handler */
;;;633      USB_CDCContext.CDC_SendDataStatus = USB_SUCCESS;
00009e  2000              MOVS     r0,#0
0000a0  4c69              LDR      r4,|L1.584|
0000a2  8120              STRH     r0,[r4,#8]
;;;634      return USB_CDC_HANDLE_DATA_SENT;
;;;635    }
0000a4  bd10              POP      {r4,pc}
;;;636    
                          ENDP

                  USB_CDC_SendData PROC
;;;356    
;;;357    USB_Result USB_CDC_SendData(uint8_t* Buffer, uint32_t Length)
0000a6  b570              PUSH     {r4-r6,lr}
;;;358    {
0000a8  4604              MOV      r4,r0
0000aa  460e              MOV      r6,r1
;;;359      /* Check if previous data sending is complete */
;;;360      USB_Result result = USB_CDCContext.CDC_SendDataStatus;
0000ac  4866              LDR      r0,|L1.584|
0000ae  8905              LDRH     r5,[r0,#8]  ; USB_CDCContext
;;;361    
;;;362      /* If data can be sent, set "busy" flag and initiate data portion transfer */
;;;363      if (result == USB_SUCCESS)
0000b0  2d00              CMP      r5,#0
0000b2  d10a              BNE      |L1.202|
;;;364      {
;;;365        USB_CDCContext.CDC_SendDataStatus = USB_ERR_BUSY;
0000b4  2001              MOVS     r0,#1
0000b6  0240              LSLS     r0,r0,#9
0000b8  4963              LDR      r1,|L1.584|
0000ba  8108              STRH     r0,[r1,#8]
;;;366        result = USB_EP_doDataIn(USB_CDC_EP_SEND, Buffer, Length, USB_CDC_OnDataSent);
0000bc  4b64              LDR      r3,|L1.592|
0000be  4632              MOV      r2,r6
0000c0  4621              MOV      r1,r4
0000c2  2001              MOVS     r0,#1
0000c4  f7fffffe          BL       USB_EP_doDataIn
0000c8  4605              MOV      r5,r0
                  |L1.202|
;;;367      }
;;;368      return result;
0000ca  4628              MOV      r0,r5
;;;369    }
0000cc  bd70              POP      {r4-r6,pc}
;;;370    
                          ENDP

                  USB_CDC_Reset PROC
;;;408    
;;;409    USB_Result USB_CDC_Reset(void)
0000ce  b510              PUSH     {r4,lr}
;;;410    {
;;;411      USB_Result result;
;;;412    
;;;413      /* Inherited handler call */
;;;414      result = USB_DeviceReset();
0000d0  f7fffffe          BL       USB_DeviceReset
0000d4  4604              MOV      r4,r0
;;;415    
;;;416      if (result == USB_SUCCESS)
0000d6  2c00              CMP      r4,#0
0000d8  d11a              BNE      |L1.272|
;;;417      {
;;;418        /* EP1, EP2 and EP3 initialization. Note: DATA1 bit would be toggled to DATA0 on the first
;;;419         * IN transaction */
;;;420        USB_EP_Init(USB_CDC_EP_SEND, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1,
0000da  2200              MOVS     r2,#0
0000dc  2105              MOVS     r1,#5
0000de  2001              MOVS     r0,#1
0000e0  f7fffffe          BL       USB_EP_Init
;;;421                    USB_CDC_HANDLE_SEND_ERROR);
;;;422        USB_EP_Init(USB_CDC_EP_STATE, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1,
0000e4  2200              MOVS     r2,#0
0000e6  2105              MOVS     r1,#5
0000e8  2002              MOVS     r0,#2
0000ea  f7fffffe          BL       USB_EP_Init
;;;423                    USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR);
;;;424        USB_EP_Init(USB_CDC_EP_RECEIVE, USB_SEPx_CTRL_EPEN_Enable, 0);
0000ee  2200              MOVS     r2,#0
0000f0  2101              MOVS     r1,#1
0000f2  2003              MOVS     r0,#3
0000f4  f7fffffe          BL       USB_EP_Init
;;;425    
;;;426        /* Start to listen for incoming data, if desired */
;;;427        if (USB_CDCContext.CDC_ReceiveDataStatus == USB_SUCCESS)
0000f8  4853              LDR      r0,|L1.584|
0000fa  8940              LDRH     r0,[r0,#0xa]  ; USB_CDCContext
0000fc  2800              CMP      r0,#0
0000fe  d107              BNE      |L1.272|
;;;428        {
;;;429          result = USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
000100  4851              LDR      r0,|L1.584|
000102  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
000104  4b51              LDR      r3,|L1.588|
000106  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
000108  2003              MOVS     r0,#3
00010a  f7fffffe          BL       USB_EP_doDataOut
00010e  4604              MOV      r4,r0
                  |L1.272|
;;;430                    USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;431        }
;;;432      }
;;;433      return result;
000110  4620              MOV      r0,r4
;;;434    }
000112  bd10              POP      {r4,pc}
;;;435    
                          ENDP

                  USB_CDC_GetDescriptor PROC
;;;449    
;;;450    USB_Result USB_CDC_GetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
000114  b5f8              PUSH     {r3-r7,lr}
;;;451    {
000116  4605              MOV      r5,r0
000118  4616              MOV      r6,r2
;;;452      uint8_t* pDescr = 0;
00011a  2000              MOVS     r0,#0
00011c  9000              STR      r0,[sp,#0]
;;;453      uint32_t length;
;;;454      USB_Result result = USB_SUCCESS;
00011e  2700              MOVS     r7,#0
;;;455    
;;;456      /* Only 0 configuration is supported; for device request this field must be 0 */
;;;457      if ((wVALUE & 0xFF) != 0)
000120  0628              LSLS     r0,r5,#24
000122  0e00              LSRS     r0,r0,#24
000124  d001              BEQ      |L1.298|
;;;458      {
;;;459        result = USB_ERROR;
000126  2701              MOVS     r7,#1
000128  e010              B        |L1.332|
                  |L1.298|
;;;460      }
;;;461      else
;;;462      {
;;;463        switch (wVALUE >> 8)      /* Descriptor type */
00012a  1228              ASRS     r0,r5,#8
00012c  2801              CMP      r0,#1
00012e  d002              BEQ      |L1.310|
000130  2802              CMP      r0,#2
000132  d108              BNE      |L1.326|
000134  e003              B        |L1.318|
                  |L1.310|
;;;464        {
;;;465          case USB_DEVICE:
;;;466            pDescr = Usb_CDC_Device_Descriptor;
000136  4847              LDR      r0,|L1.596|
000138  9000              STR      r0,[sp,#0]
;;;467            length = 0x12;
00013a  2412              MOVS     r4,#0x12
;;;468            break;
00013c  e005              B        |L1.330|
                  |L1.318|
;;;469          case USB_CONFIGURATION:
;;;470            pDescr = Usb_CDC_Configuration_Descriptor;
00013e  4846              LDR      r0,|L1.600|
000140  9000              STR      r0,[sp,#0]
;;;471            length = 0x43;
000142  2443              MOVS     r4,#0x43
;;;472            break;
000144  e001              B        |L1.330|
                  |L1.326|
;;;473          default:
;;;474            result = USB_ERROR;
000146  2701              MOVS     r7,#1
000148  bf00              NOP                            ;463
                  |L1.330|
00014a  bf00              NOP                            ;468
                  |L1.332|
;;;475        }
;;;476      }
;;;477    
;;;478      if (result == USB_SUCCESS)
00014c  2f00              CMP      r7,#0
00014e  d109              BNE      |L1.356|
;;;479      {
;;;480        if (length > wLENGTH)
000150  42b4              CMP      r4,r6
000152  d900              BLS      |L1.342|
;;;481        {
;;;482          length = wLENGTH;
000154  4634              MOV      r4,r6
                  |L1.342|
;;;483        }
;;;484        result = USB_EP_doDataIn(USB_EP0, pDescr, length, USB_DeviceDoStatusOutAck);
000156  4b41              LDR      r3,|L1.604|
000158  4622              MOV      r2,r4
00015a  2000              MOVS     r0,#0
00015c  9900              LDR      r1,[sp,#0]
00015e  f7fffffe          BL       USB_EP_doDataIn
000162  4607              MOV      r7,r0
                  |L1.356|
;;;485      }
;;;486      return result;
000164  4638              MOV      r0,r7
;;;487    }
000166  bdf8              POP      {r3-r7,pc}
;;;488    
                          ENDP

                  USB_CDC_DoDataOut PROC
;;;696    
;;;697    static USB_Result USB_CDC_DoDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000168  b5f8              PUSH     {r3-r7,lr}
;;;698    {
00016a  4605              MOV      r5,r0
00016c  460e              MOV      r6,r1
00016e  4617              MOV      r7,r2
;;;699      USB_Result result;
;;;700    
;;;701      switch (USB_CurrentSetupPacket.bRequest)
000170  483b              LDR      r0,|L1.608|
000172  7840              LDRB     r0,[r0,#1]  ; USB_CurrentSetupPacket
000174  2820              CMP      r0,#0x20
000176  d106              BNE      |L1.390|
;;;702      {
;;;703    #ifdef USB_CDC_COMM_FEATURE_SUPPORTED
;;;704        /* USB_CDC_SET_COMM_FEATURE */
;;;705        case USB_CDC_SET_COMM_FEATURE:
;;;706          /* Call user's handler */
;;;707          result = USB_CDC_HANDLE_SET_COMM_FEATURE(USB_CurrentSetupPacket.wValue,
;;;708                                                   USB_CurrentSetupPacket.wIndex,
;;;709                                                   *((uint16_t*)Buffer));
;;;710          break;
;;;711    #endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
;;;712    #ifdef USB_CDC_LINE_CODING_SUPPORTED
;;;713        /* USB_CDC_SET_LINE_CODING */
;;;714        case USB_CDC_SET_LINE_CODING:
;;;715          /* Call user's handler */
;;;716          result = USB_CDC_HANDLE_SET_LINE_CODING(USB_CurrentSetupPacket.wIndex,
000178  4939              LDR      r1,|L1.608|
00017a  8888              LDRH     r0,[r1,#4]  ; USB_CurrentSetupPacket
00017c  4631              MOV      r1,r6
00017e  f7fffffe          BL       USB_CDC_SetLineCoding
000182  4604              MOV      r4,r0
;;;717                                                  (const USB_CDC_LineCoding_TypeDef*)Buffer);
;;;718          break;
000184  e001              B        |L1.394|
                  |L1.390|
;;;719    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
;;;720        default:
;;;721          result = USB_ERR_INV_REQ;
000186  2402              MOVS     r4,#2
000188  bf00              NOP                            ;701
                  |L1.394|
00018a  bf00              NOP                            ;718
;;;722      }
;;;723      /* Initiate Status Stage */
;;;724      return result == USB_SUCCESS ? USB_EP_doDataIn(EPx, 0, 0, 0) : result;
00018c  2c00              CMP      r4,#0
00018e  d106              BNE      |L1.414|
000190  2300              MOVS     r3,#0
000192  461a              MOV      r2,r3
000194  4619              MOV      r1,r3
000196  4628              MOV      r0,r5
000198  f7fffffe          BL       USB_EP_doDataIn
00019c  e000              B        |L1.416|
                  |L1.414|
00019e  4620              MOV      r0,r4
                  |L1.416|
0001a0  b280              UXTH     r0,r0
;;;725    }
0001a2  bdf8              POP      {r3-r7,pc}
;;;726    
                          ENDP

                  USB_CDC_ClassRequest PROC
;;;496    
;;;497    USB_Result USB_CDC_ClassRequest(void)
0001a4  b5f8              PUSH     {r3-r7,lr}
;;;498    {
;;;499      USB_Result result = USB_SUCCESS;
0001a6  2500              MOVS     r5,#0
;;;500    
;;;501      uint16_t wValue = USB_CurrentSetupPacket.wValue,
0001a8  482d              LDR      r0,|L1.608|
0001aa  8847              LDRH     r7,[r0,#2]  ; USB_CurrentSetupPacket
;;;502               wIndex = USB_CurrentSetupPacket.wIndex,
0001ac  8886              LDRH     r6,[r0,#4]  ; USB_CurrentSetupPacket
;;;503               wLength = USB_CurrentSetupPacket.wLength;
0001ae  88c4              LDRH     r4,[r0,#6]  ; USB_CurrentSetupPacket
;;;504    
;;;505      /* Specific requests */
;;;506      switch (USB_CurrentSetupPacket.bRequest)
0001b0  7840              LDRB     r0,[r0,#1]  ; USB_CurrentSetupPacket
0001b2  2820              CMP      r0,#0x20
0001b4  d002              BEQ      |L1.444|
0001b6  2821              CMP      r0,#0x21
0001b8  d11e              BNE      |L1.504|
0001ba  e00b              B        |L1.468|
                  |L1.444|
;;;507      {
;;;508    #ifdef USB_CDC_ENCAPSULATION_SUPPORTED
;;;509        /* SEND_ENCAPSULATED_COMMAND */
;;;510        case USB_CDC_SEND_ENCAPSULATED_COMMAND:
;;;511          result = USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wIndex, wLength);
;;;512          break;
;;;513        /* GET_ENCAPSULATED_RESPONSE */
;;;514        case USB_CDC_GET_ENCAPSULATED_RESPONSE:
;;;515          result = USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wIndex, wLength);
;;;516          break;
;;;517    #endif /* USB_CDC_ENCAPSULATION_SUPPORTED */
;;;518    
;;;519    #ifdef USB_CDC_COMM_FEATURE_SUPPORTED
;;;520        /* SET_COMM_FEATURE */
;;;521        case USB_CDC_SET_COMM_FEATURE:
;;;522          if (wLength == 2)
;;;523          {
;;;524            result = USB_EP_doDataOut(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_CDC_DoDataOut);
;;;525          }
;;;526          else
;;;527          {
;;;528            result = USB_ERR_INV_REQ;
;;;529          }
;;;530          break;
;;;531        /* GET_COMM_FEATURE */
;;;532        case USB_CDC_GET_COMM_FEATURE:
;;;533          if (wLength == 2)
;;;534          {
;;;535            result = USB_CDC_HANDLE_GET_COMM_FEATURE(wValue, wIndex, &CDC_ClassPacketData.CommFeature);
;;;536            if (result == USB_SUCCESS)
;;;537            {
;;;538              result = USB_EP_doDataIn(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_DeviceDoStatusOutAck);
;;;539            }
;;;540          }
;;;541          else
;;;542          {
;;;543            result = USB_ERR_INV_REQ;
;;;544          }
;;;545          break;
;;;546        /* CLEAR_COMM_FEATURE */
;;;547        case USB_CDC_CLEAR_COMM_FEATURE:
;;;548          result = USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wValue, wIndex);
;;;549          break;
;;;550    #endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
;;;551    
;;;552    #ifdef USB_CDC_LINE_CODING_SUPPORTED
;;;553        /* SET_LINE_CODING */
;;;554        case USB_CDC_SET_LINE_CODING:
;;;555          if (wLength == 7)
0001bc  2c07              CMP      r4,#7
0001be  d107              BNE      |L1.464|
;;;556          {
;;;557            result = USB_EP_doDataOut(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_CDC_DoDataOut);
0001c0  4b28              LDR      r3,|L1.612|
0001c2  4622              MOV      r2,r4
0001c4  4928              LDR      r1,|L1.616|
0001c6  2000              MOVS     r0,#0
0001c8  f7fffffe          BL       USB_EP_doDataOut
0001cc  4605              MOV      r5,r0
0001ce  e000              B        |L1.466|
                  |L1.464|
;;;558          }
;;;559          else
;;;560          {
;;;561            result = USB_ERR_INV_REQ;
0001d0  2502              MOVS     r5,#2
                  |L1.466|
;;;562          }
;;;563          break;
0001d2  e013              B        |L1.508|
                  |L1.468|
;;;564        /* GET_LINE_CODING */
;;;565        case USB_CDC_GET_LINE_CODING:
;;;566          if (wLength == 7)
0001d4  2c07              CMP      r4,#7
0001d6  d10d              BNE      |L1.500|
;;;567          {
;;;568            result = USB_CDC_HANDLE_GET_LINE_CODING(wIndex, &CDC_ClassPacketData.LineCoding);
0001d8  4923              LDR      r1,|L1.616|
0001da  4630              MOV      r0,r6
0001dc  f7fffffe          BL       USB_CDC_GetLineCoding
0001e0  4605              MOV      r5,r0
;;;569            if (result == USB_SUCCESS)
0001e2  2d00              CMP      r5,#0
0001e4  d107              BNE      |L1.502|
;;;570            {
;;;571              result = USB_EP_doDataIn(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_DeviceDoStatusOutAck);
0001e6  4b1d              LDR      r3,|L1.604|
0001e8  4622              MOV      r2,r4
0001ea  491f              LDR      r1,|L1.616|
0001ec  f7fffffe          BL       USB_EP_doDataIn
0001f0  4605              MOV      r5,r0
0001f2  e000              B        |L1.502|
                  |L1.500|
;;;572            }
;;;573          }
;;;574          else
;;;575          {
;;;576            result = USB_ERR_INV_REQ;
0001f4  2502              MOVS     r5,#2
                  |L1.502|
;;;577          }
;;;578          break;
0001f6  e001              B        |L1.508|
                  |L1.504|
;;;579    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
;;;580    
;;;581    #ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
;;;582          /* SET_CONTROL_LINE_STATE */
;;;583          case USB_CDC_SET_CONTROL_LINE_STATE:
;;;584            result = USB_CDC_HANDLE_CONTROL_LINE_STATE(wValue, wIndex);
;;;585            break;
;;;586    #endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
;;;587    
;;;588    #ifdef USB_CDC_LINE_BREAK_SUPPORTED
;;;589          /* SEND_BREAK */
;;;590          case USB_CDC_SEND_BREAK:
;;;591            result = USB_CDC_HANDLE_BREAK(wValue, wIndex);
;;;592            break;
;;;593    #endif /* USB_CDC_LINE_BREAK_SUPPORTED */
;;;594    
;;;595          default:
;;;596            result = USB_ERROR;
0001f8  2501              MOVS     r5,#1
0001fa  bf00              NOP                            ;506
                  |L1.508|
0001fc  bf00              NOP                            ;563
;;;597      }
;;;598      /* If there were no DATA stage, initiate Status Stage (IN ACK) */
;;;599      if (result == USB_SUCCESS && wLength == 0)
0001fe  2d00              CMP      r5,#0
000200  d115              BNE      |L1.558|
000202  2c00              CMP      r4,#0
000204  d113              BNE      |L1.558|
;;;600      {
;;;601        result = (USB_CurrentSetupPacket.mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
000206  4816              LDR      r0,|L1.608|
000208  7800              LDRB     r0,[r0,#0]  ; USB_CurrentSetupPacket
00020a  2180              MOVS     r1,#0x80
00020c  4008              ANDS     r0,r0,r1
00020e  2880              CMP      r0,#0x80
000210  d106              BNE      |L1.544|
;;;602                        USB_EP_doDataOut(USB_EP0, 0, 0, 0) :
000212  2300              MOVS     r3,#0
000214  461a              MOV      r2,r3
000216  4619              MOV      r1,r3
000218  4618              MOV      r0,r3
00021a  f7fffffe          BL       USB_EP_doDataOut
00021e  e005              B        |L1.556|
                  |L1.544|
;;;603                        USB_EP_doDataIn(USB_EP0, 0, 0, 0);
000220  2300              MOVS     r3,#0
000222  461a              MOV      r2,r3
000224  4619              MOV      r1,r3
000226  4618              MOV      r0,r3
000228  f7fffffe          BL       USB_EP_doDataIn
                  |L1.556|
00022c  b285              UXTH     r5,r0
                  |L1.558|
;;;604      }
;;;605    
;;;606      return result;
00022e  4628              MOV      r0,r5
;;;607    }
000230  bdf8              POP      {r3-r7,pc}
;;;608    
                          ENDP

                  USB_CDC_DummyDataReceive PROC
;;;742    
;;;743    USB_Result USB_CDC_DummyDataReceive(uint8_t* Buffer, uint32_t Length)
000232  4602              MOV      r2,r0
;;;744    {
;;;745      return USB_ERROR;
000234  2001              MOVS     r0,#1
;;;746    }
000236  4770              BX       lr
;;;747    
                          ENDP

                  USB_CDC_DummyDataSent PROC
;;;755    
;;;756    USB_Result USB_CDC_DummyDataSent(void)
000238  2001              MOVS     r0,#1
;;;757    {
;;;758      return USB_ERROR;
;;;759    }
00023a  4770              BX       lr
;;;760    
                          ENDP

                  USB_CDC_DummyGetLineCoding PROC
;;;863    
;;;864    USB_Result USB_CDC_DummyGetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA)
00023c  4602              MOV      r2,r0
;;;865    {
;;;866      return USB_ERROR;
00023e  2001              MOVS     r0,#1
;;;867    }
000240  4770              BX       lr
;;;868    
                          ENDP

                  USB_CDC_DummySetLineCoding PROC
;;;879    
;;;880    USB_Result USB_CDC_DummySetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA)
000242  4602              MOV      r2,r0
;;;881    {
;;;882      return USB_ERROR;
000244  2001              MOVS     r0,#1
;;;883    }
000246  4770              BX       lr
;;;884    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
                          ENDP

                  |L1.584|
                          DCD      USB_CDCContext
                  |L1.588|
                          DCD      USB_CDC_OnDataReceive
                  |L1.592|
                          DCD      USB_CDC_OnDataSent
                  |L1.596|
                          DCD      Usb_CDC_Device_Descriptor
                  |L1.600|
                          DCD      Usb_CDC_Configuration_Descriptor
                  |L1.604|
                          DCD      USB_DeviceDoStatusOutAck
                  |L1.608|
                          DCD      USB_CurrentSetupPacket
                  |L1.612|
                          DCD      USB_CDC_DoDataOut
                  |L1.616|
                          DCD      CDC_ClassPacketData

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_CDCContext
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  Usb_CDC_Device_Descriptor
000000  12011001          DCB      0x12,0x01,0x10,0x01
000004  02000020          DCB      0x02,0x00,0x00,0x20
000008  830425f1          DCB      0x83,0x04,0x25,0xf1
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  0001              DCB      0x00,0x01
                  Usb_CDC_Configuration_Descriptor
000012  0902              DCB      0x09,0x02
000014  43000201          DCB      0x43,0x00,0x02,0x01
000018  00c03209          DCB      0x00,0xc0,0x32,0x09
00001c  04000001          DCB      0x04,0x00,0x00,0x01
000020  02020100          DCB      0x02,0x02,0x01,0x00
000024  05240010          DCB      0x05,0x24,0x00,0x10
000028  01052401          DCB      0x01,0x05,0x24,0x01
00002c  00010424          DCB      0x00,0x01,0x04,0x24
000030  02060524          DCB      0x02,0x06,0x05,0x24
000034  06000107          DCB      0x06,0x00,0x01,0x07
000038  05820320          DCB      0x05,0x82,0x03,0x20
00003c  00020904          DCB      0x00,0x02,0x09,0x04
000040  0100020a          DCB      0x01,0x00,0x02,0x0a
000044  00000007          DCB      0x00,0x00,0x00,0x07
000048  05810220          DCB      0x05,0x81,0x02,0x20
00004c  00000705          DCB      0x00,0x00,0x07,0x05
000050  03022000          DCB      0x03,0x02,0x20,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
                  CDC_ClassPacketData
                          %        8

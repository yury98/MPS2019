; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --cpu=Cortex-M1 --apcs=interwork -O0 -I.\inc -IC:\Keil4\ARM\INC -IC:\Keil4\ARM\INC\ARM --omf_browse=.\obj\main.crf src\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Setup_USB PROC
;;;151    /* USB Device layer setup and powering on */
;;;152    void Setup_USB(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154      /* Enables the CPU_CLK clock on USB */
;;;155      RST_CLK_PCLKcmd(RST_CLK_PCLK_USB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RST_CLK_PCLKcmd
;;;156    
;;;157      /* Device layer initialization */
;;;158      USB_Clock_InitStruct.USB_USBC1_Source = USB_C1HSEdiv1;
00000a  2002              MOVS     r0,#2
00000c  493f              LDR      r1,|L1.268|
00000e  6008              STR      r0,[r1,#0]  ; USB_Clock_InitStruct
;;;159      USB_Clock_InitStruct.USB_PLLUSBMUL    = USB_PLLUSBMUL6;
000010  2005              MOVS     r0,#5
000012  6048              STR      r0,[r1,#4]  ; USB_Clock_InitStruct
;;;160    
;;;161      USB_DeviceBUSParam.MODE  = USB_SC_SCFSP_Full;
000014  2010              MOVS     r0,#0x10
000016  493e              LDR      r1,|L1.272|
000018  6088              STR      r0,[r1,#8]  ; USB_DeviceBUSParam
;;;162      USB_DeviceBUSParam.SPEED = USB_SC_SCFSR_12Mb;
00001a  2020              MOVS     r0,#0x20
00001c  6048              STR      r0,[r1,#4]  ; USB_DeviceBUSParam
;;;163      USB_DeviceBUSParam.PULL  = USB_HSCR_DP_PULLUP_Set;
00001e  2010              MOVS     r0,#0x10
000020  6008              STR      r0,[r1,#0]  ; USB_DeviceBUSParam
;;;164    
;;;165      USB_DeviceInit(&USB_Clock_InitStruct, &USB_DeviceBUSParam);
000022  483a              LDR      r0,|L1.268|
000024  f7fffffe          BL       USB_DeviceInit
;;;166    
;;;167      /* Enable all USB interrupts */
;;;168      USB_SetSIM(USB_SIS_Msk);
000028  201f              MOVS     r0,#0x1f
00002a  f7fffffe          BL       USB_SetSIM
;;;169    
;;;170      USB_DevicePowerOn();
00002e  f7fffffe          BL       USB_DevicePowerOn
;;;171    
;;;172      /* Enable interrupt on USB */
;;;173    #ifdef USB_INT_HANDLE_REQUIRED
;;;174      NVIC_EnableIRQ(USB_IRQn);
000032  bf00              NOP      
000034  2002              MOVS     r0,#2
000036  2101              MOVS     r1,#1
000038  4081              LSLS     r1,r1,r0
00003a  0940              LSRS     r0,r0,#5
00003c  0080              LSLS     r0,r0,#2
00003e  4a35              LDR      r2,|L1.276|
000040  1880              ADDS     r0,r0,r2
000042  6001              STR      r1,[r0,#0]
000044  bf00              NOP      
;;;175    #endif /* USB_INT_HANDLE_REQUIRED */
;;;176    
;;;177      USB_DEVICE_HANDLE_RESET;
000046  f7fffffe          BL       USB_CDC_Reset
;;;178    }
00004a  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  Setup_CPU_Clock PROC
;;;125    /* Frequencies setup */
;;;126    void Setup_CPU_Clock(void)
00004c  b510              PUSH     {r4,lr}
;;;127    {
;;;128      /* Enable HSE */
;;;129      RST_CLK_HSEconfig(RST_CLK_HSE_ON);
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       RST_CLK_HSEconfig
;;;130      while(RST_CLK_HSEstatus()!=SUCCESS)
000054  bf00              NOP      
                  |L1.86|
000056  f7fffffe          BL       RST_CLK_HSEstatus
00005a  2801              CMP      r0,#1
00005c  d1fb              BNE      |L1.86|
;;;131      {
;;;132        /* Wait */
;;;133      }
;;;134    
;;;135      /* CPU_C1_SEL = HSE */
;;;136      RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv2, RST_CLK_CPU_PLLmul4);
00005e  2103              MOVS     r1,#3
000060  4608              MOV      r0,r1
000062  f7fffffe          BL       RST_CLK_CPU_PLLconfig
;;;137      RST_CLK_CPU_PLLcmd(ENABLE);
000066  2001              MOVS     r0,#1
000068  f7fffffe          BL       RST_CLK_CPU_PLLcmd
;;;138      while(RST_CLK_CPU_PLLstatus()!=SUCCESS)
00006c  bf00              NOP      
                  |L1.110|
00006e  f7fffffe          BL       RST_CLK_CPU_PLLstatus
000072  2801              CMP      r0,#1
000074  d1fb              BNE      |L1.110|
;;;139      {
;;;140        /* Wait */
;;;141      }
;;;142    
;;;143      /* CPU_C3_SEL = CPU_C2_SEL */
;;;144      RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
000076  2000              MOVS     r0,#0
000078  f7fffffe          BL       RST_CLK_CPUclkPrescaler
;;;145      /* CPU_C2_SEL = PLL */
;;;146      RST_CLK_CPU_PLLuse(ENABLE);
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       RST_CLK_CPU_PLLuse
;;;147      /* HCLK_SEL = CPU_C3_SEL */
;;;148      RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
000082  20ff              MOVS     r0,#0xff
000084  3001              ADDS     r0,#1
000086  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;149    }
00008a  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  VCom_Configuration PROC
;;;181    /* Example-relating data initialization */
;;;182    static void VCom_Configuration(void)
00008c  20e1              MOVS     r0,#0xe1
;;;183    {
;;;184    #ifdef USB_CDC_LINE_CODING_SUPPORTED
;;;185      LineCoding.dwDTERate = 115200;
00008e  0240              LSLS     r0,r0,#9
000090  4921              LDR      r1,|L1.280|
000092  6008              STR      r0,[r1,#0]  ; LineCoding
;;;186      LineCoding.bCharFormat = 0;
000094  2000              MOVS     r0,#0
000096  7108              STRB     r0,[r1,#4]
;;;187      LineCoding.bParityType = 0;
000098  7148              STRB     r0,[r1,#5]
;;;188      LineCoding.bDataBits = 8;
00009a  2008              MOVS     r0,#8
00009c  7188              STRB     r0,[r1,#6]
;;;189    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
;;;190    }
00009e  4770              BX       lr
;;;191    
                          ENDP

                  main PROC
;;;100    #ifdef __CC_ARM
;;;101    int main(void)
0000a0  2000              MOVS     r0,#0
;;;102    #else
;;;103    void main(void)
;;;104    #endif
;;;105    {
;;;106      RST_CLK->PER_CLOCK=0xFFFFFFFF;
0000a2  43c0              MVNS     r0,r0
0000a4  491d              LDR      r1,|L1.284|
0000a6  61c8              STR      r0,[r1,#0x1c]
;;;107      VCom_Configuration();
0000a8  f7fffffe          BL       VCom_Configuration
;;;108    
;;;109      /* CDC layer initialization */
;;;110      USB_CDC_Init(Buffer, 1, SET);
0000ac  2201              MOVS     r2,#1
0000ae  4611              MOV      r1,r2
0000b0  481b              LDR      r0,|L1.288|
0000b2  f7fffffe          BL       USB_CDC_Init
;;;111    
;;;112      EEPROM->CMD=0<<3;
0000b6  2000              MOVS     r0,#0
0000b8  491a              LDR      r1,|L1.292|
0000ba  6008              STR      r0,[r1,#0]
;;;113    
;;;114      Setup_CPU_Clock();
0000bc  f7fffffe          BL       Setup_CPU_Clock
;;;115      Setup_USB();
0000c0  f7fffffe          BL       Setup_USB
;;;116    
;;;117    /* Main loop */
;;;118      while (1)
0000c4  bf00              NOP      
                  |L1.198|
0000c6  e7fe              B        |L1.198|
;;;119      {
;;;120      }
;;;121    
;;;122    }
;;;123    
                          ENDP

                  USB_CDC_RecieveData PROC
;;;193    /* USB_CDC_HANDLE_DATA_RECEIVE implementation - data echoing */
;;;194    USB_Result USB_CDC_RecieveData(uint8_t* Buffer, uint32_t Length)
0000c8  b570              PUSH     {r4-r6,lr}
;;;195    {
0000ca  4604              MOV      r4,r0
0000cc  460d              MOV      r5,r1
;;;196      USB_Result result;
;;;197    
;;;198    #ifdef USB_DEBUG_PROTO
;;;199      ReceivedByteCount += Length;
;;;200    #endif /* USB_DEBUG_PROTO */
;;;201    
;;;202      /* Send back received data portion */
;;;203      result = USB_CDC_SendData(Buffer, Length);
0000ce  4629              MOV      r1,r5
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       USB_CDC_SendData
0000d6  4606              MOV      r6,r0
;;;204    
;;;205    #ifdef USB_DEBUG_PROTO
;;;206      if (result == USB_SUCCESS)
;;;207      {
;;;208        SentByteCount += Length;
;;;209      }
;;;210    #ifndef USB_VCOM_SYNC
;;;211      else
;;;212      {
;;;213        SkippedByteCount += Length;
;;;214      }
;;;215    #endif /* !USB_VCOM_SYNC */
;;;216    #endif /* USB_DEBUG_PROTO */
;;;217    
;;;218    #ifdef USB_VCOM_SYNC
;;;219      if (result != USB_SUCCESS)
;;;220      {
;;;221        /* If data cannot be sent now, it will await nearest possibility
;;;222         * (see USB_CDC_DataSent) */
;;;223        PendingDataLength = Length;
;;;224      }
;;;225      return result;
;;;226    #else
;;;227      return USB_SUCCESS;
0000d8  2000              MOVS     r0,#0
;;;228    #endif /* USB_VCOM_SYNC */
;;;229    }
0000da  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  USB_CDC_GetLineCoding PROC
;;;263    /* USB_CDC_HANDLE_GET_LINE_CODING implementation example */
;;;264    USB_Result USB_CDC_GetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA)
0000dc  4602              MOV      r2,r0
;;;265    {
;;;266      assert_param(DATA);
;;;267      if (wINDEX != 0)
0000de  2a00              CMP      r2,#0
0000e0  d001              BEQ      |L1.230|
;;;268      {
;;;269        /* Invalid interface */
;;;270        return USB_ERR_INV_REQ;
0000e2  2002              MOVS     r0,#2
                  |L1.228|
;;;271      }
;;;272    
;;;273      /* Just store received settings */
;;;274      *DATA = LineCoding;
;;;275      return USB_SUCCESS;
;;;276    }
0000e4  4770              BX       lr
                  |L1.230|
0000e6  4b0c              LDR      r3,|L1.280|
0000e8  cb09              LDM      r3,{r0,r3}            ;274
0000ea  604b              STR      r3,[r1,#4]            ;274
0000ec  6008              STR      r0,[r1,#0]            ;274
0000ee  2000              MOVS     r0,#0                 ;275
0000f0  e7f8              B        |L1.228|
;;;277    
                          ENDP

                  USB_CDC_SetLineCoding PROC
;;;278    /* USB_CDC_HANDLE_SET_LINE_CODING implementation example */
;;;279    USB_Result USB_CDC_SetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA)
0000f2  b510              PUSH     {r4,lr}
;;;280    {
0000f4  4602              MOV      r2,r0
;;;281      assert_param(DATA);
;;;282      if (wINDEX != 0)
0000f6  2a00              CMP      r2,#0
0000f8  d001              BEQ      |L1.254|
;;;283      {
;;;284        /* Invalid interface */
;;;285        return USB_ERR_INV_REQ;
0000fa  2002              MOVS     r0,#2
                  |L1.252|
;;;286      }
;;;287    
;;;288      /* Just send back settings stored earlier */
;;;289      LineCoding = *DATA;
;;;290      return USB_SUCCESS;
;;;291    }
0000fc  bd10              POP      {r4,pc}
                  |L1.254|
0000fe  4806              LDR      r0,|L1.280|
000100  684c              LDR      r4,[r1,#4]            ;289
000102  680b              LDR      r3,[r1,#0]            ;289
000104  c018              STM      r0!,{r3,r4}           ;289
000106  2000              MOVS     r0,#0                 ;290
000108  e7f8              B        |L1.252|
;;;292    
                          ENDP

00010a  0000              DCW      0x0000
                  |L1.268|
                          DCD      USB_Clock_InitStruct
                  |L1.272|
                          DCD      USB_DeviceBUSParam
                  |L1.276|
                          DCD      0xe000e100
                  |L1.280|
                          DCD      LineCoding
                  |L1.284|
                          DCD      0x40020000
                  |L1.288|
                          DCD      Buffer
                  |L1.292|
                          DCD      0x40018000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_DeviceBUSParam
                          %        12
                  Buffer
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  USB_Clock_InitStruct
                          %        8
                  LineCoding
                          %        8

                  __ARM_use_no_argv EQU 0

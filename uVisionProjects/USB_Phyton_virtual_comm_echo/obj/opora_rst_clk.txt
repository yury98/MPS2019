; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--debug -c --asm --interleave -o.\obj\opora_rst_clk.o --depend=.\obj\opora_rst_clk.d --cpu=Cortex-M1 --apcs=interwork -O0 -I.\inc -IC:\Keil4\ARM\INC -IC:\Keil4\ARM\INC\ARM --omf_browse=.\obj\opora_rst_clk.crf src\opora_rst_clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;959      */
;;;960    void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;961    {
;;;962      /* Check the parameters */
;;;963      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;964      assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;965      if (NewState != DISABLE)
000002  d005              BEQ      |L1.16|
;;;966      {
;;;967        RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000004  4af8              LDR      r2,|L1.1000|
000006  69d2              LDR      r2,[r2,#0x1c]
000008  4302              ORRS     r2,r2,r0
00000a  4bf7              LDR      r3,|L1.1000|
00000c  61da              STR      r2,[r3,#0x1c]
00000e  e004              B        |L1.26|
                  |L1.16|
;;;968      }
;;;969      else
;;;970      {
;;;971        RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
000010  4af5              LDR      r2,|L1.1000|
000012  69d2              LDR      r2,[r2,#0x1c]
000014  4382              BICS     r2,r2,r0
000016  4bf4              LDR      r3,|L1.1000|
000018  61da              STR      r2,[r3,#0x1c]
                  |L1.26|
;;;972      }
;;;973    }
00001a  4770              BX       lr
;;;974    
                          ENDP

                  RST_CLK_CPUclkSelection PROC
;;;595      */
;;;596    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
00001c  4601              MOV      r1,r0
;;;597    {
;;;598      uint32_t temp;
;;;599    
;;;600      /* Check the parameters */
;;;601      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;602    
;;;603      temp = RST_CLK->CPU_CLOCK;
00001e  4af2              LDR      r2,|L1.1000|
000020  68d0              LDR      r0,[r2,#0xc]
;;;604      /* Clear CPU_C3_SEL bits */
;;;605      temp &= CPU_HCLK_SELclr;
000022  2303              MOVS     r3,#3
000024  021b              LSLS     r3,r3,#8
000026  4602              MOV      r2,r0
000028  439a              BICS     r2,r2,r3
00002a  4610              MOV      r0,r2
;;;606      /* Set the CPU_C3_SEL bits */
;;;607      temp |= CPU_CLK;
00002c  4602              MOV      r2,r0
00002e  430a              ORRS     r2,r2,r1
000030  4610              MOV      r0,r2
;;;608      /* Store the new value */
;;;609      RST_CLK->CPU_CLOCK = temp;
000032  4aed              LDR      r2,|L1.1000|
000034  60d0              STR      r0,[r2,#0xc]
;;;610    }
000036  4770              BX       lr
;;;611    
                          ENDP

                  RST_CLK_GetFlagStatus PROC
;;;1155     */
;;;1156   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
000038  b510              PUSH     {r4,lr}
;;;1157   {
00003a  4601              MOV      r1,r0
;;;1158     uint32_t statusreg;
;;;1159     FlagStatus bitstatus;
;;;1160   
;;;1161     /* Check the parameters */
;;;1162     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1163   
;;;1164     /* Get the register */
;;;1165     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
00003c  23e0              MOVS     r3,#0xe0
00003e  400b              ANDS     r3,r3,r1
000040  2b20              CMP      r3,#0x20
000042  d102              BNE      |L1.74|
;;;1166     {
;;;1167       statusreg = RST_CLK->CLOCK_STATUS;
000044  4be8              LDR      r3,|L1.1000|
000046  681a              LDR      r2,[r3,#0]
000048  e001              B        |L1.78|
                  |L1.74|
;;;1168     }
;;;1169     else                                                  /* The flag to check is in REG_0F register */
;;;1170     {
;;;1171       statusreg = BKP->REG_0F;
00004a  4be8              LDR      r3,|L1.1004|
00004c  6bda              LDR      r2,[r3,#0x3c]
                  |L1.78|
;;;1172     }
;;;1173   
;;;1174     /* Get the flag status on proper position */
;;;1175     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
00004e  06cc              LSLS     r4,r1,#27
000050  0ee4              LSRS     r4,r4,#27
000052  2301              MOVS     r3,#1
000054  40a3              LSLS     r3,r3,r4
000056  4213              TST      r3,r2
000058  d001              BEQ      |L1.94|
;;;1176     {
;;;1177       bitstatus = SET;
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L1.96|
                  |L1.94|
;;;1178     }
;;;1179     else
;;;1180     {
;;;1181       bitstatus = RESET;
00005e  2000              MOVS     r0,#0
                  |L1.96|
;;;1182     }
;;;1183   
;;;1184     /* Return the flag status */
;;;1185     return bitstatus;
;;;1186   }
000060  bd10              POP      {r4,pc}
;;;1187   
                          ENDP

                  RST_CLK_HSIstatus PROC
;;;373      */
;;;374    ErrorStatus RST_CLK_HSIstatus(void)
000062  b570              PUSH     {r4-r6,lr}
;;;375    {
;;;376      __IO uint32_t startCounter = 0;
000064  2600              MOVS     r6,#0
;;;377      ErrorStatus state;
;;;378      FlagStatus flag;
;;;379    
;;;380      /* Wait until HSI is ready or time out is occure */
;;;381      do
000066  bf00              NOP      
                  |L1.104|
;;;382      {
;;;383        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
000068  2017              MOVS     r0,#0x17
00006a  f7fffffe          BL       RST_CLK_GetFlagStatus
00006e  4605              MOV      r5,r0
;;;384        startCounter++;
000070  1c76              ADDS     r6,r6,#1
;;;385      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000072  2003              MOVS     r0,#3
000074  0240              LSLS     r0,r0,#9
000076  4286              CMP      r6,r0
000078  d201              BCS      |L1.126|
00007a  2d00              CMP      r5,#0
00007c  d0f4              BEQ      |L1.104|
                  |L1.126|
;;;386    
;;;387      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
00007e  2017              MOVS     r0,#0x17
000080  f7fffffe          BL       RST_CLK_GetFlagStatus
000084  2800              CMP      r0,#0
000086  d001              BEQ      |L1.140|
;;;388      {
;;;389        state = SUCCESS;
000088  2401              MOVS     r4,#1
00008a  e000              B        |L1.142|
                  |L1.140|
;;;390      }
;;;391      else
;;;392      {
;;;393        state = ERROR;
00008c  2400              MOVS     r4,#0
                  |L1.142|
;;;394      }
;;;395      return state;
00008e  4620              MOV      r0,r4
;;;396    }
000090  bd70              POP      {r4-r6,pc}
;;;397    
                          ENDP

                  RST_CLK_HSIcmd PROC
;;;340      */
;;;341    void RST_CLK_HSIcmd(FunctionalState NewState)
000092  49d7              LDR      r1,|L1.1008|
;;;342    {
;;;343      /* Check the parameters */
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000094  0149              LSLS     r1,r1,#5
000096  2221              MOVS     r2,#0x21
000098  0652              LSLS     r2,r2,#25
00009a  1889              ADDS     r1,r1,r2
00009c  6588              STR      r0,[r1,#0x58]
;;;347    }
00009e  4770              BX       lr
;;;348    
                          ENDP

                  RST_CLK_WarmDeInit PROC
;;;183      */
;;;184    void RST_CLK_WarmDeInit(void)
0000a0  b500              PUSH     {lr}
;;;185    {
;;;186      /* Prepare HSI clk */
;;;187      RST_CLK_HSIcmd(ENABLE);
0000a2  2001              MOVS     r0,#1
0000a4  f7fffffe          BL       RST_CLK_HSIcmd
;;;188      RST_CLK_HSIstatus();
0000a8  f7fffffe          BL       RST_CLK_HSIstatus
;;;189      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;190    
;;;191      /* Reset CPU_CLOCK bits */
;;;192      RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
0000b2  48cd              LDR      r0,|L1.1000|
0000b4  68c0              LDR      r0,[r0,#0xc]
0000b6  2000              MOVS     r0,#0
0000b8  49cb              LDR      r1,|L1.1000|
0000ba  60c8              STR      r0,[r1,#0xc]
;;;193    
;;;194      /* Reset PLL_CONTROL bits */
;;;195      RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
0000bc  4608              MOV      r0,r1
0000be  6840              LDR      r0,[r0,#4]
0000c0  2000              MOVS     r0,#0
0000c2  6048              STR      r0,[r1,#4]
;;;196    
;;;197      /* Reset HSEON and HSEBYP bits */
;;;198      RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
0000c4  4608              MOV      r0,r1
0000c6  6880              LDR      r0,[r0,#8]
0000c8  2000              MOVS     r0,#0
0000ca  6088              STR      r0,[r1,#8]
;;;199    
;;;200      /* Reset USB_CLOCK bits */
;;;201      RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
0000cc  4608              MOV      r0,r1
0000ce  6900              LDR      r0,[r0,#0x10]
0000d0  2000              MOVS     r0,#0
0000d2  6108              STR      r0,[r1,#0x10]
;;;202    
;;;203      /* Reset ADC_MCO_CLOCK bits */
;;;204      RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
0000d4  4608              MOV      r0,r1
0000d6  6940              LDR      r0,[r0,#0x14]
0000d8  2000              MOVS     r0,#0
0000da  6148              STR      r0,[r1,#0x14]
;;;205    
;;;206      /* Reset RTC_CLOCK bits */
;;;207      RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
0000dc  4608              MOV      r0,r1
0000de  6980              LDR      r0,[r0,#0x18]
0000e0  2000              MOVS     r0,#0
0000e2  6188              STR      r0,[r1,#0x18]
;;;208    
;;;209      /* Reset all clock but RTC_CLK bit */
;;;210      RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(RST_CLK_BASE) | (uint32_t)PCLK_BIT(BKP_BASE);
0000e4  48c3              LDR      r0,|L1.1012|
0000e6  61c8              STR      r0,[r1,#0x1c]
;;;211    }
0000e8  bd00              POP      {pc}
;;;212    
                          ENDP

                  RST_CLK_DeInit PROC
;;;168      */
;;;169    void RST_CLK_DeInit(void)
0000ea  b500              PUSH     {lr}
;;;170    {
;;;171      RST_CLK_WarmDeInit();
0000ec  f7fffffe          BL       RST_CLK_WarmDeInit
;;;172      /* Reset REG_0F bits to zero but HSION bit */
;;;173      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  06c8              LSLS     r0,r1,#27
0000f4  f7fffffe          BL       RST_CLK_PCLKcmd
;;;174      BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
0000f8  48bc              LDR      r0,|L1.1004|
0000fa  6bc0              LDR      r0,[r0,#0x3c]
0000fc  2181              MOVS     r1,#0x81
0000fe  03c9              LSLS     r1,r1,#15
000100  4308              ORRS     r0,r0,r1
000102  49ba              LDR      r1,|L1.1004|
000104  63c8              STR      r0,[r1,#0x3c]
;;;175      BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
000106  4608              MOV      r0,r1
000108  6bc0              LDR      r0,[r0,#0x3c]
00010a  2181              MOVS     r1,#0x81
00010c  03c9              LSLS     r1,r1,#15
00010e  4008              ANDS     r0,r0,r1
000110  49b6              LDR      r1,|L1.1004|
000112  63c8              STR      r0,[r1,#0x3c]
;;;176    }
000114  bd00              POP      {pc}
;;;177    
                          ENDP

                  RST_CLK_HSEconfig PROC
;;;220      */
;;;221    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
000116  49b4              LDR      r1,|L1.1000|
;;;222    {
;;;223      /* Check the parameters */
;;;224      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;225      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;226      RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
000118  6889              LDR      r1,[r1,#8]
00011a  0889              LSRS     r1,r1,#2
00011c  0089              LSLS     r1,r1,#2
00011e  4ab2              LDR      r2,|L1.1000|
000120  6091              STR      r1,[r2,#8]
;;;227      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;228      switch (RST_CLK_HSE)
000122  2801              CMP      r0,#1
000124  d002              BEQ      |L1.300|
000126  2802              CMP      r0,#2
000128  d10e              BNE      |L1.328|
00012a  e006              B        |L1.314|
                  |L1.300|
;;;229      {
;;;230        case RST_CLK_HSE_ON:
;;;231          /* Set HSEON bit */
;;;232          RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
00012c  49ae              LDR      r1,|L1.1000|
00012e  6889              LDR      r1,[r1,#8]
000130  2201              MOVS     r2,#1
000132  4311              ORRS     r1,r1,r2
000134  4aac              LDR      r2,|L1.1000|
000136  6091              STR      r1,[r2,#8]
;;;233          break;
000138  e007              B        |L1.330|
                  |L1.314|
;;;234    
;;;235        case RST_CLK_HSE_Bypass:
;;;236          /* Set HSEBYP and HSEON bits */
;;;237          RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
00013a  49ab              LDR      r1,|L1.1000|
00013c  6889              LDR      r1,[r1,#8]
00013e  2203              MOVS     r2,#3
000140  4311              ORRS     r1,r1,r2
000142  4aa9              LDR      r2,|L1.1000|
000144  6091              STR      r1,[r2,#8]
;;;238          break;
000146  e000              B        |L1.330|
                  |L1.328|
;;;239    
;;;240        default:
;;;241          break;
000148  bf00              NOP      
                  |L1.330|
00014a  bf00              NOP                            ;233
;;;242      }
;;;243    }
00014c  4770              BX       lr
;;;244    
                          ENDP

                  RST_CLK_HSEstatus PROC
;;;249      */
;;;250    ErrorStatus RST_CLK_HSEstatus(void)
00014e  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252      __IO uint32_t startCounter = 0;
000150  2600              MOVS     r6,#0
;;;253      ErrorStatus state;
;;;254      FlagStatus flag;
;;;255    
;;;256      /* Wait until HSE is ready or time out is occure */
;;;257      do
000152  bf00              NOP      
                  |L1.340|
;;;258      {
;;;259        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
000154  2022              MOVS     r0,#0x22
000156  f7fffffe          BL       RST_CLK_GetFlagStatus
00015a  4605              MOV      r5,r0
;;;260        startCounter++;
00015c  1c76              ADDS     r6,r6,#1
;;;261      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
00015e  2003              MOVS     r0,#3
000160  0240              LSLS     r0,r0,#9
000162  4286              CMP      r6,r0
000164  d201              BCS      |L1.362|
000166  2d00              CMP      r5,#0
000168  d0f4              BEQ      |L1.340|
                  |L1.362|
;;;262    
;;;263      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
00016a  2022              MOVS     r0,#0x22
00016c  f7fffffe          BL       RST_CLK_GetFlagStatus
000170  2800              CMP      r0,#0
000172  d001              BEQ      |L1.376|
;;;264      {
;;;265        state = SUCCESS;
000174  2401              MOVS     r4,#1
000176  e000              B        |L1.378|
                  |L1.376|
;;;266      }
;;;267      else
;;;268      {
;;;269        state = ERROR;
000178  2400              MOVS     r4,#0
                  |L1.378|
;;;270      }
;;;271      return state;
00017a  4620              MOV      r0,r4
;;;272    }
00017c  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

                  RST_CLK_LSEconfig PROC
;;;281      */
;;;282    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
00017e  499b              LDR      r1,|L1.1004|
;;;283    {
;;;284      /* Check the parameters */
;;;285      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;286      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;287      BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
000180  6bc9              LDR      r1,[r1,#0x3c]
000182  0889              LSRS     r1,r1,#2
000184  0089              LSLS     r1,r1,#2
000186  4a99              LDR      r2,|L1.1004|
000188  63d1              STR      r1,[r2,#0x3c]
;;;288      switch (RST_CLK_LSE)
00018a  2801              CMP      r0,#1
00018c  d002              BEQ      |L1.404|
00018e  2802              CMP      r0,#2
000190  d10e              BNE      |L1.432|
000192  e006              B        |L1.418|
                  |L1.404|
;;;289      {
;;;290        case RST_CLK_LSE_ON:
;;;291          /* Set LSEON bit */
;;;292          BKP->REG_0F |= RST_CLK_LSE_ON;
000194  4995              LDR      r1,|L1.1004|
000196  6bc9              LDR      r1,[r1,#0x3c]
000198  2201              MOVS     r2,#1
00019a  4311              ORRS     r1,r1,r2
00019c  4a93              LDR      r2,|L1.1004|
00019e  63d1              STR      r1,[r2,#0x3c]
;;;293          break;
0001a0  e007              B        |L1.434|
                  |L1.418|
;;;294    
;;;295        case RST_CLK_LSE_Bypass:
;;;296          /* Set LSEBYP and LSEON bits */
;;;297          BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
0001a2  4992              LDR      r1,|L1.1004|
0001a4  6bc9              LDR      r1,[r1,#0x3c]
0001a6  2203              MOVS     r2,#3
0001a8  4311              ORRS     r1,r1,r2
0001aa  4a90              LDR      r2,|L1.1004|
0001ac  63d1              STR      r1,[r2,#0x3c]
;;;298          break;
0001ae  e000              B        |L1.434|
                  |L1.432|
;;;299    
;;;300        default:
;;;301          break;
0001b0  bf00              NOP      
                  |L1.434|
0001b2  bf00              NOP                            ;293
;;;302      }
;;;303    }
0001b4  4770              BX       lr
;;;304    
                          ENDP

                  RST_CLK_LSEstatus PROC
;;;309      */
;;;310    ErrorStatus RST_CLK_LSEstatus(void)
0001b6  b570              PUSH     {r4-r6,lr}
;;;311    {
;;;312      __IO uint32_t startCounter = 0;
0001b8  2600              MOVS     r6,#0
;;;313      ErrorStatus state;
;;;314      FlagStatus flag;
;;;315    
;;;316     /* Wait until LSE is ready or time out is occure */
;;;317     do
0001ba  bf00              NOP      
                  |L1.444|
;;;318      {
;;;319        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
0001bc  200d              MOVS     r0,#0xd
0001be  f7fffffe          BL       RST_CLK_GetFlagStatus
0001c2  4605              MOV      r5,r0
;;;320        startCounter++;
0001c4  1c76              ADDS     r6,r6,#1
;;;321      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
0001c6  2003              MOVS     r0,#3
0001c8  0240              LSLS     r0,r0,#9
0001ca  4286              CMP      r6,r0
0001cc  d201              BCS      |L1.466|
0001ce  2d00              CMP      r5,#0
0001d0  d0f4              BEQ      |L1.444|
                  |L1.466|
;;;322    
;;;323      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
0001d2  200d              MOVS     r0,#0xd
0001d4  f7fffffe          BL       RST_CLK_GetFlagStatus
0001d8  2800              CMP      r0,#0
0001da  d001              BEQ      |L1.480|
;;;324      {
;;;325        state = SUCCESS;
0001dc  2401              MOVS     r4,#1
0001de  e000              B        |L1.482|
                  |L1.480|
;;;326      }
;;;327      else
;;;328      {
;;;329        state = ERROR;
0001e0  2400              MOVS     r4,#0
                  |L1.482|
;;;330      }
;;;331      return state;
0001e2  4620              MOV      r0,r4
;;;332    }
0001e4  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

                  RST_CLK_HSIadjust PROC
;;;354      */
;;;355    void RST_CLK_HSIadjust(uint8_t HSItrimValue)
0001e6  4601              MOV      r1,r0
;;;356    {
;;;357      uint32_t temp;
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;360      temp = BKP->REG_0F;
0001e8  4a80              LDR      r2,|L1.1004|
0001ea  6bd0              LDR      r0,[r2,#0x3c]
;;;361      /* Clear HSITRIM[5:0] bits */
;;;362      temp &= ~HSITRIM_MASK;
0001ec  233f              MOVS     r3,#0x3f
0001ee  061b              LSLS     r3,r3,#24
0001f0  4602              MOV      r2,r0
0001f2  439a              BICS     r2,r2,r3
0001f4  4610              MOV      r0,r2
;;;363      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;364      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
0001f6  060a              LSLS     r2,r1,#24
0001f8  4310              ORRS     r0,r0,r2
;;;365      /* Store the new value */
;;;366      BKP->REG_0F = temp;
0001fa  4a7c              LDR      r2,|L1.1004|
0001fc  63d0              STR      r0,[r2,#0x3c]
;;;367    }
0001fe  4770              BX       lr
;;;368    
                          ENDP

                  RST_CLK_LSIcmd PROC
;;;404      */
;;;405    void RST_CLK_LSIcmd(FunctionalState NewState)
000200  497b              LDR      r1,|L1.1008|
;;;406    {
;;;407      /* Check the parameters */
;;;408      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;409    
;;;410      *(__IO uint32_t *) LSION_BB = (uint32_t)NewState;
000202  0149              LSLS     r1,r1,#5
000204  2221              MOVS     r2,#0x21
000206  0652              LSLS     r2,r2,#25
000208  1889              ADDS     r1,r1,r2
00020a  63c8              STR      r0,[r1,#0x3c]
;;;411    }
00020c  4770              BX       lr
;;;412    
                          ENDP

                  RST_CLK_LSIstatus PROC
;;;417      */
;;;418    ErrorStatus RST_CLK_LSIstatus(void)
00020e  b570              PUSH     {r4-r6,lr}
;;;419    {
;;;420      __IO uint32_t startCounter = 0;
000210  2600              MOVS     r6,#0
;;;421      ErrorStatus state;
;;;422      FlagStatus flag;
;;;423    
;;;424      /* Wait until LSI is ready or time out is occure */
;;;425      do
000212  bf00              NOP      
                  |L1.532|
;;;426      {
;;;427        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
000214  2015              MOVS     r0,#0x15
000216  f7fffffe          BL       RST_CLK_GetFlagStatus
00021a  4605              MOV      r5,r0
;;;428        startCounter++;
00021c  1c76              ADDS     r6,r6,#1
;;;429      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
00021e  2003              MOVS     r0,#3
000220  0240              LSLS     r0,r0,#9
000222  4286              CMP      r6,r0
000224  d201              BCS      |L1.554|
000226  2d00              CMP      r5,#0
000228  d0f4              BEQ      |L1.532|
                  |L1.554|
;;;430    
;;;431      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
00022a  2015              MOVS     r0,#0x15
00022c  f7fffffe          BL       RST_CLK_GetFlagStatus
000230  2800              CMP      r0,#0
000232  d001              BEQ      |L1.568|
;;;432      {
;;;433        state = SUCCESS;
000234  2401              MOVS     r4,#1
000236  e000              B        |L1.570|
                  |L1.568|
;;;434      }
;;;435      else
;;;436      {
;;;437        state = ERROR;
000238  2400              MOVS     r4,#0
                  |L1.570|
;;;438      }
;;;439      return (state);
00023a  4620              MOV      r0,r4
;;;440    }
00023c  bd70              POP      {r4-r6,pc}
;;;441    
                          ENDP

                  RST_CLK_CPU_PLLconfig PROC
;;;468      */
;;;469    void RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul)
00023e  b530              PUSH     {r4,r5,lr}
;;;470    {
000240  4602              MOV      r2,r0
;;;471      uint32_t temp;
;;;472    
;;;473      /* Check the parameters */
;;;474      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;475      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;476    
;;;477      /* Select CPUPLL source */
;;;478      temp = RST_CLK->CPU_CLOCK;
000242  4b69              LDR      r3,|L1.1000|
000244  68d8              LDR      r0,[r3,#0xc]
;;;479      /* Clear CPU_C1_SEL bits */
;;;480      temp &= CPU_C1_SELclr;
000246  0880              LSRS     r0,r0,#2
000248  0080              LSLS     r0,r0,#2
;;;481      /* Set the CPU_C1_SEL bits */
;;;482      temp |= RST_CLK_CPU_PLLsource;
00024a  4603              MOV      r3,r0
00024c  4313              ORRS     r3,r3,r2
00024e  4618              MOV      r0,r3
;;;483      /* Store the new value */
;;;484      RST_CLK->CPU_CLOCK = temp;
000250  4b65              LDR      r3,|L1.1000|
000252  60d8              STR      r0,[r3,#0xc]
;;;485    
;;;486      /* Set CPUPLL multiplier */
;;;487      temp = RST_CLK->PLL_CONTROL;
000254  6858              LDR      r0,[r3,#4]
;;;488      /* Clear PLLMUL[3:0] bits */
;;;489      temp &= PLLCPUmulclr;
000256  240f              MOVS     r4,#0xf
000258  0224              LSLS     r4,r4,#8
00025a  4603              MOV      r3,r0
00025c  43a3              BICS     r3,r3,r4
00025e  4618              MOV      r0,r3
;;;490      /* Set the PLLMUL[3:0] bits */
;;;491      temp |= (RST_CLK_CPU_PLLmul<<PLLCPUMUL_OFFSET);
000260  020b              LSLS     r3,r1,#8
000262  4318              ORRS     r0,r0,r3
;;;492      /* Store the new value */
;;;493      RST_CLK->PLL_CONTROL = temp;
000264  4b60              LDR      r3,|L1.1000|
000266  6058              STR      r0,[r3,#4]
;;;494    
;;;495      if ( *(__IO uint32_t *) PLLCPUON_BB)
000268  4b63              LDR      r3,|L1.1016|
00026a  015b              LSLS     r3,r3,#5
00026c  2421              MOVS     r4,#0x21
00026e  0664              LSLS     r4,r4,#25
000270  191b              ADDS     r3,r3,r4
000272  689b              LDR      r3,[r3,#8]
000274  2b00              CMP      r3,#0
000276  d006              BEQ      |L1.646|
;;;496      {
;;;497         *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t)0x01;
000278  2401              MOVS     r4,#1
00027a  4b5f              LDR      r3,|L1.1016|
00027c  015b              LSLS     r3,r3,#5
00027e  2521              MOVS     r5,#0x21
000280  066d              LSLS     r5,r5,#25
000282  195b              ADDS     r3,r3,r5
000284  60dc              STR      r4,[r3,#0xc]
                  |L1.646|
;;;498      }
;;;499    }
000286  bd30              POP      {r4,r5,pc}
;;;500    
                          ENDP

                  RST_CLK_CPU_PLLuse PROC
;;;505      */
;;;506    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
000288  4957              LDR      r1,|L1.1000|
;;;507    {
;;;508      /* Check the parameters */
;;;509      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;510    
;;;511     // *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t)UsePLL;
;;;512     RST_CLK->CPU_CLOCK|=1<<2;
00028a  68c9              LDR      r1,[r1,#0xc]
00028c  2204              MOVS     r2,#4
00028e  4311              ORRS     r1,r1,r2
000290  4a55              LDR      r2,|L1.1000|
000292  60d1              STR      r1,[r2,#0xc]
;;;513    }
000294  4770              BX       lr
;;;514    
                          ENDP

                  RST_CLK_CPU_PLLcmd PROC
;;;519      */
;;;520    void RST_CLK_CPU_PLLcmd(FunctionalState NewState)
000296  4954              LDR      r1,|L1.1000|
;;;521    {
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;523    
;;;524     // *(__IO uint32_t *) PLLCPUON_BB = (uint32_t)NewState;
;;;525     RST_CLK->PLL_CONTROL|=1<<2;
000298  6849              LDR      r1,[r1,#4]
00029a  2204              MOVS     r2,#4
00029c  4311              ORRS     r1,r1,r2
00029e  4a52              LDR      r2,|L1.1000|
0002a0  6051              STR      r1,[r2,#4]
;;;526    }
0002a2  4770              BX       lr
;;;527    
                          ENDP

                  RST_CLK_CPU_PLLstatus PROC
;;;532      */
;;;533    ErrorStatus RST_CLK_CPU_PLLstatus(void)
0002a4  b570              PUSH     {r4-r6,lr}
;;;534    {
;;;535      __IO uint32_t startCounter = 0;
0002a6  2600              MOVS     r6,#0
;;;536      ErrorStatus state;
;;;537      FlagStatus flag;
;;;538    
;;;539      /* Wait until CPUPLL is ready or time out is occure */
;;;540      do
0002a8  bf00              NOP      
                  |L1.682|
;;;541      {
;;;542        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
0002aa  2021              MOVS     r0,#0x21
0002ac  f7fffffe          BL       RST_CLK_GetFlagStatus
0002b0  4605              MOV      r5,r0
;;;543        startCounter++;
0002b2  1c76              ADDS     r6,r6,#1
;;;544      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
0002b4  2003              MOVS     r0,#3
0002b6  0240              LSLS     r0,r0,#9
0002b8  4286              CMP      r6,r0
0002ba  d201              BCS      |L1.704|
0002bc  2d00              CMP      r5,#0
0002be  d0f4              BEQ      |L1.682|
                  |L1.704|
;;;545    
;;;546      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
0002c0  2021              MOVS     r0,#0x21
0002c2  f7fffffe          BL       RST_CLK_GetFlagStatus
0002c6  2800              CMP      r0,#0
0002c8  d001              BEQ      |L1.718|
;;;547      {
;;;548        state = SUCCESS;
0002ca  2401              MOVS     r4,#1
0002cc  e000              B        |L1.720|
                  |L1.718|
;;;549      }
;;;550      else
;;;551      {
;;;552        state = ERROR;
0002ce  2400              MOVS     r4,#0
                  |L1.720|
;;;553      }
;;;554      return state;
0002d0  4620              MOV      r0,r4
;;;555    }
0002d2  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP

                  RST_CLK_CPUclkPrescaler PROC
;;;570      */
;;;571    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
0002d4  4601              MOV      r1,r0
;;;572    {
;;;573      uint32_t temp;
;;;574    
;;;575      /* Check the parameters */
;;;576      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;577    
;;;578      temp = RST_CLK->CPU_CLOCK;
0002d6  4a44              LDR      r2,|L1.1000|
0002d8  68d0              LDR      r0,[r2,#0xc]
;;;579      /* Clear CPU_C3_SEL bits */
;;;580      temp &= CPU_C3_SELclr;
0002da  23f0              MOVS     r3,#0xf0
0002dc  4602              MOV      r2,r0
0002de  439a              BICS     r2,r2,r3
0002e0  4610              MOV      r0,r2
;;;581      /* Set the CPU_C3_SEL bits */
;;;582      temp |= CPUclkDivValue;
0002e2  4602              MOV      r2,r0
0002e4  430a              ORRS     r2,r2,r1
0002e6  4610              MOV      r0,r2
;;;583      /* Store the new value */
;;;584      RST_CLK->CPU_CLOCK = temp;
0002e8  4a3f              LDR      r2,|L1.1000|
0002ea  60d0              STR      r0,[r2,#0xc]
;;;585    }
0002ec  4770              BX       lr
;;;586    
                          ENDP

                  RST_CLK_USB_PLLconfig PROC
;;;638      */
;;;639    void RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul)
0002ee  b530              PUSH     {r4,r5,lr}
;;;640    {
0002f0  4602              MOV      r2,r0
;;;641      uint32_t temp;
;;;642    
;;;643      /* Check the parameters */
;;;644      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;645      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;646    
;;;647      /* Select USBPLL source */
;;;648      temp = RST_CLK->USB_CLOCK;
0002f2  4b3d              LDR      r3,|L1.1000|
0002f4  6918              LDR      r0,[r3,#0x10]
;;;649      /* Clear USB_C1_SEL bits */
;;;650      temp &= USB_C1_SELclr;
0002f6  0880              LSRS     r0,r0,#2
0002f8  0080              LSLS     r0,r0,#2
;;;651      /* Set the USB_C1_SEL bits */
;;;652      temp |= RST_CLK_USB_PLLsource;
0002fa  4603              MOV      r3,r0
0002fc  4313              ORRS     r3,r3,r2
0002fe  4618              MOV      r0,r3
;;;653      /* Store the new value */
;;;654      RST_CLK->USB_CLOCK = temp;
000300  4b39              LDR      r3,|L1.1000|
000302  6118              STR      r0,[r3,#0x10]
;;;655    
;;;656      /* Set USBPLL multiplier */
;;;657      temp = RST_CLK->PLL_CONTROL;
000304  6858              LDR      r0,[r3,#4]
;;;658      /* Clear PLLMUL[3:0] bits */
;;;659      temp &= PLLUSBmulclr;
000306  24f0              MOVS     r4,#0xf0
000308  4603              MOV      r3,r0
00030a  43a3              BICS     r3,r3,r4
00030c  4618              MOV      r0,r3
;;;660      /* Set the PLLMUL[3:0] bits */
;;;661      temp |= (RST_CLK_USB_PLLmul<<PLLUSBMUL_OFFSET);
00030e  010b              LSLS     r3,r1,#4
000310  4318              ORRS     r0,r0,r3
;;;662      /* Store the new value */
;;;663      RST_CLK->PLL_CONTROL = temp;
000312  4b35              LDR      r3,|L1.1000|
000314  6058              STR      r0,[r3,#4]
;;;664    
;;;665      if ( *(__IO uint32_t *) PLLUSBON_BB)
000316  4b38              LDR      r3,|L1.1016|
000318  015b              LSLS     r3,r3,#5
00031a  2421              MOVS     r4,#0x21
00031c  0664              LSLS     r4,r4,#25
00031e  191b              ADDS     r3,r3,r4
000320  681b              LDR      r3,[r3,#0]
000322  2b00              CMP      r3,#0
000324  d006              BEQ      |L1.820|
;;;666      {
;;;667        *(__IO uint32_t *) PLLUSBRLD_BB  = (uint32_t)0x01;
000326  2401              MOVS     r4,#1
000328  4b33              LDR      r3,|L1.1016|
00032a  015b              LSLS     r3,r3,#5
00032c  2521              MOVS     r5,#0x21
00032e  066d              LSLS     r5,r5,#25
000330  195b              ADDS     r3,r3,r5
000332  605c              STR      r4,[r3,#4]
                  |L1.820|
;;;668      }
;;;669    }
000334  bd30              POP      {r4,r5,pc}
;;;670    
                          ENDP

                  RST_CLK_USB_PLLuse PROC
;;;675      */
;;;676    void RST_CLK_USB_PLLuse(FunctionalState UsePLL)
000336  4930              LDR      r1,|L1.1016|
;;;677    {
;;;678      /* Check the parameters */
;;;679      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;680    
;;;681      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t)UsePLL;
000338  310c              ADDS     r1,r1,#0xc
00033a  0149              LSLS     r1,r1,#5
00033c  2221              MOVS     r2,#0x21
00033e  0652              LSLS     r2,r2,#25
000340  1889              ADDS     r1,r1,r2
000342  6088              STR      r0,[r1,#8]
;;;682    }
000344  4770              BX       lr
;;;683    
                          ENDP

                  RST_CLK_USB_PLLcmd PROC
;;;688      */
;;;689    void RST_CLK_USB_PLLcmd(FunctionalState NewState)
000346  492c              LDR      r1,|L1.1016|
;;;690    {
;;;691      /* Check the parameters */
;;;692      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;693    
;;;694      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t)NewState;
000348  0149              LSLS     r1,r1,#5
00034a  2221              MOVS     r2,#0x21
00034c  0652              LSLS     r2,r2,#25
00034e  1889              ADDS     r1,r1,r2
000350  6008              STR      r0,[r1,#0]
;;;695    }
000352  4770              BX       lr
;;;696    
                          ENDP

                  RST_CLK_USB_PLLstatus PROC
;;;701      */
;;;702    ErrorStatus RST_CLK_USB_PLLstatus(void)
000354  b570              PUSH     {r4-r6,lr}
;;;703    {
;;;704      __IO uint32_t startCounter = 0;
000356  2600              MOVS     r6,#0
;;;705      ErrorStatus state;
;;;706      FlagStatus flag;
;;;707    
;;;708      /* Wait until USBPLL is ready or time out is occure */
;;;709      do
000358  bf00              NOP      
                  |L1.858|
;;;710      {
;;;711        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
00035a  2020              MOVS     r0,#0x20
00035c  f7fffffe          BL       RST_CLK_GetFlagStatus
000360  4605              MOV      r5,r0
;;;712        startCounter++;
000362  1c76              ADDS     r6,r6,#1
;;;713      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
000364  2003              MOVS     r0,#3
000366  0240              LSLS     r0,r0,#9
000368  4286              CMP      r6,r0
00036a  d201              BCS      |L1.880|
00036c  2d00              CMP      r5,#0
00036e  d0f4              BEQ      |L1.858|
                  |L1.880|
;;;714    
;;;715      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
000370  2020              MOVS     r0,#0x20
000372  f7fffffe          BL       RST_CLK_GetFlagStatus
000376  2800              CMP      r0,#0
000378  d001              BEQ      |L1.894|
;;;716      {
;;;717        state = SUCCESS;
00037a  2401              MOVS     r4,#1
00037c  e000              B        |L1.896|
                  |L1.894|
;;;718      }
;;;719      else
;;;720      {
;;;721        state = ERROR;
00037e  2400              MOVS     r4,#0
                  |L1.896|
;;;722      }
;;;723      return state;
000380  4620              MOV      r0,r4
;;;724    }
000382  bd70              POP      {r4-r6,pc}
;;;725    
                          ENDP

                  RST_CLK_USBclkPrescaler PROC
;;;732      */
;;;733    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
000384  491c              LDR      r1,|L1.1016|
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;737    
;;;738      *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t)NewState;
000386  310c              ADDS     r1,r1,#0xc
000388  0149              LSLS     r1,r1,#5
00038a  2221              MOVS     r2,#0x21
00038c  0652              LSLS     r2,r2,#25
00038e  1889              ADDS     r1,r1,r2
000390  6208              STR      r0,[r1,#0x20]
;;;739    }
000392  4770              BX       lr
;;;740    
                          ENDP

                  RST_CLK_USBclkEnable PROC
;;;747      */
;;;748    void RST_CLK_USBclkEnable(FunctionalState NewState)
000394  4918              LDR      r1,|L1.1016|
;;;749    {
;;;750      /* Check the parameters */
;;;751      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;752    
;;;753      *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000396  310c              ADDS     r1,r1,#0xc
000398  0149              LSLS     r1,r1,#5
00039a  2221              MOVS     r2,#0x21
00039c  0652              LSLS     r2,r2,#25
00039e  1889              ADDS     r1,r1,r2
0003a0  6108              STR      r0,[r1,#0x10]
;;;754    }
0003a2  4770              BX       lr
;;;755    
                          ENDP

                  RST_CLK_ADCclkSelection PROC
;;;767      */
;;;768    void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
0003a4  4601              MOV      r1,r0
;;;769    {
;;;770      uint32_t temp;
;;;771    
;;;772      /* Check the parameters */
;;;773      assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;774    
;;;775      /* Select ADC_CLK source */
;;;776      temp = RST_CLK->ADC_MCO_CLOCK;
0003a6  4a10              LDR      r2,|L1.1000|
0003a8  6950              LDR      r0,[r2,#0x14]
;;;777      /* Clear ADC_C1,C2 SEL bits */
;;;778      temp &= ADC_C12_SELclr;
0003aa  2333              MOVS     r3,#0x33
0003ac  4602              MOV      r2,r0
0003ae  439a              BICS     r2,r2,r3
0003b0  4610              MOV      r0,r2
;;;779      /* Set the ADC_C1,C2 SEL bits */
;;;780      temp |= ADC_CLK;
0003b2  4602              MOV      r2,r0
0003b4  430a              ORRS     r2,r2,r1
0003b6  4610              MOV      r0,r2
;;;781      /* Store the new value */
;;;782      RST_CLK->ADC_MCO_CLOCK = temp;
0003b8  4a0b              LDR      r2,|L1.1000|
0003ba  6150              STR      r0,[r2,#0x14]
;;;783    }
0003bc  4770              BX       lr
;;;784    
                          ENDP

                  RST_CLK_ADCclkPrescaler PROC
;;;806      */
;;;807    void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
0003be  4601              MOV      r1,r0
;;;808    {
;;;809      uint32_t temp;
;;;810    
;;;811      /* Check the parameters */
;;;812      assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;813    
;;;814      temp = RST_CLK->ADC_MCO_CLOCK;
0003c0  4a09              LDR      r2,|L1.1000|
0003c2  6950              LDR      r0,[r2,#0x14]
;;;815      /* Clear ADC_C3_SEL bits */
;;;816      temp &= ADC_C3_SELclr;
0003c4  230f              MOVS     r3,#0xf
0003c6  021b              LSLS     r3,r3,#8
0003c8  4602              MOV      r2,r0
0003ca  439a              BICS     r2,r2,r3
0003cc  4610              MOV      r0,r2
;;;817      /* Set the ADC_C3_SEL bits */
;;;818      temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
0003ce  020a              LSLS     r2,r1,#8
0003d0  4310              ORRS     r0,r0,r2
;;;819      /* Store the new value */
;;;820      RST_CLK->ADC_MCO_CLOCK = temp;
0003d2  4a05              LDR      r2,|L1.1000|
0003d4  6150              STR      r0,[r2,#0x14]
;;;821    }
0003d6  4770              BX       lr
;;;822    
                          ENDP

                  RST_CLK_ADCclkEnable PROC
;;;829      */
;;;830    void RST_CLK_ADCclkEnable(FunctionalState NewState)
0003d8  4907              LDR      r1,|L1.1016|
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;834    
;;;835      *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t)NewState;
0003da  3110              ADDS     r1,r1,#0x10
0003dc  0149              LSLS     r1,r1,#5
0003de  2221              MOVS     r2,#0x21
0003e0  0652              LSLS     r2,r2,#25
0003e2  1889              ADDS     r1,r1,r2
0003e4  6348              STR      r0,[r1,#0x34]
;;;836    }
0003e6  4770              BX       lr
                  |L1.1000|
                          DCD      0x40020000
                  |L1.1004|
                          DCD      0x400d8000
                  |L1.1008|
                          DCD      0x000d803c
                  |L1.1012|
                          DCD      0x08000010
                  |L1.1016|
                          DCD      0x00020004
                          ENDP

                  RST_CLK_HSIclkPrescaler PROC
;;;859      */
;;;860    void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
0003fc  4601              MOV      r1,r0
;;;861    {
;;;862      uint32_t temp;
;;;863    
;;;864      /* Check the parameters */
;;;865      assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;866    
;;;867      temp = RST_CLK->RTC_CLOCK;
0003fe  4a82              LDR      r2,|L1.1544|
000400  6990              LDR      r0,[r2,#0x18]
;;;868      /* Clear HSI_SEL bits */
;;;869      temp &= HSI_SELclr;
000402  23f0              MOVS     r3,#0xf0
000404  4602              MOV      r2,r0
000406  439a              BICS     r2,r2,r3
000408  4610              MOV      r0,r2
;;;870      /* Set the HSI_SEL bits */
;;;871      temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
00040a  010a              LSLS     r2,r1,#4
00040c  4310              ORRS     r0,r0,r2
;;;872      /* Store the new value */
;;;873      RST_CLK->RTC_CLOCK = temp;
00040e  4a7e              LDR      r2,|L1.1544|
000410  6190              STR      r0,[r2,#0x18]
;;;874    }
000412  4770              BX       lr
;;;875    
                          ENDP

                  RST_CLK_RTC_HSIclkEnable PROC
;;;882      */
;;;883    void RST_CLK_RTC_HSIclkEnable(FunctionalState NewState)
000414  497d              LDR      r1,|L1.1548|
;;;884    {
;;;885      /* Check the parameters */
;;;886      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;887    
;;;888      *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t)NewState;
000416  0149              LSLS     r1,r1,#5
000418  2221              MOVS     r2,#0x21
00041a  0652              LSLS     r2,r2,#25
00041c  1889              ADDS     r1,r1,r2
00041e  6248              STR      r0,[r1,#0x24]
;;;889    }
000420  4770              BX       lr
;;;890    
                          ENDP

                  RST_CLK_HSEclkPrescaler PROC
;;;912      */
;;;913    void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
000422  4601              MOV      r1,r0
;;;914    {
;;;915      uint32_t temp;
;;;916    
;;;917      /* Check the parameters */
;;;918      assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;919    
;;;920      temp = RST_CLK->RTC_CLOCK;
000424  4a78              LDR      r2,|L1.1544|
000426  6990              LDR      r0,[r2,#0x18]
;;;921      /* Clear HSE_SEL bits */
;;;922      temp &= HSE_SELclr;
000428  0900              LSRS     r0,r0,#4
00042a  0100              LSLS     r0,r0,#4
;;;923      /* Set the HSE_SEL bits */
;;;924      temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
00042c  4602              MOV      r2,r0
00042e  430a              ORRS     r2,r2,r1
000430  4610              MOV      r0,r2
;;;925      /* Store the new value */
;;;926      RST_CLK->RTC_CLOCK = temp;
000432  4a75              LDR      r2,|L1.1544|
000434  6190              STR      r0,[r2,#0x18]
;;;927    }
000436  4770              BX       lr
;;;928    
                          ENDP

                  RST_CLK_RTC_HSEclkEnable PROC
;;;935      */
;;;936    void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
000438  4974              LDR      r1,|L1.1548|
;;;937    {
;;;938      /* Check the parameters */
;;;939      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;940    
;;;941      *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
00043a  0149              LSLS     r1,r1,#5
00043c  2221              MOVS     r2,#0x21
00043e  0652              LSLS     r2,r2,#25
000440  1889              ADDS     r1,r1,r2
000442  6208              STR      r0,[r1,#0x20]
;;;942    }
000444  4770              BX       lr
;;;943    
                          ENDP

                  RST_CLK_GetClocksFreq PROC
;;;981      */
;;;982    void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
000446  b5f0              PUSH     {r4-r7,lr}
;;;983    {
000448  b089              SUB      sp,sp,#0x24
00044a  4604              MOV      r4,r0
;;;984      uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;985      uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;986      uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;987      uint32_t hsi_c1_freq, hse_c1_freq;
;;;988      uint32_t pll_mul;
;;;989    
;;;990      /* Check the parameter */
;;;991      assert_param(RST_CLK_Clocks != 0);
;;;992    
;;;993      /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;994    
;;;995      /* Compute CPU_CLK frequency */
;;;996    
;;;997      /* Determine CPU_C1 frequency */
;;;998      if (*(__IO uint32_t *) CPU_C1_SEL1_BB)
00044c  486f              LDR      r0,|L1.1548|
00044e  380c              SUBS     r0,r0,#0xc
000450  0140              LSLS     r0,r0,#5
000452  2121              MOVS     r1,#0x21
000454  0649              LSLS     r1,r1,#25
000456  1840              ADDS     r0,r0,r1
000458  6840              LDR      r0,[r0,#4]
00045a  2800              CMP      r0,#0
00045c  d001              BEQ      |L1.1122|
;;;999      {
;;;1000       cpu_c1_freq = HSE_Value;
00045e  4d6c              LDR      r5,|L1.1552|
000460  e000              B        |L1.1124|
                  |L1.1122|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       cpu_c1_freq = HSI_Value;
000462  4d6b              LDR      r5,|L1.1552|
                  |L1.1124|
;;;1005     }
;;;1006   
;;;1007     if (*(__IO uint32_t *) CPU_C1_SEL0_BB)
000464  4869              LDR      r0,|L1.1548|
000466  380c              SUBS     r0,r0,#0xc
000468  0140              LSLS     r0,r0,#5
00046a  2121              MOVS     r1,#0x21
00046c  0649              LSLS     r1,r1,#25
00046e  1840              ADDS     r0,r0,r1
000470  6800              LDR      r0,[r0,#0]
000472  2800              CMP      r0,#0
000474  d000              BEQ      |L1.1144|
;;;1008     {
;;;1009       cpu_c1_freq /= 2;
000476  086d              LSRS     r5,r5,#1
                  |L1.1144|
;;;1010     }
;;;1011   
;;;1012     /* Determine CPU_C2 frequency */
;;;1013     cpu_c2_freq = cpu_c1_freq;
000478  462e              MOV      r6,r5
;;;1014   
;;;1015     if (*(__IO uint32_t *) CPU_C2_SEL_BB != 0)
00047a  4864              LDR      r0,|L1.1548|
00047c  380c              SUBS     r0,r0,#0xc
00047e  0140              LSLS     r0,r0,#5
000480  2121              MOVS     r1,#0x21
000482  0649              LSLS     r1,r1,#25
000484  1840              ADDS     r0,r0,r1
000486  6880              LDR      r0,[r0,#8]
000488  2800              CMP      r0,#0
00048a  d007              BEQ      |L1.1180|
;;;1016     {
;;;1017       /* Determine CPU PLL output frequency */
;;;1018       pll_mul = ((RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_OFFS) & (uint32_t)0x0F) + 1;
00048c  485e              LDR      r0,|L1.1544|
00048e  6840              LDR      r0,[r0,#4]
000490  0500              LSLS     r0,r0,#20
000492  0f00              LSRS     r0,r0,#28
000494  1c40              ADDS     r0,r0,#1
000496  9000              STR      r0,[sp,#0]
;;;1019       cpu_c2_freq *= pll_mul;
000498  9800              LDR      r0,[sp,#0]
00049a  4346              MULS     r6,r0,r6
                  |L1.1180|
;;;1020     }
;;;1021   
;;;1022     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1023     switch ((RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_OFFS) & (uint32_t)0x03)
00049c  485a              LDR      r0,|L1.1544|
00049e  68c0              LDR      r0,[r0,#0xc]
0004a0  0580              LSLS     r0,r0,#22
0004a2  0f80              LSRS     r0,r0,#30
0004a4  d004              BEQ      |L1.1200|
0004a6  2801              CMP      r0,#1
0004a8  d005              BEQ      |L1.1206|
0004aa  2802              CMP      r0,#2
0004ac  d11e              BNE      |L1.1260|
0004ae  e019              B        |L1.1252|
                  |L1.1200|
;;;1024     {
;;;1025       case 0 :
;;;1026         /* HSI */
;;;1027         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
0004b0  4857              LDR      r0,|L1.1552|
0004b2  6020              STR      r0,[r4,#0]
;;;1028         break;
0004b4  e01d              B        |L1.1266|
                  |L1.1206|
;;;1029       case 1 :
;;;1030         /* CPU_C3 */
;;;1031         /* Determine CPU_C3 frequency */
;;;1032         if (( RST_CLK->CPU_CLOCK >> RST_CLK_USB_CLOCK_CPU_C3_SEL_OFFS & (uint32_t)0x08) == 0x00)
0004b6  4854              LDR      r0,|L1.1544|
0004b8  68c0              LDR      r0,[r0,#0xc]
0004ba  0900              LSRS     r0,r0,#4
0004bc  2108              MOVS     r1,#8
0004be  4208              TST      r0,r1
0004c0  d101              BNE      |L1.1222|
;;;1033         {
;;;1034           cpu_c3_freq = cpu_c2_freq;
0004c2  9608              STR      r6,[sp,#0x20]
0004c4  e00b              B        |L1.1246|
                  |L1.1222|
;;;1035         }
;;;1036         else
;;;1037         {
;;;1038           cpu_c3_freq = cpu_c2_freq/(1 << ((RST_CLK->CPU_CLOCK >> RST_CLK_USB_CLOCK_CPU_C3_SEL_OFFS & (uint32_t)0x07) + 1));
0004c6  4850              LDR      r0,|L1.1544|
0004c8  68c0              LDR      r0,[r0,#0xc]
0004ca  0640              LSLS     r0,r0,#25
0004cc  0f40              LSRS     r0,r0,#29
0004ce  1c40              ADDS     r0,r0,#1
0004d0  2201              MOVS     r2,#1
0004d2  4082              LSLS     r2,r2,r0
0004d4  4611              MOV      r1,r2
0004d6  4630              MOV      r0,r6
0004d8  f7fffffe          BL       __aeabi_uidivmod
0004dc  9008              STR      r0,[sp,#0x20]
                  |L1.1246|
;;;1039         }
;;;1040         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
0004de  9808              LDR      r0,[sp,#0x20]
0004e0  6020              STR      r0,[r4,#0]
;;;1041         break;
0004e2  e006              B        |L1.1266|
                  |L1.1252|
;;;1042       case 2 :
;;;1043         /* LSE */
;;;1044         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
0004e4  2001              MOVS     r0,#1
0004e6  03c0              LSLS     r0,r0,#15
0004e8  6020              STR      r0,[r4,#0]
;;;1045         break;
0004ea  e002              B        |L1.1266|
                  |L1.1260|
;;;1046       default : /* case 3 */
;;;1047         /* LSI */
;;;1048         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
0004ec  4849              LDR      r0,|L1.1556|
0004ee  6020              STR      r0,[r4,#0]
;;;1049         break;
0004f0  bf00              NOP      
                  |L1.1266|
0004f2  bf00              NOP                            ;1028
;;;1050     }
;;;1051   
;;;1052     /* Compute USB_CLK frequency */
;;;1053   
;;;1054     /* Determine USB_C1 frequency */
;;;1055     if (*(__IO uint32_t *) USB_C1_SEL1_BB)
0004f4  4845              LDR      r0,|L1.1548|
0004f6  3808              SUBS     r0,r0,#8
0004f8  0140              LSLS     r0,r0,#5
0004fa  2121              MOVS     r1,#0x21
0004fc  0649              LSLS     r1,r1,#25
0004fe  1840              ADDS     r0,r0,r1
000500  6840              LDR      r0,[r0,#4]
000502  2800              CMP      r0,#0
000504  d001              BEQ      |L1.1290|
;;;1056     {
;;;1057       usb_c1_freq = HSE_Value;
000506  4f42              LDR      r7,|L1.1552|
000508  e000              B        |L1.1292|
                  |L1.1290|
;;;1058     }
;;;1059     else
;;;1060     {
;;;1061       usb_c1_freq = HSI_Value;
00050a  4f41              LDR      r7,|L1.1552|
                  |L1.1292|
;;;1062     }
;;;1063   
;;;1064     if (*(__IO uint32_t *) USB_C1_SEL0_BB)
00050c  483f              LDR      r0,|L1.1548|
00050e  3808              SUBS     r0,r0,#8
000510  0140              LSLS     r0,r0,#5
000512  2121              MOVS     r1,#0x21
000514  0649              LSLS     r1,r1,#25
000516  1840              ADDS     r0,r0,r1
000518  6800              LDR      r0,[r0,#0]
00051a  2800              CMP      r0,#0
00051c  d000              BEQ      |L1.1312|
;;;1065     {
;;;1066       usb_c1_freq /= 2;
00051e  087f              LSRS     r7,r7,#1
                  |L1.1312|
;;;1067     }
;;;1068   
;;;1069     /* Determine USB_C2 frequency */
;;;1070     usb_c2_freq = usb_c1_freq;
000520  9707              STR      r7,[sp,#0x1c]
;;;1071   
;;;1072     if (*(__IO uint32_t *) USB_C2_SEL_BB != 0)
000522  483a              LDR      r0,|L1.1548|
000524  3808              SUBS     r0,r0,#8
000526  0140              LSLS     r0,r0,#5
000528  2121              MOVS     r1,#0x21
00052a  0649              LSLS     r1,r1,#25
00052c  1840              ADDS     r0,r0,r1
00052e  6880              LDR      r0,[r0,#8]
000530  2800              CMP      r0,#0
000532  d009              BEQ      |L1.1352|
;;;1073     {
;;;1074       /* Determine USB PLL output frequency */
;;;1075       pll_mul = ((RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_OFFS) & (uint32_t)0x0F) + 1;
000534  4834              LDR      r0,|L1.1544|
000536  6840              LDR      r0,[r0,#4]
000538  0600              LSLS     r0,r0,#24
00053a  0f00              LSRS     r0,r0,#28
00053c  1c40              ADDS     r0,r0,#1
00053e  9000              STR      r0,[sp,#0]
;;;1076       usb_c2_freq *= pll_mul;
000540  9900              LDR      r1,[sp,#0]
000542  9807              LDR      r0,[sp,#0x1c]
000544  4348              MULS     r0,r1,r0
000546  9007              STR      r0,[sp,#0x1c]
                  |L1.1352|
;;;1077     }
;;;1078   
;;;1079     /* Determine USB_C3 frequency */
;;;1080     usb_c3_freq = usb_c2_freq;
000548  9807              LDR      r0,[sp,#0x1c]
00054a  9006              STR      r0,[sp,#0x18]
;;;1081     if (*(__IO uint32_t *) USB_C3_SEL_BB != 0)
00054c  482f              LDR      r0,|L1.1548|
00054e  3808              SUBS     r0,r0,#8
000550  0140              LSLS     r0,r0,#5
000552  2121              MOVS     r1,#0x21
000554  0649              LSLS     r1,r1,#25
000556  1840              ADDS     r0,r0,r1
000558  6900              LDR      r0,[r0,#0x10]
00055a  2800              CMP      r0,#0
00055c  d002              BEQ      |L1.1380|
;;;1082     {
;;;1083       usb_c3_freq /= 2;
00055e  9806              LDR      r0,[sp,#0x18]
000560  0840              LSRS     r0,r0,#1
000562  9006              STR      r0,[sp,#0x18]
                  |L1.1380|
;;;1084     }
;;;1085   
;;;1086     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
000564  9806              LDR      r0,[sp,#0x18]
000566  6060              STR      r0,[r4,#4]
;;;1087   
;;;1088     /* Compute RTCHSE_CLK frequency */
;;;1089     hsi_c1_freq = HSI_Value/((RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_OFFS & (uint32_t)0x0F) + 1);
000568  4827              LDR      r0,|L1.1544|
00056a  6980              LDR      r0,[r0,#0x18]
00056c  0600              LSLS     r0,r0,#24
00056e  0f00              LSRS     r0,r0,#28
000570  1c41              ADDS     r1,r0,#1
000572  4827              LDR      r0,|L1.1552|
000574  f7fffffe          BL       __aeabi_uidivmod
000578  9002              STR      r0,[sp,#8]
;;;1090     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
00057a  9802              LDR      r0,[sp,#8]
00057c  60e0              STR      r0,[r4,#0xc]
;;;1091   
;;;1092     /* Compute RTCHSI_CLK frequency */
;;;1093     hse_c1_freq = HSE_Value/((RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_OFFS & (uint32_t)0x0F) + 1);
00057e  4822              LDR      r0,|L1.1544|
000580  6980              LDR      r0,[r0,#0x18]
000582  0700              LSLS     r0,r0,#28
000584  0f00              LSRS     r0,r0,#28
000586  1c41              ADDS     r1,r0,#1
000588  4821              LDR      r0,|L1.1552|
00058a  f7fffffe          BL       __aeabi_uidivmod
00058e  9001              STR      r0,[sp,#4]
;;;1094     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
000590  9801              LDR      r0,[sp,#4]
000592  6120              STR      r0,[r4,#0x10]
;;;1095   
;;;1096     /* Compute ADC_CLK frequency */
;;;1097   
;;;1098     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1099     switch ((RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_OFFS) & (uint32_t)0x03)
000594  481c              LDR      r0,|L1.1544|
000596  6940              LDR      r0,[r0,#0x14]
000598  0780              LSLS     r0,r0,#30
00059a  0f80              LSRS     r0,r0,#30
00059c  d004              BEQ      |L1.1448|
00059e  2801              CMP      r0,#1
0005a0  d004              BEQ      |L1.1452|
0005a2  2802              CMP      r0,#2
0005a4  d106              BNE      |L1.1460|
0005a6  e003              B        |L1.1456|
                  |L1.1448|
;;;1100     {
;;;1101       case 0 :
;;;1102         /* CPU_C1 */
;;;1103         adc_c1_freq = cpu_c1_freq;
0005a8  9505              STR      r5,[sp,#0x14]
;;;1104         break;
0005aa  e006              B        |L1.1466|
                  |L1.1452|
;;;1105       case 1 :
;;;1106         /* USB_C1 */
;;;1107         adc_c1_freq = usb_c1_freq;
0005ac  9705              STR      r7,[sp,#0x14]
;;;1108         break;
0005ae  e004              B        |L1.1466|
                  |L1.1456|
;;;1109       case 2 :
;;;1110         /* CPU_C2 */
;;;1111         adc_c1_freq = cpu_c2_freq;
0005b0  9605              STR      r6,[sp,#0x14]
;;;1112         break;
0005b2  e002              B        |L1.1466|
                  |L1.1460|
;;;1113       default : /* case 3 */
;;;1114         /* USB_C2 */
;;;1115         adc_c1_freq = usb_c2_freq;
0005b4  9807              LDR      r0,[sp,#0x1c]
0005b6  9005              STR      r0,[sp,#0x14]
;;;1116         break;
0005b8  bf00              NOP      
                  |L1.1466|
0005ba  bf00              NOP                            ;1104
;;;1117     }
;;;1118   
;;;1119     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1120     switch ((RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_OFFS) & (uint32_t)0x03)
0005bc  4812              LDR      r0,|L1.1544|
0005be  6940              LDR      r0,[r0,#0x14]
0005c0  0680              LSLS     r0,r0,#26
0005c2  0f80              LSRS     r0,r0,#30
0005c4  d004              BEQ      |L1.1488|
0005c6  2801              CMP      r0,#1
0005c8  d006              BEQ      |L1.1496|
0005ca  2802              CMP      r0,#2
0005cc  d10a              BNE      |L1.1508|
0005ce  e006              B        |L1.1502|
                  |L1.1488|
;;;1121     {
;;;1122       case 0 :
;;;1123         /* LSE */
;;;1124         adc_c2_freq = LSE_Value;
0005d0  2001              MOVS     r0,#1
0005d2  03c0              LSLS     r0,r0,#15
0005d4  9004              STR      r0,[sp,#0x10]
;;;1125         break;
0005d6  e008              B        |L1.1514|
                  |L1.1496|
;;;1126       case 1 :
;;;1127         /* LSI */
;;;1128         adc_c2_freq = LSI_Value;
0005d8  480e              LDR      r0,|L1.1556|
0005da  9004              STR      r0,[sp,#0x10]
;;;1129         break;
0005dc  e005              B        |L1.1514|
                  |L1.1502|
;;;1130       case 2 :
;;;1131         /* ADC_C1 */
;;;1132         adc_c2_freq = adc_c1_freq;
0005de  9805              LDR      r0,[sp,#0x14]
0005e0  9004              STR      r0,[sp,#0x10]
;;;1133         break;
0005e2  e002              B        |L1.1514|
                  |L1.1508|
;;;1134       default : /* case 3 */
;;;1135         /* HSI_C1 */
;;;1136         adc_c2_freq = hsi_c1_freq;
0005e4  9802              LDR      r0,[sp,#8]
0005e6  9004              STR      r0,[sp,#0x10]
;;;1137         break;
0005e8  bf00              NOP      
                  |L1.1514|
0005ea  bf00              NOP                            ;1125
;;;1138     }
;;;1139   
;;;1140     adc_c3_freq = adc_c2_freq /((RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_OFFS & (uint32_t)0x0F) + 1);
0005ec  4806              LDR      r0,|L1.1544|
0005ee  6940              LDR      r0,[r0,#0x14]
0005f0  0500              LSLS     r0,r0,#20
0005f2  0f00              LSRS     r0,r0,#28
0005f4  1c41              ADDS     r1,r0,#1
0005f6  9804              LDR      r0,[sp,#0x10]
0005f8  f7fffffe          BL       __aeabi_uidivmod
0005fc  9003              STR      r0,[sp,#0xc]
;;;1141     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
0005fe  9803              LDR      r0,[sp,#0xc]
000600  60a0              STR      r0,[r4,#8]
;;;1142   }
000602  b009              ADD      sp,sp,#0x24
000604  bdf0              POP      {r4-r7,pc}
;;;1143   
                          ENDP

000606  0000              DCW      0x0000
                  |L1.1544|
                          DCD      0x40020000
                  |L1.1548|
                          DCD      0x00020018
                  |L1.1552|
                          DCD      0x007a1200
                  |L1.1556|
                          DCD      0x00009c40
